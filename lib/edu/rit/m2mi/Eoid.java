//******************************************************************************
//
// File:    Eoid.java
// Package: edu.rit.m2mi
// Unit:    Class edu.rit.m2mi.Eoid
//
// This Java source file is copyright (C) 2001-2004 by Alan Kaminsky. All rights
// reserved. For further information, contact the author, Alan Kaminsky, at
// ark@cs.rit.edu.
//
// This Java source file is part of the M2MI Library ("The Library"). The
// Library is free software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the Free Software
// Foundation; either version 2 of the License, or (at your option) any later
// version.
//
// The Library is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
// details.
//
// A copy of the GNU General Public License is provided in the file gpl.txt. You
// may also obtain a copy of the GNU General Public License on the World Wide
// Web at http://www.gnu.org/licenses/gpl.html or by writing to the Free
// Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
// USA.
//
//******************************************************************************

package edu.rit.m2mi;

import edu.rit.device.DeviceProperties;

import edu.rit.util.Platform;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;

/**
 * Class Eoid encapsulates an exported object identifier (EOID). An EOID
 * uniquely identifies an object that has been exported to the M2MI layer. An
 * EOID is a 128-bit value consisting of the following fields (from most
 * significant to least significant): a 48-bit sequence number, a 48-bit device
 * ID, and a 32-bit process ID. The <I>wildcard</I> EOID, which designates all
 * objects that implement a certain target interface, has a value of 0.
 * <P>
 * Class Eoid provides the <TT>next()</TT> method to generate a series of EOIDs.
 * The first generated EOID has its sequence number initialized from the system
 * clock (<TT>System.currentTimeMillis()</TT>); has its device ID initialized to
 * the device's globally unique device ID from the device properties file (see
 * class {@link DeviceProperties </CODE>DeviceProperties<CODE>}); and has its
 * process ID initialized to that of the current process (see class {@link
 * edu.rit.util.Platform </CODE>Platform<CODE>}). Thereafter, each successively
 * generated EOID has a sequence number 1 greater than the previous EOID and has
 * the same device ID and process ID.
 * <P>
 * Class Eoid also provides the <TT>increment()</TT> method to generate an EOID
 * that is "1 greater" than an existing EOID. The new EOID's sequence number is
 * set to 1 greater than the existing EOID's sequence number. The new EOID's
 * device ID and process ID are set to those of the current device and process.
 * Class Eoid further provides the <TT>compareTo</TT> method for determining the
 * order of two EOIDs and the <TT>max()</TT> and <TT>min()</TT> methods for
 * choosing the larger or smaller of two EOIDs. Thus, EOIDs can be used as
 * Lamport timestamp values for a logical clock in a distributed system.
 *
 * @author  Alan Kaminsky
 * @version 26-Aug-2004
 */
public class Eoid
	implements Comparable, Externalizable
	{

// Hidden data members.

	// For generating EOIDs from this device and process.
	private static long seqnumgen;
	private static long mswordgen;
	private static long lswordgen;
	static
		{
		seqnumgen = System.currentTimeMillis() << 16;
		long deviceid = DeviceProperties.getDeviceID();
		int processid = Platform.getProcessID();
		mswordgen =
			((deviceid  >> 32) & 0x000000000000FFFFL);
		lswordgen =
			((deviceid  << 32) & 0xFFFFFFFF00000000L) |
			((processid      ) & 0x00000000FFFFFFFFL);
		}

	// Most significant word and least significant word of this EOID.
	private long msword;
	private long lsword;

// Exported constants.

	/**
	 * The wildcard EOID.
	 */
	public static final Eoid WILDCARD = new Eoid();

// Exported constructors.

	/**
	 * Construct a new EOID. The EOID's value is 0, which stands for a wildcard
	 * value.
	 */
	public Eoid()
		{
		}

// Exported operations.

	/**
	 * Generate the next EOID in the series of generated EOIDs. The new EOID's
	 * sequence number is 1 higher than the sequence number of the last EOID
	 * generated by <TT>next()</TT>; if this is the first time <TT>next()</TT>
	 * has been called, the new EOID's sequence number is initialized from the
	 * system clock. The new EOID's device ID and process ID are those of the
	 * current device and process.
	 *
	 * @return  Next EOID.
	 */
	public synchronized static Eoid next()
		{
		Eoid eoid = new Eoid();
		eoid.msword = seqnumgen | mswordgen;
		eoid.lsword = lswordgen;
		seqnumgen += 0x10000L;
		return eoid;
		}

	/**
	 * Generate the next EOID after this EOID. The new EOID's sequence number is
	 * 1 higher than this EOID's sequence number. The new EOID's device ID and
	 * process ID are those of the current device and process.
	 *
	 * @return  The next EOID after this EOID.
	 */
	public Eoid increment()
		{
		Eoid eoid = new Eoid();
		eoid.msword =
			((this.msword & 0xFFFFFFFFFFFF0000L) + 0x10000L) | mswordgen;
		eoid.lsword = lswordgen;
		return eoid;
		}

	/**
	 * Determine the larger of the two given EOIDs.
	 *
	 * @param  eoid1  First EOID.
	 * @param  eoid2  Second EOID.
	 *
	 * @return  <TT>eoid1</TT> if <TT>eoid1</TT> &gt;= <TT>eoid2</TT>;
	 *          <TT>eoid2</TT> if <TT>eoid1</TT> &lt; <TT>eoid2</TT>.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>eoid1</TT> is null or
	 *     <TT>eoid2</TT> is null.
	 */
	public static Eoid max
		(Eoid eoid1,
		 Eoid eoid2)
		{
		return eoid1.compareTo (eoid2) >= 0 ? eoid1 : eoid2;
		}

	/**
	 * Determine the smaller of the two given EOIDs.
	 *
	 * @param  eoid1  First EOID.
	 * @param  eoid2  Second EOID.
	 *
	 * @return  <TT>eoid1</TT> if <TT>eoid1</TT> &lt;= <TT>eoid2</TT>;
	 *          <TT>eoid2</TT> if <TT>eoid1</TT> &gt; <TT>eoid2</TT>.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>eoid1</TT> is null or
	 *     <TT>eoid2</TT> is null.
	 */
	public static Eoid min
		(Eoid eoid1,
		 Eoid eoid2)
		{
		return eoid1.compareTo (eoid2) <= 0 ? eoid1 : eoid2;
		}

	/**
	 * Compare this EOID with the given object.
	 *
	 * @param  obj  Object to compare to. It must be a non-null instance of
	 *              class Eoid.
	 *
	 * @return  A number less than 0 if this EOID is less than <TT>obj</TT>; 0
	 *          if this EOID is equal to <TT>obj</TT>; a number greater than 0
	 *          if this EOID is greater than <TT>obj</TT>.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>obj</TT> is null.
	 * @exception  ClassCastException
	 *     (unchecked exception) Thrown if <TT>obj</TT> is not an instance of
	 *     class Eoid.
	 */
	public int compareTo
		(Object obj)
		{
		Eoid that = (Eoid) obj;
		return
			this.msword < that.msword ? -1 :
			this.msword > that.msword ? +1 :
			this.lsword < that.lsword ? -1 :
			this.lsword > that.lsword ? +1 : 0;
		}

	/**
	 * Determine if this EOID is equal to the given object.
	 *
	 * @param  obj  Object to test.
	 *
	 * @return  True if <TT>obj</TT> is a non-null instance of class Eoid with
	 *          the same value as this EOID, false otherwise.
	 */
	public boolean equals
		(Object obj)
		{
		return
			obj instanceof Eoid &&
			this.msword == ((Eoid) obj).msword &&
			this.lsword == ((Eoid) obj).lsword;
		}

	/**
	 * Returns a hash code for this EOID.
	 *
	 * @return  Hash code.
	 */
	public int hashCode()
		{
		return
			((int) (msword >> 32)) +
			((int) (msword      )) +
			((int) (lsword >> 32)) +
			((int) (lsword      ));
		}

	/**
	 * Returns a string version of this EOID. The sequence number, device ID,
	 * and process ID field values are displayed in hexadecimal with hyphens in
	 * between.
	 */
	public String toString()
		{
		StringBuffer result = new StringBuffer();
		result.append (hexdigit[(int)(msword >> 60) & 0xF]);
		result.append (hexdigit[(int)(msword >> 56) & 0xF]);
		result.append (hexdigit[(int)(msword >> 52) & 0xF]);
		result.append (hexdigit[(int)(msword >> 48) & 0xF]);
		result.append (hexdigit[(int)(msword >> 44) & 0xF]);
		result.append (hexdigit[(int)(msword >> 40) & 0xF]);
		result.append (hexdigit[(int)(msword >> 36) & 0xF]);
		result.append (hexdigit[(int)(msword >> 32) & 0xF]);
		result.append (hexdigit[(int)(msword >> 28) & 0xF]);
		result.append (hexdigit[(int)(msword >> 24) & 0xF]);
		result.append (hexdigit[(int)(msword >> 20) & 0xF]);
		result.append (hexdigit[(int)(msword >> 16) & 0xF]);
		result.append ('-');
		result.append (hexdigit[(int)(msword >> 12) & 0xF]);
		result.append (hexdigit[(int)(msword >>  8) & 0xF]);
		result.append (hexdigit[(int)(msword >>  4) & 0xF]);
		result.append (hexdigit[(int)(msword      ) & 0xF]);
		result.append (hexdigit[(int)(lsword >> 60) & 0xF]);
		result.append (hexdigit[(int)(lsword >> 56) & 0xF]);
		result.append (hexdigit[(int)(lsword >> 52) & 0xF]);
		result.append (hexdigit[(int)(lsword >> 48) & 0xF]);
		result.append (hexdigit[(int)(lsword >> 44) & 0xF]);
		result.append (hexdigit[(int)(lsword >> 40) & 0xF]);
		result.append (hexdigit[(int)(lsword >> 36) & 0xF]);
		result.append (hexdigit[(int)(lsword >> 32) & 0xF]);
		result.append ('-');
		result.append (hexdigit[(int)(lsword >> 28) & 0xF]);
		result.append (hexdigit[(int)(lsword >> 24) & 0xF]);
		result.append (hexdigit[(int)(lsword >> 20) & 0xF]);
		result.append (hexdigit[(int)(lsword >> 16) & 0xF]);
		result.append (hexdigit[(int)(lsword >> 12) & 0xF]);
		result.append (hexdigit[(int)(lsword >>  8) & 0xF]);
		result.append (hexdigit[(int)(lsword >>  4) & 0xF]);
		result.append (hexdigit[(int)(lsword      ) & 0xF]);
		return result.toString();
		}

	private static final char[] hexdigit = new char[]
		{'0', '1', '2', '3', '4', '5', '6', '7',
		 '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

	/**
	 * Write this EOID to the given data output stream.
	 *
	 * @param  theDataOutput  Data output stream.
	 *
	 * @exception  IOException
	 *     Thrown if an I/O error occurred.
	 */
	public void write
		(DataOutput theDataOutput)
		throws IOException
		{
		theDataOutput.writeLong (msword);
		theDataOutput.writeLong (lsword);
		}

	/**
	 * Read this EOID from the given data input stream. This method assumes the
	 * value was written to the stream by {@link #write(java.io.DataOutput)
	 * write()}.
	 *
	 * @param  theDataInput  Data input stream.
	 *
	 * @exception  IOException
	 *     Thrown if an I/O error occurred.
	 */
	public void read
		(DataInput theDataInput)
		throws IOException
		{
		msword = theDataInput.readLong();
		lsword = theDataInput.readLong();
		}

	/**
	 * Write this EOID to the given object output stream.
	 *
	 * @param  theObjectOutput  Object output stream.
	 *
	 * @exception  IOException
	 *     Thrown if an I/O error occurred.
	 */
	public void writeExternal
		(ObjectOutput theObjectOutput)
		throws IOException
		{
		write (theObjectOutput);
		}

	/**
	 * Read this EOID from the given object input stream. This method assumes
	 * the value was written to the stream by {@link
	 * #writeExternal(java.io.ObjectOutput) writeExternal()}.
	 *
	 * @param  theObjectInput  Object input stream.
	 *
	 * @exception  IOException
	 *     Thrown if an I/O error occurred.
	 */
	public void readExternal
		(ObjectInput theObjectInput)
		throws IOException
		{
		read (theObjectInput);
		}

// Unit test main program.

//*DBG*/	public static void main
//*DBG*/		(String[] args)
//*DBG*/		{
//*DBG*/		try
//*DBG*/			{
//*DBG*/			int n = 10;
//*DBG*/			Eoid[] eoid = new Eoid [n];
//*DBG*/			for (int i = 0; i < n; ++ i)
//*DBG*/				{
//*DBG*/				eoid[i] = Eoid.next();
//*DBG*/				System.out.println ("[" + i + "] " + eoid[i]);
//*DBG*/				}
//*DBG*/			System.out.println
//*DBG*/				("max([4],[5]) = " + Eoid.max (eoid[4], eoid[5]));
//*DBG*/			System.out.println
//*DBG*/				("max([5],[5]) = " + Eoid.max (eoid[5], eoid[5]));
//*DBG*/			System.out.println
//*DBG*/				("max([6],[5]) = " + Eoid.max (eoid[6], eoid[5]));
//*DBG*/			System.out.println
//*DBG*/				("min([4],[5]) = " + Eoid.min (eoid[4], eoid[5]));
//*DBG*/			System.out.println
//*DBG*/				("min([5],[5]) = " + Eoid.min (eoid[5], eoid[5]));
//*DBG*/			System.out.println
//*DBG*/				("min([6],[5]) = " + Eoid.min (eoid[6], eoid[5]));
//*DBG*/			}
//*DBG*/		catch (Throwable exc)
//*DBG*/			{
//*DBG*/			exc.printStackTrace (System.err);
//*DBG*/			System.exit (1);
//*DBG*/			}
//*DBG*/		}

	}
