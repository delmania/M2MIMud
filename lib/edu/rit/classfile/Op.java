//******************************************************************************
//
// File:    Op.java
// Package: edu.rit.classfile
// Unit:    Class edu.rit.classfile.Op
//
// This Java source file is copyright (C) 2001-2004 by Alan Kaminsky. All rights
// reserved. For further information, contact the author, Alan Kaminsky, at
// ark@cs.rit.edu.
//
// This Java source file is part of the RIT Classfile Library ("The Library").
// The Library is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free Software
// Foundation; either version 2 of the License, or (at your option) any later
// version.
//
// The Library is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
// details.
//
// A copy of the GNU General Public License is provided in the file gpl.txt. You
// may also obtain a copy of the GNU General Public License on the World Wide
// Web at http://www.gnu.org/licenses/gpl.html or by writing to the Free
// Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
// USA.
//
//******************************************************************************

package edu.rit.classfile;

/**
 * Class Op encapsulates all the opcodes used in Java bytecode instructions. To
 * create a particular {@link Instruction Instruction}, use the desired static
 * field or method in class Op. For example:
 * <PRE>
 *     SynthesizedMethodDescription theMethod = . . .;
 *     ClassReference javaLangObject = NamedClassReference.JAVA_LANG_OBJECT;
 *     SubroutineReference javaLangObjectInit = new ConstructorReference (javaLangObject);
 *     . . .
 *     theMethod.addInstruction (Op.ALOAD (0));
 *     theMethod.addInstruction (Op.INVOKESPECIAL (javaLangObjectInit));
 *     theMethod.addInstruction (Op.RETURN);</PRE>
 * <P>
 * Class Op provides certain "smart opcodes" that generate different Java
 * bytecodes, depending on the argument:
 * <UL>
 * <P><LI>
 * Java bytecodes <I>aload_0</I> through <I>aload_3, aload,</I> and <I>wide
 * aload</I> are generated by {@link #ALOAD(int) <TT>ALOAD(int)</TT>}.
 * <P><LI>
 * Java bytecodes <I>astore_0</I> through <I>astore_3, astore,</I> and <I>wide
 * astore</I> are generated by {@link #ASTORE(int) <TT>ASTORE(int)</TT>}.
 * <P><LI>
 * Java bytecodes <I>dload_0</I> through <I>dload_3, dload,</I> and <I>wide
 * dload</I> are generated by {@link #DLOAD(int) <TT>DLOAD(int)</TT>}.
 * <P><LI>
 * Java bytecodes <I>dstore_0</I> through <I>dstore_3, dstore,</I> and <I>wide
 * dstore</I> are generated by {@link #DSTORE(int) <TT>DSTORE(int)</TT>}.
 * <P><LI>
 * Java bytecodes <I>fload_0</I> through <I>fload_3, fload,</I> and <I>wide
 * fload</I> are generated by {@link #FLOAD(int) <TT>FLOAD(int)</TT>}.
 * <P><LI>
 * Java bytecodes <I>fstore_0</I> through <I>fstore_3, fstore,</I> and <I>wide
 * fstore</I> are generated by {@link #FSTORE(int) <TT>FSTORE(int)</TT>}.
 * <P><LI>
 * Java bytecodes <I>iinc</I> and <I>wide iinc</I> are generated by {@link
 * #IINC(int,int) <TT>IINC(int,int)</TT>}.
 * <P><LI>
 * Java bytecodes <I>iload_0</I> through <I>iload_3, iload,</I> and <I>wide
 * iload</I> are generated by {@link #ILOAD(int) <TT>ILOAD(int)</TT>}.
 * <P><LI>
 * Java bytecodes <I>istore_0</I> through <I>istore_3, istore,</I> and <I>wide
 * istore</I> are generated by {@link #ISTORE(int) <TT>ISTORE(int)</TT>}.
 * <P><LI>
 * Java bytecodes <I>ldc</I> (for a string constant) and <I>ldc_w</I> (for a
 * string constant) are generated by {@link #LDC(java.lang.String)
 * <TT>LDC(String)</TT>}.
 * <P><LI>
 * Java bytecodes <I>iconst_m1</I> through <I>iconst_5, bipush, sipush, ldc</I>
 * (for an integer constant), and <I>ldc_w</I> (for an integer constant) are
 * generated by {@link #LDC(int) <TT>LDC(int)</TT>}.
 * <P><LI>
 * Java bytecodes <I>fconst_0</I> through <I>fconst_2, ldc</I> (for a float
 * constant), and <I>ldc_w</I> (for a float constant) are generated by {@link
 * #LDC(float) <TT>LDC(float)</TT>}.
 * <P><LI>
 * Java bytecodes <I>lconst_0, lconst_1,</I> and <I>ldc2_w</I> (for a long
 * constant) are generated by {@link #LDC(long) <TT>LDC(long)</TT>}.
 * <P><LI>
 * Java bytecodes <I>dconst_0, dconst_1,</I> and <I>ldc2_w</I> (for a double
 * constant) are generated by {@link #LDC(double) <TT>LDC(double)</TT>}.
 * <P><LI>
 * Java bytecodes <I>lload_0</I> through <I>lload_3, lload,</I> and <I>wide
 * lload</I> are generated by {@link #LLOAD(int) <TT>LLOAD(int)</TT>}.
 * <P><LI>
 * Java bytecodes <I>lstore_0</I> through <I>lstore_3, lstore,</I> and <I>wide
 * lstore</I> are generated by {@link #LSTORE(int) <TT>LSTORE(int)</TT>}.
 * <P><LI>
 * Java bytecodes <I>ret</I> and <I>wide ret</I> are generated by {@link
 * #RET(int) <TT>RET(int)</TT>}.
 * </UL>
 * <P>
 * Class Op provides the following "type sensitive opcodes" where the actual
 * opcode depends on a given type reference: {@link #TLOAD(int,TypeReference)
 * <TT>TLOAD</TT>}, {@link #TSTORE(int,TypeReference) <TT>TSTORE</TT>}.
 * <P>
 * For the official explanation of what each Java bytecode does, refer to
 * <A HREF="http://java.sun.com/docs/books/vmspec/2nd-edition/html/VMSpecTOC.doc.html"><I>The
 * Java&trade; Virtual Machine Specification, 2nd Edition</I></A> by Tim
 * Lindholm and Frank Yellin.
 *
 * @author  Alan Kaminsky
 * @version 26-Mar-2002
 */
public class Op
	{

// Hidden constructors.

	private Op()
		{
		}

// Hidden constants for opcodes.

	static final byte OP_NOP             = 0;
	static final byte OP_ACONST_NULL     = 1;
	static final byte OP_ICONST_M1       = 2;
	static final byte OP_ICONST_0        = 3;
	static final byte OP_ICONST_1        = 4;
	static final byte OP_ICONST_2        = 5;
	static final byte OP_ICONST_3        = 6;
	static final byte OP_ICONST_4        = 7;
	static final byte OP_ICONST_5        = 8;
	static final byte OP_LCONST_0        = 9;
	static final byte OP_LCONST_1        = 10;
	static final byte OP_FCONST_0        = 11;
	static final byte OP_FCONST_1        = 12;
	static final byte OP_FCONST_2        = 13;
	static final byte OP_DCONST_0        = 14;
	static final byte OP_DCONST_1        = 15;
	static final byte OP_BIPUSH          = 16;
	static final byte OP_SIPUSH          = 17;
	static final byte OP_LDC             = 18;
	static final byte OP_LDC_W           = 19;
	static final byte OP_LDC2_W          = 20;
	static final byte OP_ILOAD           = 21;
	static final byte OP_LLOAD           = 22;
	static final byte OP_FLOAD           = 23;
	static final byte OP_DLOAD           = 24;
	static final byte OP_ALOAD           = 25;
	static final byte OP_ILOAD_0         = 26;
	static final byte OP_ILOAD_1         = 27;
	static final byte OP_ILOAD_2         = 28;
	static final byte OP_ILOAD_3         = 29;
	static final byte OP_LLOAD_0         = 30;
	static final byte OP_LLOAD_1         = 31;
	static final byte OP_LLOAD_2         = 32;
	static final byte OP_LLOAD_3         = 33;
	static final byte OP_FLOAD_0         = 34;
	static final byte OP_FLOAD_1         = 35;
	static final byte OP_FLOAD_2         = 36;
	static final byte OP_FLOAD_3         = 37;
	static final byte OP_DLOAD_0         = 38;
	static final byte OP_DLOAD_1         = 39;
	static final byte OP_DLOAD_2         = 40;
	static final byte OP_DLOAD_3         = 41;
	static final byte OP_ALOAD_0         = 42;
	static final byte OP_ALOAD_1         = 43;
	static final byte OP_ALOAD_2         = 44;
	static final byte OP_ALOAD_3         = 45;
	static final byte OP_IALOAD          = 46;
	static final byte OP_LALOAD          = 47;
	static final byte OP_FALOAD          = 48;
	static final byte OP_DALOAD          = 49;
	static final byte OP_AALOAD          = 50;
	static final byte OP_BALOAD          = 51;
	static final byte OP_CALOAD          = 52;
	static final byte OP_SALOAD          = 53;
	static final byte OP_ISTORE          = 54;
	static final byte OP_LSTORE          = 55;
	static final byte OP_FSTORE          = 56;
	static final byte OP_DSTORE          = 57;
	static final byte OP_ASTORE          = 58;
	static final byte OP_ISTORE_0        = 59;
	static final byte OP_ISTORE_1        = 60;
	static final byte OP_ISTORE_2        = 61;
	static final byte OP_ISTORE_3        = 62;
	static final byte OP_LSTORE_0        = 63;
	static final byte OP_LSTORE_1        = 64;
	static final byte OP_LSTORE_2        = 65;
	static final byte OP_LSTORE_3        = 66;
	static final byte OP_FSTORE_0        = 67;
	static final byte OP_FSTORE_1        = 68;
	static final byte OP_FSTORE_2        = 69;
	static final byte OP_FSTORE_3        = 70;
	static final byte OP_DSTORE_0        = 71;
	static final byte OP_DSTORE_1        = 72;
	static final byte OP_DSTORE_2        = 73;
	static final byte OP_DSTORE_3        = 74;
	static final byte OP_ASTORE_0        = 75;
	static final byte OP_ASTORE_1        = 76;
	static final byte OP_ASTORE_2        = 77;
	static final byte OP_ASTORE_3        = 78;
	static final byte OP_IASTORE         = 79;
	static final byte OP_LASTORE         = 80;
	static final byte OP_FASTORE         = 81;
	static final byte OP_DASTORE         = 82;
	static final byte OP_AASTORE         = 83;
	static final byte OP_BASTORE         = 84;
	static final byte OP_CASTORE         = 85;
	static final byte OP_SASTORE         = 86;
	static final byte OP_POP             = 87;
	static final byte OP_POP2            = 88;
	static final byte OP_DUP             = 89;
	static final byte OP_DUP_X1          = 90;
	static final byte OP_DUP_X2          = 91;
	static final byte OP_DUP2            = 92;
	static final byte OP_DUP2_X1         = 93;
	static final byte OP_DUP2_X2         = 94;
	static final byte OP_SWAP            = 95;
	static final byte OP_IADD            = 96;
	static final byte OP_LADD            = 97;
	static final byte OP_FADD            = 98;
	static final byte OP_DADD            = 99;
	static final byte OP_ISUB            = 100;
	static final byte OP_LSUB            = 101;
	static final byte OP_FSUB            = 102;
	static final byte OP_DSUB            = 103;
	static final byte OP_IMUL            = 104;
	static final byte OP_LMUL            = 105;
	static final byte OP_FMUL            = 106;
	static final byte OP_DMUL            = 107;
	static final byte OP_IDIV            = 108;
	static final byte OP_LDIV            = 109;
	static final byte OP_FDIV            = 110;
	static final byte OP_DDIV            = 111;
	static final byte OP_IREM            = 112;
	static final byte OP_LREM            = 113;
	static final byte OP_FREM            = 114;
	static final byte OP_DREM            = 115;
	static final byte OP_INEG            = 116;
	static final byte OP_LNEG            = 117;
	static final byte OP_FNEG            = 118;
	static final byte OP_DNEG            = 119;
	static final byte OP_ISHL            = 120;
	static final byte OP_LSHL            = 121;
	static final byte OP_ISHR            = 122;
	static final byte OP_LSHR            = 123;
	static final byte OP_IUSHR           = 124;
	static final byte OP_LUSHR           = 125;
	static final byte OP_IAND            = 126;
	static final byte OP_LAND            = 127;
	static final byte OP_IOR             = (byte) 128;
	static final byte OP_LOR             = (byte) 129;
	static final byte OP_IXOR            = (byte) 130;
	static final byte OP_LXOR            = (byte) 131;
	static final byte OP_IINC            = (byte) 132;
	static final byte OP_I2L             = (byte) 133;
	static final byte OP_I2F             = (byte) 134;
	static final byte OP_I2D             = (byte) 135;
	static final byte OP_L2I             = (byte) 136;
	static final byte OP_L2F             = (byte) 137;
	static final byte OP_L2D             = (byte) 138;
	static final byte OP_F2I             = (byte) 139;
	static final byte OP_F2L             = (byte) 140;
	static final byte OP_F2D             = (byte) 141;
	static final byte OP_D2I             = (byte) 142;
	static final byte OP_D2L             = (byte) 143;
	static final byte OP_D2F             = (byte) 144;
	static final byte OP_I2B             = (byte) 145;
	static final byte OP_I2C             = (byte) 146;
	static final byte OP_I2S             = (byte) 147;
	static final byte OP_LCMP            = (byte) 148;
	static final byte OP_FCMPL           = (byte) 149;
	static final byte OP_FCMPG           = (byte) 150;
	static final byte OP_DCMPL           = (byte) 151;
	static final byte OP_DCMPG           = (byte) 152;
	static final byte OP_IFEQ            = (byte) 153;
	static final byte OP_IFNE            = (byte) 154;
	static final byte OP_IFLT            = (byte) 155;
	static final byte OP_IFGE            = (byte) 156;
	static final byte OP_IFGT            = (byte) 157;
	static final byte OP_IFLE            = (byte) 158;
	static final byte OP_IF_ICMPEQ       = (byte) 159;
	static final byte OP_IF_ICMPNE       = (byte) 160;
	static final byte OP_IF_ICMPLT       = (byte) 161;
	static final byte OP_IF_ICMPGE       = (byte) 162;
	static final byte OP_IF_ICMPGT       = (byte) 163;
	static final byte OP_IF_ICMPLE       = (byte) 164;
	static final byte OP_IF_ACMPEQ       = (byte) 165;
	static final byte OP_IF_ACMPNE       = (byte) 166;
	static final byte OP_GOTO            = (byte) 167;
	static final byte OP_JSR             = (byte) 168;
	static final byte OP_RET             = (byte) 169;
	static final byte OP_TABLESWITCH     = (byte) 170;
	static final byte OP_LOOKUPSWITCH    = (byte) 171;
	static final byte OP_IRETURN         = (byte) 172;
	static final byte OP_LRETURN         = (byte) 173;
	static final byte OP_FRETURN         = (byte) 174;
	static final byte OP_DRETURN         = (byte) 175;
	static final byte OP_ARETURN         = (byte) 176;
	static final byte OP_RETURN          = (byte) 177;
	static final byte OP_GETSTATIC       = (byte) 178;
	static final byte OP_PUTSTATIC       = (byte) 179;
	static final byte OP_GETFIELD        = (byte) 180;
	static final byte OP_PUTFIELD        = (byte) 181;
	static final byte OP_INVOKEVIRTUAL   = (byte) 182;
	static final byte OP_INVOKESPECIAL   = (byte) 183;
	static final byte OP_INVOKESTATIC    = (byte) 184;
	static final byte OP_INVOKEINTERFACE = (byte) 185;
	static final byte OP_NEW             = (byte) 187;
	static final byte OP_NEWARRAY        = (byte) 188;
	static final byte OP_ANEWARRAY       = (byte) 189;
	static final byte OP_ARRAYLENGTH     = (byte) 190;
	static final byte OP_ATHROW          = (byte) 191;
	static final byte OP_CHECKCAST       = (byte) 192;
	static final byte OP_INSTANCEOF      = (byte) 193;
	static final byte OP_MONITORENTER    = (byte) 194;
	static final byte OP_MONITOREXIT     = (byte) 195;
	static final byte OP_WIDE            = (byte) 196;
	static final byte OP_MULTIANEWARRAY  = (byte) 197;
	static final byte OP_IFNULL          = (byte) 198;
	static final byte OP_IFNONNULL       = (byte) 199;
	static final byte OP_GOTO_W          = (byte) 200;
	static final byte OP_JSR_W           = (byte) 201;

	static final Instruction[] ALOAD_N_INSTRUCTION = new Instruction[]
		{
		new OneByteInstruction (OP_ALOAD_0),
		new OneByteInstruction (OP_ALOAD_1),
		new OneByteInstruction (OP_ALOAD_2),
		new OneByteInstruction (OP_ALOAD_3)
		};

	static final Instruction[] ASTORE_N_INSTRUCTION = new Instruction[]
		{
		new OneByteInstruction (OP_ASTORE_0),
		new OneByteInstruction (OP_ASTORE_1),
		new OneByteInstruction (OP_ASTORE_2),
		new OneByteInstruction (OP_ASTORE_3)
		};

	static final Instruction[] DLOAD_N_INSTRUCTION = new Instruction[]
		{
		new OneByteInstruction (OP_DLOAD_0),
		new OneByteInstruction (OP_DLOAD_1),
		new OneByteInstruction (OP_DLOAD_2),
		new OneByteInstruction (OP_DLOAD_3)
		};

	static final Instruction[] DSTORE_N_INSTRUCTION = new Instruction[]
		{
		new OneByteInstruction (OP_DSTORE_0),
		new OneByteInstruction (OP_DSTORE_1),
		new OneByteInstruction (OP_DSTORE_2),
		new OneByteInstruction (OP_DSTORE_3)
		};

	static final Instruction[] FLOAD_N_INSTRUCTION = new Instruction[]
		{
		new OneByteInstruction (OP_FLOAD_0),
		new OneByteInstruction (OP_FLOAD_1),
		new OneByteInstruction (OP_FLOAD_2),
		new OneByteInstruction (OP_FLOAD_3)
		};

	static final Instruction[] FSTORE_N_INSTRUCTION = new Instruction[]
		{
		new OneByteInstruction (OP_FSTORE_0),
		new OneByteInstruction (OP_FSTORE_1),
		new OneByteInstruction (OP_FSTORE_2),
		new OneByteInstruction (OP_FSTORE_3)
		};

	static final Instruction[] ICONST_N_INSTRUCTION = new Instruction[]
		{
		new OneByteInstruction (OP_ICONST_M1),
		new OneByteInstruction (OP_ICONST_0),
		new OneByteInstruction (OP_ICONST_1),
		new OneByteInstruction (OP_ICONST_2),
		new OneByteInstruction (OP_ICONST_3),
		new OneByteInstruction (OP_ICONST_4),
		new OneByteInstruction (OP_ICONST_5)
		};

	static final Instruction[] ILOAD_N_INSTRUCTION = new Instruction[]
		{
		new OneByteInstruction (OP_ILOAD_0),
		new OneByteInstruction (OP_ILOAD_1),
		new OneByteInstruction (OP_ILOAD_2),
		new OneByteInstruction (OP_ILOAD_3)
		};

	static final Instruction[] ISTORE_N_INSTRUCTION = new Instruction[]
		{
		new OneByteInstruction (OP_ISTORE_0),
		new OneByteInstruction (OP_ISTORE_1),
		new OneByteInstruction (OP_ISTORE_2),
		new OneByteInstruction (OP_ISTORE_3)
		};

	static final Instruction[] LLOAD_N_INSTRUCTION = new Instruction[]
		{
		new OneByteInstruction (OP_LLOAD_0),
		new OneByteInstruction (OP_LLOAD_1),
		new OneByteInstruction (OP_LLOAD_2),
		new OneByteInstruction (OP_LLOAD_3)
		};

	static final Instruction[] LSTORE_N_INSTRUCTION = new Instruction[]
		{
		new OneByteInstruction (OP_LSTORE_0),
		new OneByteInstruction (OP_LSTORE_1),
		new OneByteInstruction (OP_LSTORE_2),
		new OneByteInstruction (OP_LSTORE_3)
		};

// Exported fields.

	/**
	 * An <I>aaload</I> instruction. This loads a <TT>reference</TT> value from
	 * an array.
	 */
	public static final Instruction AALOAD =
		new OneByteInstruction (OP_AALOAD);

	/**
	 * An <I>aastore</I> instruction. This stores a <TT>reference</TT> value
	 * into an array.
	 */
	public static final Instruction AASTORE =
		new OneByteInstruction (OP_AASTORE);

	/**
	 * An <I>aconst_null</I> instruction. This pushes <TT>null</TT>.
	 */
	public static final Instruction ACONST_NULL =
		new OneByteInstruction (OP_ACONST_NULL);

	/**
	 * An <I>areturn</I> instruction. This returns a <TT>reference</TT> value
	 * from a method.
	 */
	public static final Instruction ARETURN =
		new OneByteInstruction (OP_ARETURN);

	/**
	 * An <I>arraylength</I> instruction. This gets the length of an array.
	 */
	public static final Instruction ARRAYLENGTH =
		new OneByteInstruction (OP_ARRAYLENGTH);

	/**
	 * An <I>athrow</I> instruction. This throws an exception or error.
	 */
	public static final Instruction ATHROW =
		new OneByteInstruction (OP_ATHROW);

	/**
	 * A <I>baload</I> instruction. This loads a <TT>byte</TT> or
	 * <TT>boolean</TT> value from an array.
	 */
	public static final Instruction BALOAD =
		new OneByteInstruction (OP_BALOAD);

	/**
	 * A <I>bastore</I> instruction. This stores a <TT>byte</TT> or
	 * <TT>boolean</TT> value into an array.
	 */
	public static final Instruction BASTORE =
		new OneByteInstruction (OP_BASTORE);

	/**
	 * A <I>caload</I> instruction. This loads a <TT>char</TT> value from an
	 * array.
	 */
	public static final Instruction CALOAD =
		new OneByteInstruction (OP_CALOAD);

	/**
	 * A <I>castore</I> instruction. This stores a <TT>char</TT> value into an
	 * array.
	 */
	public static final Instruction CASTORE =
		new OneByteInstruction (OP_CASTORE);

	/**
	 * A <I>d2f</I> instruction. This converts a <TT>double</TT> value to a
	 * <TT>float</TT> value.
	 */
	public static final Instruction D2F =
		new OneByteInstruction (OP_D2F);

	/**
	 * A <I>d2i</I> instruction. This converts a <TT>double</TT> value to an
	 * <TT>int</TT> value.
	 */
	public static final Instruction D2I =
		new OneByteInstruction (OP_D2I);

	/**
	 * A <I>d2l</I> instruction. This converts a <TT>double</TT> value to a
	 * <TT>long</TT> value.
	 */
	public static final Instruction D2L =
		new OneByteInstruction (OP_D2L);

	/**
	 * A <I>dadd</I> instruction. This adds two <TT>double</TT> values.
	 */
	public static final Instruction DADD =
		new OneByteInstruction (OP_DADD);

	/**
	 * A <I>daload</I> instruction. This loads a <TT>double</TT> value from an
	 * array.
	 */
	public static final Instruction DALOAD =
		new OneByteInstruction (OP_DALOAD);

	/**
	 * A <I>dastore</I> instruction. This stores a <TT>double</TT> value into an
	 * array.
	 */
	public static final Instruction DASTORE =
		new OneByteInstruction (OP_DASTORE);

	/**
	 * A <I>dcmpg</I> instruction. This compares two <TT>double</TT> values. If
	 * either value is NaN, the first value is considered to be greater than the
	 * second value.
	 */
	public static final Instruction DCMPG =
		new OneByteInstruction (OP_DCMPG);

	/**
	 * A <I>dcmpl</I> instruction. This compares two <TT>double</TT> values. If
	 * either value is NaN, the first value is considered to be less than the
	 * second value.
	 */
	public static final Instruction DCMPL =
		new OneByteInstruction (OP_DCMPL);

	/**
	 * A <I>dconst_0</I> instruction. This pushes the <TT>double</TT> value 0.0.
	 */
	private static final Instruction DCONST_0 =
		new OneByteInstruction (OP_DCONST_0);

	/**
	 * A <I>dconst_1</I> instruction. This pushes the <TT>double</TT> value 1.0.
	 */
	private static final Instruction DCONST_1 =
		new OneByteInstruction (OP_DCONST_1);

	/**
	 * A <I>ddiv</I> instruction. This divides two <TT>double</TT> values.
	 */
	public static final Instruction DDIV =
		new OneByteInstruction (OP_DDIV);

	/**
	 * A <I>dmul</I> instruction. This multiplies two <TT>double</TT> values.
	 */
	public static final Instruction DMUL =
		new OneByteInstruction (OP_DMUL);

	/**
	 * A <I>dneg</I> instruction. This negates a <TT>double</TT> value.
	 */
	public static final Instruction DNEG =
		new OneByteInstruction (OP_DNEG);

	/**
	 * A <I>drem</I> instruction. This computes the remainder from dividing two
	 * <TT>double</TT> values.
	 */
	public static final Instruction DREM =
		new OneByteInstruction (OP_DREM);

	/**
	 * A <I>dreturn</I> instruction. This returns a <TT>double</TT> value from a
	 * method.
	 */
	public static final Instruction DRETURN =
		new OneByteInstruction (OP_DRETURN);

	/**
	 * A <I>dsub</I> instruction. This subtracts two <TT>double</TT> values.
	 */
	public static final Instruction DSUB =
		new OneByteInstruction (OP_DSUB);

	/**
	 * A <I>dup</I> instruction. This pushes a copy of the word at the top of
	 * the operand stack.
	 */
	public static final Instruction DUP =
		new OneByteInstruction (OP_DUP);

	/**
	 * A <I>dup_x1</I> instruction. This inserts a copy of the word at the top
	 * of the operand stack below the two words at the top of the operand stack.
	 */
	public static final Instruction DUP_X1 =
		new OneByteInstruction (OP_DUP_X1);

	/**
	 * A <I>dup_x2</I> instruction. This inserts a copy of the word at the top
	 * of the operand stack below the three words at the top of the operand
	 * stack.
	 */
	public static final Instruction DUP_X2 =
		new OneByteInstruction (OP_DUP_X2);

	/**
	 * A <I>dup2</I> instruction. This pushes a copy of the two words at the top
	 * of the operand stack.
	 */
	public static final Instruction DUP2 =
		new OneByteInstruction (OP_DUP2);

	/**
	 * A <I>dup2_x1</I> instruction. This inserts a copy of the two words at the
	 * top of the operand stack below the three words at the top of the operand
	 * stack.
	 */
	public static final Instruction DUP2_X1 =
		new OneByteInstruction (OP_DUP2_X1);

	/**
	 * A <I>dup2_x2</I> instruction. This inserts a copy of the two words at the
	 * top of the operand stack below the four words at the top of the operand
	 * stack.
	 */
	public static final Instruction DUP2_X2 =
		new OneByteInstruction (OP_DUP2_X2);

	/**
	 * An <I>f2d</I> instruction. This converts a <TT>float</TT> value to a
	 * <TT>double</TT> value.
	 */
	public static final Instruction F2D =
		new OneByteInstruction (OP_F2D);

	/**
	 * An <I>f2i</I> instruction. This converts a <TT>float</TT> value to an
	 * <TT>int</TT> value.
	 */
	public static final Instruction F2I =
		new OneByteInstruction (OP_F2I);

	/**
	 * An <I>f2l</I> instruction. This converts a <TT>float</TT> value to a
	 * <TT>long</TT> value.
	 */
	public static final Instruction F2L =
		new OneByteInstruction (OP_F2L);

	/**
	 * An <I>fadd</I> instruction. This adds two <TT>float</TT> values.
	 */
	public static final Instruction FADD =
		new OneByteInstruction (OP_FADD);

	/**
	 * An <I>faload</I> instruction. This loads a <TT>float</TT> value from an
	 * array.
	 */
	public static final Instruction FALOAD =
		new OneByteInstruction (OP_FALOAD);

	/**
	 * An <I>fastore</I> instruction. This stores a <TT>float</TT> value into an
	 * array.
	 */
	public static final Instruction FASTORE =
		new OneByteInstruction (OP_FASTORE);

	/**
	 * An <I>fcmpg</I> instruction. This compares two <TT>float</TT> values. If
	 * either value is NaN, the first value is considered to be greater than the
	 * second value.
	 */
	public static final Instruction FCMPG =
		new OneByteInstruction (OP_FCMPG);

	/**
	 * An <I>fcmpl</I> instruction. This compares two <TT>float</TT> values. If
	 * either value is NaN, the first value is considered to be less than the
	 * second value.
	 */
	public static final Instruction FCMPL =
		new OneByteInstruction (OP_FCMPL);

	/**
	 * An <I>fconst_0</I> instruction. This pushes the <TT>float</TT> value
	 * 0.0f.
	 */
	private static final Instruction FCONST_0 =
		new OneByteInstruction (OP_FCONST_0);

	/**
	 * An <I>fconst_1</I> instruction. This pushes the <TT>float</TT> value
	 * 1.0f.
	 */
	private static final Instruction FCONST_1 =
		new OneByteInstruction (OP_FCONST_1);

	/**
	 * An <I>fconst_2</I> instruction. This pushes the <TT>float</TT> value
	 * 2.0f.
	 */
	private static final Instruction FCONST_2 =
		new OneByteInstruction (OP_FCONST_2);

	/**
	 * An <I>fdiv</I> instruction. This divides two <TT>float</TT> values.
	 */
	public static final Instruction FDIV =
		new OneByteInstruction (OP_FDIV);

	/**
	 * An <I>fmul</I> instruction. This multiplies two <TT>float</TT> values.
	 */
	public static final Instruction FMUL =
		new OneByteInstruction (OP_FMUL);

	/**
	 * An <I>fneg</I> instruction. This negates a <TT>float</TT> value.
	 */
	public static final Instruction FNEG =
		new OneByteInstruction (OP_FNEG);

	/**
	 * An <I>frem</I> instruction. This computes the remainder from dividing two
	 * <TT>float</TT> values.
	 */
	public static final Instruction FREM =
		new OneByteInstruction (OP_FREM);

	/**
	 * An <I>freturn</I> instruction. This returns a <TT>float</TT> value from a
	 * method.
	 */
	public static final Instruction FRETURN =
		new OneByteInstruction (OP_FRETURN);

	/**
	 * An <I>fsub</I> instruction. This subtracts two <TT>float</TT> values.
	 */
	public static final Instruction FSUB =
		new OneByteInstruction (OP_FSUB);

	/**
	 * An <I>i2b</I> instruction. This converts an <TT>int</TT> value to a
	 * <TT>byte</TT> value.
	 */
	public static final Instruction I2B =
		new OneByteInstruction (OP_I2B);

	/**
	 * An <I>i2c</I> instruction. This converts an <TT>int</TT> value to a
	 * <TT>char</TT> value.
	 */
	public static final Instruction I2C =
		new OneByteInstruction (OP_I2C);

	/**
	 * An <I>i2d</I> instruction. This converts an <TT>int</TT> value to a
	 * <TT>double</TT> value.
	 */
	public static final Instruction I2D =
		new OneByteInstruction (OP_I2D);

	/**
	 * An <I>i2f</I> instruction. This converts an <TT>int</TT> value to a
	 * <TT>float</TT> value.
	 */
	public static final Instruction I2F =
		new OneByteInstruction (OP_I2F);

	/**
	 * An <I>i2l</I> instruction. This converts an <TT>int</TT> value to a
	 * <TT>long</TT> value.
	 */
	public static final Instruction I2L =
		new OneByteInstruction (OP_I2L);

	/**
	 * An <I>i2s</I> instruction. This converts an <TT>int</TT> value to a
	 * <TT>short</TT> value.
	 */
	public static final Instruction I2S =
		new OneByteInstruction (OP_I2S);

	/**
	 * An <I>iadd</I> instruction. This adds two <TT>int</TT> values.
	 */
	public static final Instruction IADD =
		new OneByteInstruction (OP_IADD);

	/**
	 * An <I>iaload</I> instruction. This loads an <TT>int</TT> value from an
	 * array.
	 */
	public static final Instruction IALOAD =
		new OneByteInstruction (OP_IALOAD);

	/**
	 * An <I>iand</I> instruction. This bitwise-ands two <TT>int</TT> values.
	 */
	public static final Instruction IAND =
		new OneByteInstruction (OP_IAND);

	/**
	 * An <I>iastore</I> instruction. This stores an <TT>int</TT> value into an
	 * array.
	 */
	public static final Instruction IASTORE =
		new OneByteInstruction (OP_IASTORE);

	/**
	 * An <I>idiv</I> instruction. This divides two <TT>int</TT> values.
	 */
	public static final Instruction IDIV =
		new OneByteInstruction (OP_IDIV);

	/**
	 * An <I>imul</I> instruction. This multiplies two <TT>int</TT> values.
	 */
	public static final Instruction IMUL =
		new OneByteInstruction (OP_IMUL);

	/**
	 * An <I>ineg</I> instruction. This negates an <TT>int</TT> value.
	 */
	public static final Instruction INEG =
		new OneByteInstruction (OP_INEG);

	/**
	 * An <I>ior</I> instruction. This bitwise-ors two <TT>int</TT> values.
	 */
	public static final Instruction IOR =
		new OneByteInstruction (OP_IOR);

	/**
	 * An <I>irem</I> instruction. This computes the remainder from dividing two
	 * <TT>int</TT> values.
	 */
	public static final Instruction IREM =
		new OneByteInstruction (OP_IREM);

	/**
	 * An <I>ireturn</I> instruction. This returns an <TT>int</TT> value from a
	 * method.
	 */
	public static final Instruction IRETURN =
		new OneByteInstruction (OP_IRETURN);

	/**
	 * An <I>ishl</I> instruction. This left-shifts an <TT>int</TT> value.
	 */
	public static final Instruction ISHL =
		new OneByteInstruction (OP_ISHL);

	/**
	 * An <I>ishr</I> instruction. This arithmetic right-shifts an <TT>int</TT>
	 * value (with sign extension).
	 */
	public static final Instruction ISHR =
		new OneByteInstruction (OP_ISHR);

	/**
	 * An <I>isub</I> instruction. This subtracts two <TT>int</TT> values.
	 */
	public static final Instruction ISUB =
		new OneByteInstruction (OP_ISUB);

	/**
	 * An <I>iushr</I> instruction. This logical right-shifts an <TT>int</TT>
	 * value (with zero extension).
	 */
	public static final Instruction IUSHR =
		new OneByteInstruction (OP_IUSHR);

	/**
	 * An <I>ixor</I> instruction. This bitwise-exclusive-ors two <TT>int</TT>
	 * values.
	 */
	public static final Instruction IXOR =
		new OneByteInstruction (OP_IXOR);

	/**
	 * An <I>l2d</I> instruction. This converts a <TT>long</TT> value to a
	 * <TT>double</TT> value.
	 */
	public static final Instruction L2D =
		new OneByteInstruction (OP_L2D);

	/**
	 * An <I>l2f</I> instruction. This converts a <TT>long</TT> value to a
	 * <TT>float</TT> value.
	 */
	public static final Instruction L2F =
		new OneByteInstruction (OP_L2F);

	/**
	 * An <I>l2i</I> instruction. This converts a <TT>long</TT> value to an
	 * <TT>int</TT> value.
	 */
	public static final Instruction L2I =
		new OneByteInstruction (OP_L2I);

	/**
	 * An <I>ladd</I> instruction. This adds two <TT>long</TT> values.
	 */
	public static final Instruction LADD =
		new OneByteInstruction (OP_LADD);

	/**
	 * An <I>laload</I> instruction. This loads a <TT>long</TT> value from an
	 * array.
	 */
	public static final Instruction LALOAD =
		new OneByteInstruction (OP_LALOAD);

	/**
	 * An <I>land</I> instruction. This bitwise-ands two <TT>long</TT> values.
	 */
	public static final Instruction LAND =
		new OneByteInstruction (OP_LAND);

	/**
	 * An <I>lastore</I> instruction. This stores a <TT>long</TT> value into an
	 * array.
	 */
	public static final Instruction LASTORE =
		new OneByteInstruction (OP_LASTORE);

	/**
	 * An <I>lcmp</I> instruction. This compares two <TT>long</TT> values.
	 */
	public static final Instruction LCMP =
		new OneByteInstruction (OP_LCMP);

	/**
	 * An <I>lconst_0</I> instruction. This pushes the <TT>long</TT> value 0L.
	 */
	private static final Instruction LCONST_0 =
		new OneByteInstruction (OP_LCONST_0);

	/**
	 * An <I>lconst_1</I> instruction. This pushes the <TT>long</TT> value 1L.
	 */
	private static final Instruction LCONST_1 =
		new OneByteInstruction (OP_LCONST_1);

	/**
	 * An <I>ldiv</I> instruction. This divides two <TT>long</TT> values.
	 */
	public static final Instruction LDIV =
		new OneByteInstruction (OP_LDIV);

	/**
	 * An <I>lmul</I> instruction. This multiplies two <TT>long</TT> values.
	 */
	public static final Instruction LMUL =
		new OneByteInstruction (OP_LMUL);

	/**
	 * An <I>lneg</I> instruction. This negates a <TT>long</TT> value.
	 */
	public static final Instruction LNEG =
		new OneByteInstruction (OP_LNEG);

	/**
	 * An <I>lor</I> instruction. This bitwise-ors two <TT>long</TT> values.
	 */
	public static final Instruction LOR =
		new OneByteInstruction (OP_LOR);

	/**
	 * An <I>lrem</I> instruction. This computes the remainder from dividing two
	 * <TT>long</TT> values.
	 */
	public static final Instruction LREM =
		new OneByteInstruction (OP_LREM);

	/**
	 * An <I>lreturn</I> instruction. This returns a <TT>long</TT> value from a
	 * method.
	 */
	public static final Instruction LRETURN =
		new OneByteInstruction (OP_LRETURN);

	/**
	 * An <I>lshl</I> instruction. This left-shifts a <TT>long</TT> value.
	 */
	public static final Instruction LSHL =
		new OneByteInstruction (OP_LSHL);

	/**
	 * An <I>lshr</I> instruction. This arithmetic right-shifts a <TT>long</TT>
	 * value (with sign extension).
	 */
	public static final Instruction LSHR =
		new OneByteInstruction (OP_LSHR);

	/**
	 * An <I>lsub</I> instruction. This subtracts two <TT>long</TT> values.
	 */
	public static final Instruction LSUB =
		new OneByteInstruction (OP_LSUB);

	/**
	 * An <I>lushr</I> instruction. This logical right-shifts a <TT>long</TT>
	 * value (with zero extension).
	 */
	public static final Instruction LUSHR =
		new OneByteInstruction (OP_LUSHR);

	/**
	 * An <I>lxor</I> instruction. This bitwise-exclusive-ors two <TT>long</TT>
	 * values.
	 */
	public static final Instruction LXOR =
		new OneByteInstruction (OP_LXOR);

	/**
	 * A <I>monitorenter</I> instruction. This enters an object's monitor.
	 */
	public static final Instruction MONITORENTER =
		new OneByteInstruction (OP_MONITORENTER);

	/**
	 * A <I>monitorexit</I> instruction. This exits an object's monitor.
	 */
	public static final Instruction MONITOREXIT =
		new OneByteInstruction (OP_MONITOREXIT);

	/**
	 * A <I>nop</I> instruction. This does nothing.
	 */
	public static final Instruction NOP =
		new OneByteInstruction (OP_NOP);

	/**
	 * A <I>pop</I> instruction. This pops the top word off the operand stack.
	 */
	public static final Instruction POP =
		new OneByteInstruction (OP_POP);

	/**
	 * A <I>pop2</I> instruction. This pops the top two words off the operand
	 * stack.
	 */
	public static final Instruction POP2 =
		new OneByteInstruction (OP_POP2);

	/**
	 * A <I>return</I> instruction. This returns <TT>void</TT> from a method.
	 */
	public static final Instruction RETURN =
		new OneByteInstruction (OP_RETURN);

	/**
	 * An <I>saload</I> instruction. This loads a <TT>short</TT> value from an
	 * array.
	 */
	public static final Instruction SALOAD =
		new OneByteInstruction (OP_SALOAD);

	/**
	 * An <I>sastore</I> instruction. This stores a <TT>short</TT> value into an
	 * array.
	 */
	public static final Instruction SASTORE =
		new OneByteInstruction (OP_SASTORE);

	/**
	 * A <I>swap</I> instruction. This interchanges the first word with the
	 * second word on the operand stack.
	 */
	public static final Instruction SWAP =
		new OneByteInstruction (OP_SWAP);

// Exported static operations.

	/**
	 * An <I>aload</I> instruction. This pushes onto the operand stack a
	 * <TT>reference</TT> value from the local variable at the given index. If
	 * the index is in the range 0 .. 3, the opcode is <I>aload_0</I> through
	 * <I>aload_3</I>; if the index is in the range 4 .. 255, the opcode is
	 * <I>aload</I>; if the index is in the range 256 .. 65535, the opcode is
	 * <I>wide aload</I>.
	 *
	 * @param  theIndex  Local variable index.
	 *
	 * @return  <I>aload</I> instruction.
	 *
	 * @exception  OutOfRangeException
	 *     Thrown if <TT>theIndex</TT> is not in the range 0 .. 65535.
	 */
	public static final Instruction ALOAD
		(int theIndex)
		throws OutOfRangeException
		{
		return getLoadStore (theIndex, ALOAD_N_INSTRUCTION, OP_ALOAD);
		}

	/**
	 * An <I>anewarray</I> instruction. This creates a new array of
	 * <TT>reference</TT> values.
	 *
	 * @param  theType  Component type for the new array (an array or class
	 *                  reference).
	 *
	 * @return  <I>anewarray</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theType</TT> is null.
	 */
	public static final Instruction ANEWARRAY
		(ArrayOrClassReference theType)
		{
		return new ClassRefInstruction (OP_ANEWARRAY, theType);
		}

	/**
	 * An <I>astore</I> instruction. This pops from the operand stack a
	 * <TT>reference</TT> value into the local variable at the given index. If
	 * the index is in the range 0 .. 3, the opcode is <I>astore_0</I> through
	 * <I>astore_3</I>; if the index is in the range 4 .. 255, the opcode is
	 * <I>astore</I>; if the index is in the range 256 .. 65535, the opcode is
	 * <I>wide astore</I>.
	 *
	 * @param  theIndex  Local variable index.
	 *
	 * @return  <I>astore</I> instruction.
	 *
	 * @exception  OutOfRangeException
	 *     Thrown if <TT>theIndex</TT> is not in the range 0 .. 65535.
	 */
	public static final Instruction ASTORE
		(int theIndex)
		throws OutOfRangeException
		{
		return getLoadStore (theIndex, ASTORE_N_INSTRUCTION, OP_ASTORE);
		}

	/**
	 * A <I>checkcast</I> instruction. This checks whether an object can be cast
	 * to the given type.
	 *
	 * @param  theType  Type to check (an array or class reference).
	 *
	 * @return  <I>checkcast</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theType</TT> is null.
	 */
	public static final Instruction CHECKCAST
		(ArrayOrClassReference theType)
		{
		return new ClassRefInstruction (OP_CHECKCAST, theType);
		}

	/**
	 * A <I>dload</I> instruction. This pushes onto the operand stack a
	 * <TT>double</TT> value from the two local variables starting at the given
	 * index. If the index is in the range 0 .. 3, the opcode is <I>dload_0</I>
	 * through <I>dload_3</I>; if the index is in the range 4 .. 255, the opcode
	 * is <I>dload</I>; if the index is in the range 256 .. 65535, the opcode is
	 * <I>wide dload</I>.
	 *
	 * @param  theIndex  Local variable index.
	 *
	 * @return  <I>dload</I> instruction.
	 *
	 * @exception  OutOfRangeException
	 *     Thrown if <TT>theIndex</TT> is not in the range 0 .. 65535.
	 */
	public static final Instruction DLOAD
		(int theIndex)
		throws OutOfRangeException
		{
		return getLoadStore (theIndex, DLOAD_N_INSTRUCTION, OP_DLOAD);
		}

	/**
	 * A <I>dstore</I> instruction. This pops from the operand stack a
	 * <TT>double</TT> value into the two local variables starting at the given
	 * index. If the index is in the range 0 .. 3, the opcode is <I>dstore_0</I>
	 * through <I>dstore_3</I>; if the index is in the range 4 .. 255, the
	 * opcode is <I>dstore</I>; if the index is in the range 256 .. 65535, the
	 * opcode is <I>wide dstore</I>.
	 *
	 * @param  theIndex  Local variable index.
	 *
	 * @return  <I>dstore</I> instruction.
	 *
	 * @exception  OutOfRangeException
	 *     Thrown if <TT>theIndex</TT> is not in the range 0 .. 65535.
	 */
	public static final Instruction DSTORE
		(int theIndex)
		throws OutOfRangeException
		{
		return getLoadStore (theIndex, DSTORE_N_INSTRUCTION, OP_DSTORE);
		}

	/**
	 * An <I>fload</I> instruction. This pushes onto the operand stack a
	 * <TT>float</TT> value from the local variable at the given index. If the
	 * index is in the range 0 .. 3, the opcode is <I>fload_0</I> through
	 * <I>fload_3</I>; if the index is in the range 4 .. 255, the opcode is
	 * <I>fload</I>; if the index is in the range 256 .. 65535, the opcode is
	 * <I>wide fload</I>.
	 *
	 * @param  theIndex  Local variable index.
	 *
	 * @return  <I>fload</I> instruction.
	 *
	 * @exception  OutOfRangeException
	 *     Thrown if <TT>theIndex</TT> is not in the range 0 .. 65535.
	 */
	public static final Instruction FLOAD
		(int theIndex)
		throws OutOfRangeException
		{
		return getLoadStore (theIndex, FLOAD_N_INSTRUCTION, OP_FLOAD);
		}

	/**
	 * An <I>fstore</I> instruction. This pops from the operand stack a
	 * <TT>float</TT> value into the local variable at the given
	 * index. If the index is in the range 0 .. 3, the opcode is <I>fstore_0</I>
	 * through <I>fstore_3</I>; if the index is in the range 4 .. 255, the
	 * opcode is <I>fstore</I>; if the index is in the range 256 .. 65535, the
	 * opcode is <I>wide fstore</I>.
	 *
	 * @param  theIndex  Local variable index.
	 *
	 * @return  <I>fstore</I> instruction.
	 *
	 * @exception  OutOfRangeException
	 *     Thrown if <TT>theIndex</TT> is not in the range 0 .. 65535.
	 */
	public static final Instruction FSTORE
		(int theIndex)
		throws OutOfRangeException
		{
		return getLoadStore (theIndex, FSTORE_N_INSTRUCTION, OP_FSTORE);
		}

	/**
	 * A <I>getfield</I> instruction. This loads an instance field of an object.
	 *
	 * @param  theField  Field in the symbolic link.
	 *
	 * @return  <I>getfield</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theField</TT> is null.
	 */
	public static final Instruction GETFIELD
		(FieldReference theField)
		{
		return new FieldRefInstruction (OP_GETFIELD, theField);
		}

	/**
	 * A <I>getstatic</I> instruction. This loads a static field of a class.
	 *
	 * @param  theField  Field in the symbolic link.
	 *
	 * @return  <I>getstatic</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theField</TT> is null.
	 */
	public static final Instruction GETSTATIC
		(FieldReference theField)
		{
		return new FieldRefInstruction (OP_GETSTATIC, theField);
		}

	/**
	 * A <I>goto</I> instruction. This performs an unconditional branch. The
	 * branch target location must be no more than 32768 bytes before and no
	 * more than 32767 bytes after the goto instruction; otherwise, a
	 * ByteCodeException will be thrown when the classfile containing the goto
	 * instruction is emitted.
	 *
	 * @param  theTarget  Target location for the branch.
	 *
	 * @return  <I>goto</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theTarget</TT> is null.
	 */
	public static final Instruction GOTO
		(Location theTarget)
		{
		return new BranchInstruction (OP_GOTO, theTarget);
		}

	/**
	 * A <I>goto_w</I> instruction. This performs an unconditional branch. The
	 * branch target location may be any number of bytes before or after the
	 * goto instruction.
	 *
	 * @param  theTarget  Target location for the branch.
	 *
	 * @return  <I>goto_w</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theTarget</TT> is null.
	 */
	public static final Instruction GOTO_W
		(Location theTarget)
		{
		return new WideBranchInstruction (OP_GOTO_W, theTarget);
		}

	/**
	 * An <I>if_acmpeq</I> instruction. This performs a conditional branch if a
	 * <TT>reference</TT> value is equal to another <TT>reference</TT> value.
	 *
	 * @param  theTarget  Target location for the branch.
	 *
	 * @return  <I>if_acmpeq</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theTarget</TT> is null.
	 */
	public static final Instruction IF_ACMPEQ
		(Location theTarget)
		{
		return new BranchInstruction (OP_IF_ACMPEQ, theTarget);
		}

	/**
	 * An <I>if_acmpne</I> instruction. This performs a conditional branch if a
	 * <TT>reference</TT> value is not equal to another <TT>reference</TT>
	 * value.
	 *
	 * @param  theTarget  Target location for the branch.
	 *
	 * @return  <I>if_acmpne</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theTarget</TT> is null.
	 */
	public static final Instruction IF_ACMPNE
		(Location theTarget)
		{
		return new BranchInstruction (OP_IF_ACMPNE, theTarget);
		}

	/**
	 * An <I>if_icmpeq</I> instruction. This performs a conditional branch if an
	 * <TT>int</TT> value is equal to another <TT>int</TT> value.
	 *
	 * @param  theTarget  Target location for the branch.
	 *
	 * @return  <I>if_icmpeq</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theTarget</TT> is null.
	 */
	public static final Instruction IF_ICMPEQ
		(Location theTarget)
		{
		return new BranchInstruction (OP_IF_ICMPEQ, theTarget);
		}

	/**
	 * An <I>if_icmpne</I> instruction. This performs a conditional branch if an
	 * <TT>int</TT> value is not equal to another <TT>int</TT> value.
	 *
	 * @param  theTarget  Target location for the branch.
	 *
	 * @return  <I>if_icmpne</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theTarget</TT> is null.
	 */
	public static final Instruction IF_ICMPNE
		(Location theTarget)
		{
		return new BranchInstruction (OP_IF_ICMPNE, theTarget);
		}

	/**
	 * An <I>if_icmplt</I> instruction. This performs a conditional branch if an
	 * <TT>int</TT> value is less than another <TT>int</TT> value.
	 *
	 * @param  theTarget  Target location for the branch.
	 *
	 * @return  <I>if_icmplt</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theTarget</TT> is null.
	 */
	public static final Instruction IF_ICMPLT
		(Location theTarget)
		{
		return new BranchInstruction (OP_IF_ICMPLT, theTarget);
		}

	/**
	 * An <I>if_icmpge</I> instruction. This performs a conditional branch if an
	 * <TT>int</TT> value is greater than or equal to another <TT>int</TT>
	 * value.
	 *
	 * @param  theTarget  Target location for the branch.
	 *
	 * @return  <I>if_icmpge</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theTarget</TT> is null.
	 */
	public static final Instruction IF_ICMPGE
		(Location theTarget)
		{
		return new BranchInstruction (OP_IF_ICMPGE, theTarget);
		}

	/**
	 * An <I>if_icmpgt</I> instruction. This performs a conditional branch if an
	 * <TT>int</TT> value is greater than another <TT>int</TT> value.
	 *
	 * @param  theTarget  Target location for the branch.
	 *
	 * @return  <I>if_icmpgt</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theTarget</TT> is null.
	 */
	public static final Instruction IF_ICMPGT
		(Location theTarget)
		{
		return new BranchInstruction (OP_IF_ICMPGT, theTarget);
		}

	/**
	 * An <I>if_icmple</I> instruction. This performs a conditional branch if an
	 * <TT>int</TT> value is less than or equal to another <TT>int</TT> value.
	 *
	 * @param  theTarget  Target location for the branch.
	 *
	 * @return  <I>if_icmple</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theTarget</TT> is null.
	 */
	public static final Instruction IF_ICMPLE
		(Location theTarget)
		{
		return new BranchInstruction (OP_IF_ICMPLE, theTarget);
		}

	/**
	 * An <I>ifeq</I> instruction. This performs a conditional branch if an
	 * <TT>int</TT> value is equal to zero.
	 *
	 * @param  theTarget  Target location for the branch.
	 *
	 * @return  <I>ifeq</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theTarget</TT> is null.
	 */
	public static final Instruction IFEQ
		(Location theTarget)
		{
		return new BranchInstruction (OP_IFEQ, theTarget);
		}

	/**
	 * An <I>ifne</I> instruction. This performs a conditional branch if an
	 * <TT>int</TT> value is not equal to zero.
	 *
	 * @param  theTarget  Target location for the branch.
	 *
	 * @return  <I>ifne</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theTarget</TT> is null.
	 */
	public static final Instruction IFNE
		(Location theTarget)
		{
		return new BranchInstruction (OP_IFNE, theTarget);
		}

	/**
	 * An <I>iflt</I> instruction. This performs a conditional branch if an
	 * <TT>int</TT> value is less than zero.
	 *
	 * @param  theTarget  Target location for the branch.
	 *
	 * @return  <I>iflt</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theTarget</TT> is null.
	 */
	public static final Instruction IFLT
		(Location theTarget)
		{
		return new BranchInstruction (OP_IFLT, theTarget);
		}

	/**
	 * An <I>ifge</I> instruction. This performs a conditional branch if an
	 * <TT>int</TT> value is greater than or equal to zero.
	 *
	 * @param  theTarget  Target location for the branch.
	 *
	 * @return  <I>ifge</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theTarget</TT> is null.
	 */
	public static final Instruction IFGE
		(Location theTarget)
		{
		return new BranchInstruction (OP_IFGE, theTarget);
		}

	/**
	 * An <I>ifgt</I> instruction. This performs a conditional branch if an
	 * <TT>int</TT> value is greater than zero.
	 *
	 * @param  theTarget  Target location for the branch.
	 *
	 * @return  <I>ifgt</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theTarget</TT> is null.
	 */
	public static final Instruction IFGT
		(Location theTarget)
		{
		return new BranchInstruction (OP_IFGT, theTarget);
		}

	/**
	 * An <I>ifle</I> instruction. This performs a conditional branch if an
	 * <TT>int</TT> value is less than or equal to zero.
	 *
	 * @param  theTarget  Target location for the branch.
	 *
	 * @return  <I>ifle</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theTarget</TT> is null.
	 */
	public static final Instruction IFLE
		(Location theTarget)
		{
		return new BranchInstruction (OP_IFLE, theTarget);
		}

	/**
	 * An <I>ifnonnull</I> instruction. This performs a conditional branch if a
	 * <TT>reference</TT> value is not null.
	 *
	 * @param  theTarget  Target location for the branch.
	 *
	 * @return  <I>ifnonnull</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theTarget</TT> is null.
	 */
	public static final Instruction IFNONNULL
		(Location theTarget)
		{
		return new BranchInstruction (OP_IFNONNULL, theTarget);
		}

	/**
	 * An <I>ifnull</I> instruction. This performs a conditional branch if a
	 * <TT>reference</TT> value is null.
	 *
	 * @param  theTarget  Target location for the branch.
	 *
	 * @return  <I>ifnull</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theTarget</TT> is null.
	 */
	public static final Instruction IFNULL
		(Location theTarget)
		{
		return new BranchInstruction (OP_IFNULL, theTarget);
		}

	/**
	 * An <I>iinc</I> instruction. This increments the <TT>int</TT> valued local
	 * variable at the given index by the given amount. If the index is in the
	 * range 0 .. 255 and the amount is in the range -128 .. 127, the opcode is
	 * <I>iinc.</I> If the index is in the range 0 .. 65535 or the amount is in
	 * the range -32768 .. 32767, the opcode is <I>wide iinc.</I>
	 *
	 * @param  theIndex   Local variable index.
	 * @param  theAmount  Amount by which to increment the local variable.
	 *
	 * @return  <I>fload</I> instruction.
	 *
	 * @exception  OutOfRangeException
	 *     Thrown if <TT>theIndex</TT> is not in the range 0 .. 65535 or
	 *     <TT>theAmount</TT> is not in the range -32768 .. 32767.
	 */
	public static final Instruction IINC
		(int theIndex,
		 int theAmount)
		throws OutOfRangeException
		{
		if
			(0 > theIndex || theIndex > 65535 ||
			 -32768 > theAmount || theAmount > 32767)
			{
			throw new OutOfRangeException();
			}
		else if
			(0 <= theIndex && theIndex <= 255 &&
			 -128 <= theAmount && theAmount <= 127)
			{
			return new ThreeByteInstruction
				(OP_IINC,
				 Instruction.byte0 (theIndex),
				 Instruction.byte0 (theAmount));
			}
		else
			{
			return new SixByteInstruction
				(OP_WIDE, OP_IINC,
				 Instruction.byte1 (theIndex), Instruction.byte0 (theIndex),
				 Instruction.byte1 (theAmount), Instruction.byte0 (theAmount));
			}
		}

	/**
	 * An <I>iload</I> instruction. This pushes onto the operand stack an
	 * <TT>int</TT> value from the local variable at the given index. If the
	 * index is in the range 0 .. 3, the opcode is <I>iload_0</I> through
	 * <I>iload_3</I>; if the index is in the range 4 .. 255, the opcode is
	 * <I>iload</I>; if the index is in the range 256 .. 65535, the opcode is
	 * <I>wide iload</I>.
	 *
	 * @param  theIndex  Local variable index.
	 *
	 * @return  <I>iload</I> instruction.
	 *
	 * @exception  OutOfRangeException
	 *     Thrown if <TT>theIndex</TT> is not in the range 0 .. 65535.
	 */
	public static final Instruction ILOAD
		(int theIndex)
		throws OutOfRangeException
		{
		return getLoadStore (theIndex, ILOAD_N_INSTRUCTION, OP_ILOAD);
		}

	/**
	 * An <I>instanceof</I> instruction. This checks whether an object is an
	 * instance of the given type.
	 *
	 * @param  theType  Type to check (an array or class reference).
	 *
	 * @return  <I>instanceof</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theType</TT> is null.
	 */
	public static final Instruction INSTANCEOF
		(ArrayOrClassReference theType)
		{
		return new ClassRefInstruction (OP_INSTANCEOF, theType);
		}

	/**
	 * An <I>invokeinterface</I> instruction. This invokes an interface method.
	 *
	 * @param  theMethod  Method in the symbolic link.
	 *
	 * @return  <I>invokeinterface</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theMethod</TT> is null.
	 */
	public static final Instruction INVOKEINTERFACE
		(SubroutineReference theMethod)
		{
		return new InterfaceMethodRefInstruction
			(OP_INVOKEINTERFACE,
			 theMethod);
		}

	/**
	 * An <I>invokespecial</I> instruction. This invokes an instance method,
	 * with special handling for superclass, private, and instance
	 * initialization method invocations.
	 *
	 * @param  theMethod  Method in the symbolic link.
	 *
	 * @return  <I>invokespecial</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theMethod</TT> is null.
	 */
	public static final Instruction INVOKESPECIAL
		(SubroutineReference theMethod)
		{
		return new MethodRefInstruction (OP_INVOKESPECIAL, theMethod);
		}

	/**
	 * An <I>invokestatic</I> instruction. This invokes a class static method.
	 *
	 * @param  theMethod  Method in the symbolic link.
	 *
	 * @return  <I>invokestatic</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theMethod</TT> is null.
	 */
	public static final Instruction INVOKESTATIC
		(SubroutineReference theMethod)
		{
		return new MethodRefInstruction (OP_INVOKESTATIC, theMethod);
		}

	/**
	 * An <I>invokevirtual</I> instruction. This invokes an instance method.
	 *
	 * @param  theMethod  Method in the symbolic link.
	 *
	 * @return  <I>invokevirtual</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theMethod</TT> is null.
	 */
	public static final Instruction INVOKEVIRTUAL
		(SubroutineReference theMethod)
		{
		return new MethodRefInstruction (OP_INVOKEVIRTUAL, theMethod);
		}

	/**
	 * An <I>istore</I> instruction. This pops from the operand stack an
	 * <TT>int</TT> value into the local variable at the given index. If the
	 * index is in the range 0 .. 3, the opcode is <I>istore_0</I> through
	 * <I>istore_3</I>; if the index is in the range 4 .. 255, the opcode is
	 * <I>istore</I>; if the index is in the range 256 .. 65535, the opcode is
	 * <I>wide istore</I>.
	 *
	 * @param  theIndex  Local variable index.
	 *
	 * @return  <I>istore</I> instruction.
	 *
	 * @exception  OutOfRangeException
	 *     Thrown if <TT>theIndex</TT> is not in the range 0 .. 65535.
	 */
	public static final Instruction ISTORE
		(int theIndex)
		throws OutOfRangeException
		{
		return getLoadStore (theIndex, ISTORE_N_INSTRUCTION, OP_ISTORE);
		}

	/**
	 * A <I>jsr</I> instruction. This performs an unconditional branch to a
	 * miniature subroutine within the same bytecode sequence, pushing the
	 * return address on the operand stack. The branch target location must be
	 * no more than 32768 bytes before and no more than 32767 bytes after the
	 * jump subroutine instruction; otherwise, a ByteCodeException will be
	 * thrown when the classfile containing the jump subroutine instruction is
	 * emitted.
	 *
	 * @param  theTarget  Target location for the branch.
	 *
	 * @return  <I>jsr</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theTarget</TT> is null.
	 */
	public static final Instruction JSR
		(Location theTarget)
		{
		return new BranchInstruction (OP_JSR, theTarget);
		}

	/**
	 * A <I>jsr_w</I> instruction. This performs an unconditional branch to a
	 * miniature subroutine within the same bytecode sequence, pushing the
	 * return address on the operand stack. The branch target location may be
	 * any number of bytes before or after the jump subroutine instruction.
	 *
	 * @param  theTarget  Target location for the branch.
	 *
	 * @return  <I>jsr_w</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theTarget</TT> is null.
	 */
	public static final Instruction JSR_W
		(Location theTarget)
		{
		return new WideBranchInstruction (OP_JSR_W, theTarget);
		}

	/**
	 * A string <I>ldc</I> instruction. This pushes the given string constant
	 * value onto the operand stack. The opcode is <I>ldc</I> or <I>ldc_w</I>
	 * depending on how full the constant pool is.
	 *
	 * @param  theValue  String value to push.
	 *
	 * @return  Instruction.
	 */
	public static final Instruction LDC
		(String theValue)
		{
		return new StringLdcInstruction (theValue);
		}

	/**
	 * An integer <I>ldc</I> instruction. This pushes the given integer constant
	 * value onto the operand stack. If the value is in the range &#150;1 .. 5,
	 * the opcode is <I>iconst_m1</I> through <I>iconst_5.</I> Otherwise, if the
	 * value is in the range &#150;2<SUP>7</SUP> .. 2<SUP>7</SUP>&#150;1, the
	 * opcode is <I>bipush.</I> Otherwise, if the value is in the range
	 * &#150;2<SUP>15</SUP> .. 2<SUP>15</SUP>&#150;1, the opcode is
	 * <I>sipush.</I> Otherwise, the opcode is <I>ldc</I> or <I>ldc_w</I>
	 * depending on how full the constant pool is.
	 *
	 * @param  theValue  Integer value to push.
	 *
	 * @return  Instruction.
	 */
	public static final Instruction LDC
		(int theValue)
		{
		if (-1 <= theValue && theValue <= 5)
			{
			return ICONST_N_INSTRUCTION[theValue+1];
			}
		else if (Byte.MIN_VALUE <= theValue && theValue <= Byte.MAX_VALUE)
			{
			return new TwoByteInstruction
				(OP_BIPUSH,
				 Instruction.byte0 (theValue));
			}
		else if (Short.MIN_VALUE <= theValue && theValue <= Short.MAX_VALUE)
			{
			return new ThreeByteInstruction
				(OP_SIPUSH,
				 Instruction.byte1 (theValue), Instruction.byte0 (theValue));
			}
		else
			{
			return new IntegerLdcInstruction (theValue);
			}
		}

	/**
	 * A float <I>ldc</I> instruction. This pushes the given float constant
	 * value onto the operand stack. If the value is 0.0f, 1.0f, or 2.0f, the
	 * opcode is <I>fconst_0, fconst_1,</I> or <I>fconst_2</I> respectively.
	 * Otherwise, the opcode is <I>ldc</I> or <I>ldc_w</I> depending on how full
	 * the constant pool is.
	 *
	 * @param  theValue  Float value to push.
	 *
	 * @return  Instruction.
	 */
	public static final Instruction LDC
		(float theValue)
		{
		if (theValue == 0.0f)
			{
			return FCONST_0;
			}
		else if (theValue == 1.0f)
			{
			return FCONST_1;
			}
		else if (theValue == 2.0f)
			{
			return FCONST_2;
			}
		else
			{
			return new FloatLdcInstruction (theValue);
			}
		}

	/**
	 * A long <I>ldc</I> instruction. This pushes the given long constant value
	 * onto the operand stack. If the value is 0L or 1L, the opcode is
	 * <I>lconst_0</I> or <I>lconst_1</I> respectively. Otherwise, the opcode is
	 * <I>ldc2_w.</I>
	 *
	 * @param  theValue  Long value to push.
	 *
	 * @return  Instruction.
	 */
	public static final Instruction LDC
		(long theValue)
		{
		if (theValue == 0L)
			{
			return LCONST_0;
			}
		else if (theValue == 1L)
			{
			return LCONST_1;
			}
		else
			{
			return new LongLdcInstruction (theValue);
			}
		}

	/**
	 * A double <I>ldc</I> instruction. This pushes the given double constant
	 * value onto the operand stack. If the value is 0.0 or 1.0, the opcode is
	 * <I>dconst_0</I> or <I>dconst_1</I> respectively. Otherwise, the opcode is
	 * <I>ldc2_w.</I>
	 *
	 * @param  theValue  Double value to push.
	 *
	 * @return  Instruction.
	 */
	public static final Instruction LDC
		(double theValue)
		{
		if (theValue == 0.0)
			{
			return DCONST_0;
			}
		else if (theValue == 1.0)
			{
			return DCONST_1;
			}
		else
			{
			return new DoubleLdcInstruction (theValue);
			}
		}

	/**
	 * An <I>lload</I> instruction. This pushes onto the operand stack a
	 * <TT>long</TT> value from the local variable at the given index. If the
	 * index is in the range 0 .. 3, the opcode is <I>lload_0</I> through
	 * <I>lload_3</I>; if the index is in the range 4 .. 255, the opcode is
	 * <I>lload</I>; if the index is in the range 256 .. 65535, the opcode is
	 * <I>wide lload</I>.
	 *
	 * @param  theIndex  Local variable index.
	 *
	 * @return  <I>lload</I> instruction.
	 *
	 * @exception  OutOfRangeException
	 *     Thrown if <TT>theIndex</TT> is not in the range 0 .. 65535.
	 */
	public static final Instruction LLOAD
		(int theIndex)
		throws OutOfRangeException
		{
		return getLoadStore (theIndex, LLOAD_N_INSTRUCTION, OP_LLOAD);
		}

	/**
	 * A <I>lookupswitch</I> instruction. This branches to a target location
	 * based on an integer case value by searching in a list of (case value,
	 * target location) pairs. After creating a <I>lookupswitch</I> instruction,
	 * and before adding the instruction to a subroutine, add cases to the
	 * instruction as described in class {@link SwitchInstruction
	 * SwitchInstruction}.
	 *
	 * @param  theDefaultTarget  Target branch location for the <TT>default</TT>
	 *                           case.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theDefaultTarget</TT> is null.
	 */
	public static final SwitchInstruction LOOKUPSWITCH
		(Location theDefaultTarget)
		{
		return new LookupSwitchInstruction (theDefaultTarget);
		}

	/**
	 * An <I>lstore</I> instruction. This pops from the operand stack a
	 * <TT>long</TT> value into the local variable at the given index. If the
	 * index is in the range 0 .. 3, the opcode is <I>lstore_0</I> through
	 * <I>lstore_3</I>; if the index is in the range 4 .. 255, the opcode is
	 * <I>lstore</I>; if the index is in the range 256 .. 65535, the opcode is
	 * <I>wide lstore</I>.
	 *
	 * @param  theIndex  Local variable index.
	 *
	 * @return  <I>lstore</I> instruction.
	 *
	 * @exception  OutOfRangeException
	 *     Thrown if <TT>theIndex</TT> is not in the range 0 .. 65535.
	 */
	public static final Instruction LSTORE
		(int theIndex)
		throws OutOfRangeException
		{
		return getLoadStore (theIndex, LSTORE_N_INSTRUCTION, OP_LSTORE);
		}

	/**
	 * A <I>multianewarray</I> instruction. This creates a new multidimensional
	 * array. Note that the argument is a reference to the type of the array
	 * <I>itself,</I> not a reference to the type of the array's components.
	 *
	 * @param  theArrayType   Type of the new array. This must be an array
	 *                        reference with at least as many dimensions as
	 *                        <TT>theDimensions</TT>.
	 * @param  theDimensions  Number of dimensions to create.
	 *
	 * @return  <I>multianewarray</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theArrayType</TT> is null.
	 * @exception  OutOfRangeException
	 *     Thrown if <TT>theDimensions</TT> is not in the range 1 .. 255, or if
	 *     <TT>theDimensions</TT> is greater than the number of dimensions in
	 *     <TT>theArrayType</TT>.
	 */
	public static final Instruction MULTIANEWARRAY
		(ArrayReference theArrayType,
		 int theDimensions)
		throws OutOfRangeException
		{
		return new MultianewarrayInstruction (theArrayType, theDimensions);
		}

	/**
	 * A <I>new</I> instruction. This creates a new object of the given type.
	 *
	 * @param  theType  Type for the new object (a class reference). It should
	 *                  refer to a class, not an interface.
	 *
	 * @return  <I>new</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theType</TT> is null.
	 */
	public static final Instruction NEW
		(ClassReference theType)
		{
		return new ClassRefInstruction (OP_NEW, theType);
		}

	/**
	 * A <I>newarray</I> instruction. This creates a new array of a primitive
	 * type.
	 *
	 * @param  theType  Component type for the new array (a primitive 
	 *                  reference).
	 *
	 * @return  <I>newarray</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theType</TT> is null.
	 */
	public static final Instruction NEWARRAY
		(PrimitiveReference theType)
		{
		return new TwoByteInstruction (OP_NEWARRAY, theType.getAtype());
		}

	/**
	 * A <I>putfield</I> instruction. This stores into an instance field of an
	 * object.
	 *
	 * @param  theField  Field in the symbolic link.
	 *
	 * @return  <I>putfield</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theField</TT> is null.
	 */
	public static final Instruction PUTFIELD
		(FieldReference theField)
		{
		return new FieldRefInstruction (OP_PUTFIELD, theField);
		}

	/**
	 * A <I>putstatic</I> instruction. This stores into a static field of a
	 * class.
	 *
	 * @param  theField  Field in the symbolic link.
	 *
	 * @return  <I>putstatic</I> instruction.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theField</TT> is null.
	 */
	public static final Instruction PUTSTATIC
		(FieldReference theField)
		{
		return new FieldRefInstruction (OP_PUTSTATIC, theField);
		}

	/**
	 * A <I>ret</I> instruction. This returns from a miniature subroutine in the
	 * bytecode sequence, with the return address being taken from the local
	 * variable at the given index. If the index is in the range 0 .. 255, the
	 * opcode is <I>ret</I>; if the index is in the range 256 .. 65535, the
	 * opcode is <I>wide ret</I>.
	 *
	 * @param  theIndex  Local variable index.
	 *
	 * @return  <I>ret</I> instruction.
	 *
	 * @exception  OutOfRangeException
	 *     Thrown if <TT>theIndex</TT> is not in the range 0 .. 65535.
	 */
	public static final Instruction RET
		(int theIndex)
		throws OutOfRangeException
		{
		if (theIndex < 0)
			{
			throw new OutOfRangeException();
			}
		else if (theIndex <= 255)
			{
			return new TwoByteInstruction
				(OP_RET,
				 Instruction.byte0 (theIndex));
			}
		else if (theIndex <= 65535)
			{
			return new FourByteInstruction
				(OP_WIDE, OP_RET,
				 Instruction.byte1 (theIndex), Instruction.byte0 (theIndex));
			}
		else
			{
			throw new OutOfRangeException();
			}
		}

	/**
	 * A <I>tableswitch</I> instruction. This branches to a target location
	 * based on an integer case value by indexing a table of target locations.
	 * After creating a <I>tableswitch</I> instruction, and before adding the
	 * instruction to a subroutine, add cases to the instruction as described in
	 * class {@link SwitchInstruction SwitchInstruction}.
	 *
	 * @param  theDefaultTarget  Target branch location for the <TT>default</TT>
	 *                           case.
	 *
	 * @exception  NullPointerException
	 *     (unchecked exception) Thrown if <TT>theDefaultTarget</TT> is null.
	 */
	public static final SwitchInstruction TABLESWITCH
		(Location theDefaultTarget)
		{
		return new TableSwitchInstruction (theDefaultTarget);
		}

	/**
	 * A type-sensitive <I>load</I> instruction. This pushes onto the operand
	 * stack a value from the local variable at the given index. The type of the
	 * local variable is the given type.
	 *
	 * @param  theIndex  Local variable index.
	 * @param  theType   Local variable type.
	 *
	 * @return  The appropriate <I>load</I> instruction for <TT>theType</TT>.
	 *
	 * @exception  OutOfRangeException
	 *     Thrown if <TT>theIndex</TT> is not in the range 0 .. 65535.
	 */
	public static final Instruction TLOAD
		(int theIndex,
		 TypeReference theType)
		throws OutOfRangeException
		{
		return getLoadStore
			(theIndex, theType.getLoadNTable(), theType.getLoadOpcode());
		}

	/**
	 * A type-sensitive <I>store</I> instruction. This pops a value from the
	 * operand stack and stores it in the local variable at the given index. The
	 * type of the local variable is the given type.
	 *
	 * @param  theIndex  Local variable index.
	 * @param  theType   Local variable type.
	 *
	 * @return  The appropriate <I>store</I> instruction for <TT>theType</TT>.
	 *
	 * @exception  OutOfRangeException
	 *     Thrown if <TT>theIndex</TT> is not in the range 0 .. 65535.
	 */
	public static final Instruction TSTORE
		(int theIndex,
		 TypeReference theType)
		throws OutOfRangeException
		{
		return getLoadStore
			(theIndex, theType.getStoreNTable(), theType.getStoreOpcode());
		}

// Hidden operations.

	/**
	 * Generate a <I>*load</I> or <I>*store</I> instruction.
	 */
	private static final Instruction getLoadStore
		(int theIndex,
		 Instruction[] theTable,
		 byte theOpcode)
		throws OutOfRangeException
		{
		if (theIndex < 0)
			{
			throw new OutOfRangeException();
			}
		else if (theIndex <= 3)
			{
			return theTable[theIndex];
			}
		else if (theIndex <= 255)
			{
			return new TwoByteInstruction
				(theOpcode,
				 Instruction.byte0 (theIndex));
			}
		else if (theIndex <= 65535)
			{
			return new FourByteInstruction
				(OP_WIDE, theOpcode,
				 Instruction.byte1 (theIndex), Instruction.byte0 (theIndex));
			}
		else
			{
			throw new OutOfRangeException();
			}
		}

	}
