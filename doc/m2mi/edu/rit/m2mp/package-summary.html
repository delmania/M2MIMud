<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_05) on Tue Nov 23 10:30:39 EST 2004 -->
<TITLE>
edu.rit.m2mp (M2MI Library Documentation)
</TITLE>

<META NAME="keywords" CONTENT="edu.rit.m2mp package">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="edu.rit.m2mp (M2MI Library Documentation)";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../edu/rit/m2mi/test/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../edu/rit/m2mp/udp/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
Package edu.rit.m2mp
</H2>
Package edu.rit.m2mp
is the API for the Many-to-Many Protocol (M2MP).
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Class Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../edu/rit/m2mp/Channel.html" title="class in edu.rit.m2mp">Channel</A></B></TD>
<TD>Class Channel is the abstract superclass for a channel in the Many-to-Many
 Protocol (M2MP).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../edu/rit/m2mp/Daemon.html" title="class in edu.rit.m2mp">Daemon</A></B></TD>
<TD>Class Daemon is the main program for the M2MP Daemon process.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../edu/rit/m2mp/DaemonChannel.html" title="class in edu.rit.m2mp">DaemonChannel</A></B></TD>
<TD>Class DaemonChannel provides an M2MP <A HREF="../../../edu/rit/m2mp/Channel.html" title="class in edu.rit.m2mp"><CODE></CODE>Channel<CODE></CODE></A> for
 communicating between an M2MP client process and the M2MP Daemon process.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../edu/rit/m2mp/FlowController.html" title="class in edu.rit.m2mp">FlowController</A></B></TD>
<TD>Class FlowController provides an object that does flow control for the M2MP
 Layer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../edu/rit/m2mp/M2MP.html" title="class in edu.rit.m2mp">M2MP</A></B></TD>
<TD>Class M2MP provides the Many-to-Many Protocol (M2MP) Layer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../edu/rit/m2mp/M2MPProperties.html" title="class in edu.rit.m2mp">M2MPProperties</A></B></TD>
<TD>Class M2MPProperties provides access to properties that are used to configure
 the M2MP Layer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../edu/rit/m2mp/MessageInputStream.html" title="class in edu.rit.m2mp">MessageInputStream</A></B></TD>
<TD>Class MessageInputStream provides an input stream for reading the contents
 of an incoming Many-to-Many Protocol (M2MP) message.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../edu/rit/m2mp/MessageOutputStream.html" title="class in edu.rit.m2mp">MessageOutputStream</A></B></TD>
<TD>Class MessageOutputStream provides an output stream for writing the contents
 of an outgoing Many-to-Many Protocol (M2MP) message.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../edu/rit/m2mp/MessageQueue.html" title="class in edu.rit.m2mp">MessageQueue</A></B></TD>
<TD>Class MessageQueue provides a FIFO queue of incoming M2MP messages (type
 <A HREF="../../../edu/rit/m2mp/MessageInputStream.html" title="class in edu.rit.m2mp"><CODE></CODE>MessageInputStream<CODE></CODE></A>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../edu/rit/m2mp/MessageRouter.html" title="class in edu.rit.m2mp">MessageRouter</A></B></TD>
<TD>Class MessageRouter provides an object that decides whether to accept each
 incoming M2MP message.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../edu/rit/m2mp/NullChannel.html" title="class in edu.rit.m2mp">NullChannel</A></B></TD>
<TD>Class NullChannel provides an M2MP <A HREF="../../../edu/rit/m2mp/Channel.html" title="class in edu.rit.m2mp"><CODE></CODE>Channel<CODE></CODE></A>
 implementation that does not send or receive messages.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../edu/rit/m2mp/Packet.html" title="class in edu.rit.m2mp">Packet</A></B></TD>
<TD>Class Packet provides an M2MP packet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../edu/rit/m2mp/PacketPool.html" title="class in edu.rit.m2mp">PacketPool</A></B></TD>
<TD>Class PacketPool provides a pool of M2MP <A HREF="../../../edu/rit/m2mp/Packet.html" title="class in edu.rit.m2mp"><CODE></CODE>Packet<CODE></CODE></A>s.</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Exception Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../edu/rit/m2mp/M2MPInitializationException.html" title="class in edu.rit.m2mp">M2MPInitializationException</A></B></TD>
<TD>Class M2MPInitializationException indicates that initialization of the M2MP
 Layer failed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../edu/rit/m2mp/M2MPPropertyFileException.html" title="class in edu.rit.m2mp">M2MPPropertyFileException</A></B></TD>
<TD>Class M2MPPropertyFileException indicates that initialization of the M2MP
 Layer failed because the M2MP properties file could not be found or could not
 be read.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../edu/rit/m2mp/M2MPPropertyMissingException.html" title="class in edu.rit.m2mp">M2MPPropertyMissingException</A></B></TD>
<TD>Class M2MPPropertyMissingException indicates that initialization of the M2MP
 Layer failed because a certain property was not specified in the M2MP
 properties file.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../edu/rit/m2mp/M2MPPropertyValueException.html" title="class in edu.rit.m2mp">M2MPPropertyValueException</A></B></TD>
<TD>Class M2MPPropertyValueException indicates that initialization of the M2MP
 Layer failed because a certain property had an invalid value in the M2MP
 properties file.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../edu/rit/m2mp/M2MPRuntimeException.html" title="class in edu.rit.m2mp">M2MPRuntimeException</A></B></TD>
<TD>Class M2MPRuntimeException is the common base class for all unchecked
 RuntimeExceptions in M2MP.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A><H2>
Package edu.rit.m2mp Description
</H2>

<P>
Package edu.rit.m2mp
is the API for the Many-to-Many Protocol (M2MP).

<P>
<A HREF="#concepts">Section 1</A>
briefly introduces the concepts of M2MP
and describes the architecture of the M2MP Layer.
<A HREF="#configuring">Section 2</A>
describes how to configure the M2MP Layer.
<A HREF="#daemon">Section 3</A>
describes how to run the M2MP Daemon.
<A HREF="#writing">Section 4</A>
describes how to write code
using the M2MP Library.
<A HREF="#packets">Section 5</A>
describes the format of M2MP packets
and describes how M2MP packets are processed.

<P>
<HR>
<H2>Table of Contents</H2>

1. <A HREF="#concepts">M2MP Concepts</A>
<BR>
2. <A HREF="#configuring">Configuring the M2MP Layer</A>
<BR>
3. <A HREF="#daemon">Running the M2MP Daemon</A>
<BR>
4. <A HREF="#writing">Working with the M2MP Library</A>
<BR>
5. <A HREF="#packets">M2MP Packet Format and Processing</A>

<P>
<HR>
<A NAME="concepts"><H2>1. M2MP Concepts</H2></A>

<P>
<B>Assumptions</B>

<P>
Intended particularly for the wireless proximal
ad hoc networking environment,
M2MP's design is based on these assumptions:
<OL TYPE=1>
<LI>
<EM>Messages are not sent to particular device addresses.</EM>
Consequently, devices can enter and leave the network
in an ad hoc fashion
without having to maintain any routing tables.
<BR>&nbsp;
<LI>
<EM>Messages are broadcast to all nearby devices.</EM>
M2MP assumes it is using a broadcast communication medium,
like a wired Ethernet or a wireless Ethernet.
Every device in a proximal group of devices --
every device on the same wired Ethernet segment,
or every device in radio range in a wireless Ethernet --
receives every transmission from every device.
Therefore, at the data link level it's just as easy
to deliver a message to all devices
as to one device.
<BR>&nbsp;
<LI>
<EM>Message delivery is mostly reliable.</EM>
Most of the time,
a message broadcast by one device
is received by all the other devices.
However, on rare occasions
a message broadcast by one device
is not received by some or all of the other devices.
<BR>&nbsp;
<LI>
<EM>Packets are not reordered in the communication medium.</EM>
While the broadcast communication medium
may occasionally fail to deliver certain packets
to certain devices,
the packets that do get through
are delivered in the same order at every device.
<BR>&nbsp;
<LI>
<EM>A message's relevancy is determined by its contents.</EM>
A device decides which incoming messages to process
by examining the initial bytes of each message.
</OL>

<P>
<B>Message Transfer</B>

<P>
When an application on one device
sends an M2MP message,
the application writes a stream of bytes
with the message's contents
to the M2MP Layer.
The M2MP Layer breaks the byte stream
into a sequence of fragments,
wraps each fragment in a packet,
and broadcasts each packet.
On the receiving device,
the M2MP Layer reassembles the packets into messages
and passes the messages up to the application.
See "<A HREF="#packets">M2MP Packet Format and Processing</A>"
for further information about the M2MP packets.

<P>
To receive incoming messages,
an application must register one or more <EM>message filters</EM>
with the M2MP Layer.
Each message filter has a <EM>message prefix,</EM>
a fixed byte string.
If an incoming message's initial bytes
match the message prefix
of a registered message filter,
the M2MP Layer passes the message
up to the application
that registered the message filter.
Otherwise, the M2MP Layer discards the message,
and the application never sees it.
An application that uses M2MP, such as M2MI,
designs the contents of its M2MP messages
to take advantage of M2MP's message filtering capability
and weed out irrelevant messages
before they ever reach the application.

<P>
If a failure occurs in the middle of an incoming message,
such as a lost packet,
the M2MP Layer will time out
waiting for the proper packet
to arrive.
If the timeout occurs,
the M2MP Layer abandons the message
and signals an exception to the application
reading the message.
The M2MP Layer does not retransmit packets.

<P>
Retransmitting lost packets is unnecessary,
and abandoning the message is acceptable,
because M2MP assumes the proximal network is mostly reliable.
Recovery from an occasional message loss
can be done at the application level.
Indeed, the messaging layer should not be expected
to provide end-to-end delivery or ordering guarantees.
This considerably simplifies M2MP.

<P>
<B>M2MP Layer Architecture</B>

<P>
Ideally,
M2MP would be implemented in the platform operating system
(as TCP/IP is),
and there would be system calls
and programming language APIs
for accessing the M2MP Layer.
However, at present M2MP is implemented at the user level,
not in the operating system.
This means that users 
must be aware of the M2MP Layer's architecture
to a certain extent
in order to run M2MP-based applications,
such as M2MI-based applications.

<P>
On each device,
the M2MP Layer can be configured in two different ways.
Figure 1 shows the more common alternative.

<P>
<CENTER>
<IMG SRC="doc-files/m2mparch1.png">
<BR>
<FONT SIZE="-1"
<B>Figure 1.</B>
Multiple M2MP application processes on a device
</FONT>
</CENTER>

<P>
Here there are one or more M2MP-based applications
running in different processes
on the same device.
In this case,
an additional process,
the M2MP Daemon process,
must also be running on the device.
Each application process has an instance of the M2MP Layer.
Each M2MP Layer uses a "daemon channel"
to communicate with the M2MP Daemon process.
The M2MP Daemon process in turn
uses another channel to communicate
with other devices over the external network.
Figure 1 shows the M2MP Daemon process
using a "UDP multicast channel"
to communicate with other devices
using UDP multicast datagrams.
To use a different kind of external network,
M2MP can be configured to use a different kind of channel.

<P>
An M2MP message sent from an application process within the device
arrives at the M2MP Daemon process
via the daemon channel.
The M2MP Daemon process
then forwards a copy of the message
to every other application process within the device,
and the M2MP Daemon process
also broadcasts a copy of the message
on the external network.
An M2MP message sent from an application process in another device
arrives at the M2MP Daemon process
via the channel connected to the external network.
The M2MP Daemon process
then forwards a copy of the message
to every application process within the device.
In this way,
an M2MP message gets broadcast everywhere
except to the process that sent it.

<P>
Figure 2 shows the other way to configure the M2MP Layer.
If there is only one M2MP-based application process on a device,
then the M2MP Daemon process is not needed,
and the application process's M2MP Layer
can communicate directly with the external network.

<P>
<CENTER>
<IMG SRC="doc-files/m2mparch2.png">
<BR>
<FONT SIZE="-1"
<B>Figure 2.</B>
A single M2MP application process on a device
</FONT>
</CENTER>

<P>
<HR>
<A NAME="configuring"><H2>2. Configuring the M2MP Layer</H2></A>

<P>
Both the M2MI Layer and the M2MP Layer are configured
by means of a "device properties file"
containing a device ID value.
Typically, the device properties file
is named <TT>"device.properties"</TT>
and resides in the home directory of your account.
With the device properties file located in your home directory,
every application that runs in your account
will use the same device ID.
Another possibility
is to put the <TT>"device.properties"</TT> file
in a subdirectory;
then every application that runs in that subdirectory
will use that file to get the device ID
(instead of the file in your home directory if any).
See class <A HREF="../device/DeviceProperties.html">DeviceProperties</A>
for further information
about where the device properties file can be located.

<P>
Here is the typical recommended contents
of the device properties file.
If you use this example,
be sure to change the value
of the <TT>edu.rit.device.id</TT> property.

<P>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>
<TR>
<TD ALIGN="left" VALIGN="top">
<FONT SIZE="-1">
<PRE>
# Device Properties File

# Globally unique device ID (hexadecimal integer, 000000000000 .. 3FFFFFFFFFFF)
edu.rit.device.id = 00087443BC87
</PRE>
</FONT>
</TD>
</TR>
</TABLE>

<P>
The meaning of the above setting is as follows.
See class <A HREF="../device/DeviceProperties.html">DeviceProperties</A>
for further information
about the possible property settings.
<UL>
<LI>
<TT><B>edu.rit.device.id</B></TT> --
The globally unique device ID of the device.
It must be a 48-bit hexadecimal integer in the range
<TT>000000000000</TT> through <TT>3FFFFFFFFFFF</TT>.
Every device in the world must use a different device ID.
The suggested value is the Ethernet MAC address
of the device's network interface.
<I>Be sure to specify a different device ID
on each different machine that is running M2MP!</I>
</UL>

<P>
The M2MP Layer is also configured
by means of an "M2MP properties file"
containing a number of configuration settings.
Typically, the M2MP properties file
is named <TT>"m2mp.properties"</TT>
and resides in the home directory of your account.
With the M2MP properties file located in your home directory,
every application that runs in your account
will use the same configuration for the M2MP Layer.
Another possibility
is to put the <TT>"m2mp.properties"</TT> file
in a subdirectory;
then every application that runs in that subdirectory
will use that file to configure the M2MP Layer
(instead of the file in your home directory if any).
See class <A HREF="M2MPProperties.html">M2MPProperties</A>
for further information
about where the M2MP properties file can be located.

<P>
Here is the typical recommended contents
of the M2MP properties file.
A copy of this file is included in the M2MP Library
(<A HREF="doc-files/m2mp.properties"><TT>m2mp.properties</TT></A>).

<P>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>
<TR>
<TD ALIGN="left" VALIGN="top">
<FONT SIZE="-1">
<PRE>
# M2MP Properties File

# Message timeout, milliseconds (decimal integer &gt; 0)
edu.rit.m2mp.messagetimeout = 5000

# Flow control timeout, milliseconds (decimal integer &gt; 0)
edu.rit.m2mp.flowtimeout = 100

# Packet redundancy (decimal integer &gt; 0)
edu.rit.m2mp.redundancy = 2

# ReceiverThread debug level (integer)
# 0 = Don't print
# 1 = Print exception stack traces
# 2 = Print exception stack traces and debug messages
edu.rit.m2mp.debug.ReceiverThread = 0

# Packet debug level (integer)
# 0 = Don't print
# 1 = Print packet arrivals and departures
# 2 = Print packet arrivals and departures, including packet contents
edu.rit.m2mp.debug.packets = 0

# Message filter debug level (integer)
# 0 = Don't print
# 1 = Print message filter additions and removals
# 2 = Print message filter additions and removals including message prefixes
edu.rit.m2mp.debug.messagefilters = 0

# M2MP Daemon process's port number (0 if no M2MP Daemon process)
edu.rit.m2mp.daemon.port = 5678

# M2MP channel implementation class name
edu.rit.m2mp.channel.class = edu.rit.m2mp.udp.UDPMulticastChannel
</PRE>
</FONT>
</TD>
</TR>
</TABLE>

<P>
The meanings of the above settings are as follows.
See class <A HREF="M2MPProperties.html">M2MPProperties</A>
for further information
about the possible property settings.
<UL>
<LI>
<TT><B>edu.rit.m2mp.messagetimeout = 5000</B></TT> --
The M2MP Layer will time out and abort an incoming message
if there is a gap longer than 5000 milliseconds (5 seconds)
between successive packets of the message.
<BR>&nbsp;
<LI>
<TT><B>edu.rit.m2mp.flowtimeout = 100</B></TT> --
After transmitting a packet,
the M2MP Layer will wait at most 100 milliseconds
before sending the next packet.
The M2MP Layer will usually send the next packet sooner than this.
See "<A HREF="#packets">M2MP Packet Format and Processing</A>"
below for further information.
<BR>&nbsp;
<LI>
<TT><B>edu.rit.m2mp.redundancy = 2</B></TT> --
To compensate for the possibility of lost packets,
the M2MP Layer will send each outgoing packet twice.
See "<A HREF="#packets">M2MP Packet Format and Processing</A>"
below for further information.
<BR>&nbsp;
<LI>
<TT><B>edu.rit.m2mp.debug.ReceiverThread = 0</B></TT> --
The M2MP Layer will not print any debug messages,
such as exception stack traces,
when receiving incoming M2MP messages.
<BR>&nbsp;
<LI>
<TT><B>edu.rit.m2mp.debug.packets = 0</B></TT> --
The M2MP Layer will not print any debug messages
showing the contents of each incoming and outgoing packet.
<BR>&nbsp;
<LI>
<TT><B>edu.rit.m2mp.debug.messagefilters = 0</B></TT> --
The M2MP Layer will not print any debug messages
showing each message filter that is added or removed.
<BR>&nbsp;
<LI>
<TT><B>edu.rit.m2mp.daemon.port = 5678</B></TT> --
The M2MP Layer will use the M2MP Daemon process
to route M2MP messages
among separate processes on this device
as well as the external network.
The M2MP Daemon process will listen
to IP address 127.0.0.1 (localhost) and port 5678
for connections from M2MP client processes.
<BR>&nbsp;
<LI>
<TT><B>edu.rit.m2mp.channel.class = edu.rit.m2mp.udp.UDPMulticastChannel</B></TT> --
The M2MP Daemon process
will use an instance of class
<A HREF="udp/UDPMulticastChannel.html">edu.rit.m2mp.udp.UDPMulticastChannel</A>
to communicate with the external network.
The UDP multicast channel will use default values
for all its parameter settings
(see class <A HREF="udp/UDPMulticastChannel.html">UDPMulticastChannel</A>
for further information).
</UL>

<P>
The above M2MP properties file
is configured for the typical case
where M2MP client processes
communicate with M2MP client processes in other devices
via an external network.
If M2MP client processes
will never communicate with other devices,
change the M2MP channel class setting as follows:
<BR>&nbsp;
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;edu.rit.m2mp.channel.class = edu.rit.m2mp.NullChannel</TT>

<P>
The above M2MP properties file
is also configured for the typical case
where multiple M2MP client processes
are running in the same device
and the M2MP Daemon process is used
to route M2MP messages
among the client processes
as well as the external network.
If only one M2MP client process
will ever run on the device,
then the M2MP Daemon process is not needed.
In that case,
change the M2MP Daemon port setting as follows:
<BR>&nbsp;
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;edu.rit.m2mp.daemon.port = 0</TT>
<BR>&nbsp;
<BR>The M2MP Layer
will then communicate directly with the external network
using an instance of the channel class
specified by the <TT>edu.rit.m2mp.channel.class</TT> property.

<P>
<HR>
<A NAME="daemon"><H2>3. Running the M2MP Daemon</H2></A>

<P>
If the M2MP Layer is configured to use the M2MP Daemon
(property <TT>edu.rit.m2mp.daemon.port</TT> is not 0),
then you must run the M2MP Daemon
in a separate process
<I>before</I> running any M2MP- or M2MI-based applications.
To run the M2MP Daemon process,
type this command:
<BR>&nbsp;
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;java edu.rit.m2mp.Daemon</TT>

<P>
<HR>
<A NAME="writing"><H2>4. Working With the M2MP Library</H2></A>

<P>
If you write applications using M2MI,
you never need to work with the M2MP Library directly.
For those who want to use M2MP without using M2MI,
this section gives an overview
of how to write M2MP-based applications
using the M2MP Library.
For more detailed information,
refer to the documentation
for the various classes and methods.

<P>
The key component is class <A HREF="M2MP.html">M2MP</A>,
which encapsulates an instance of the M2MP Layer
and provides methods for working with M2MP.
Also important are the <A HREF="Channel.html">Channel</A> abstract class
and the classes that extend it.

<P>
<H3>2.1. Initialization</H3>

<P>
To use the M2MP Layer,
create an instance of class <A HREF="M2MP.html">M2MP</A>
by calling the <A HREF="M2MP.html#M2MP()"><TT>M2MP()</TT></A> constructor.
The constructor gets the parameters it needs
to configure the M2MP Layer
from the M2MP properties file
(see "<A HREF="#configuring">Configuring the M2MP Layer</A>").

<P>
<H3>2.2. Sending M2MP Messages</H3>

<P>
To send an outgoing M2MP message, call the
<A HREF="M2MP.html#createOutgoingMessage()"><TT>createOutgoingMessage()</TT></A>
method to create an output stream for the
message; write the message contents to the output stream; and close the
output stream. You may write multiple outgoing messages concurrently in
separate threads.

<P>
<B><I>Warning:</I></B> It is very important to close the output stream when
finished with it, including when an exception is thrown while writing the
output stream. If you don't close the output stream, the M2MP Layer will time
out and abort the message.

<P>
<B><I>Warning:</I></B> The sending M2MP Layer will broadcast a packet
containing the message data whenever enough bytes have been written to the
output stream. On the receiving side, after receiving a packet of a message,
the M2MP Layer starts a timeout for receiving the next packet of the message.
If you pause too long while writing the message's output stream, you risk
having the receiving M2MP Layer time out and abort the message.

<P>
<H3>2.3. Receiving M2MP Messages</H3>

<P>
To receive incoming M2MP messages, first register one or more
appropriate <I>message filters</I> by calling the
<A HREF="M2MP.html#addMessageFilter(byte[])"><TT>addMessageFilter(byte[])</TT></A>
method. If you don't register any message filters, the M2MP Layer will never
receive any messages. Then call the
<A HREF="M2MP.html#acceptIncomingMessage()"><TT>acceptIncomingMessage()</TT></A>
method
to obtain an input stream for reading an incoming message that matched one of
the registered message filters; read the message contents from the input
stream; and close the input stream. Repeat these steps to receive the next
incoming M2MP message. You may read and process multiple incoming messages
concurrently by calling
<A HREF="M2MP.html#acceptIncomingMessage()"><TT>acceptIncomingMessage()</TT></A>
in one thread and
reading each message's input stream in its own separate thread.

<P>
<B><I>Warning:</I></B> Don't let the application go for a long time without
calling the
<A HREF="M2MP.html#acceptIncomingMessage()"><TT>acceptIncomingMessage()</TT></A>
method. If an incoming message
becomes available but
<A HREF="M2MP.html#acceptIncomingMessage()"><TT>acceptIncomingMessage()</TT></A>
is not called, the
M2MP Layer will time out and discard the incoming message, and the
application will miss the message.

<P>
A message filter is specified by a <I>message prefix</I>, a sequence of
bytes. An incoming message matches a message filter if the initial bytes of
the message are the same as the message filter's message prefix. A
zero-length message prefix matches any incoming message.

<P>
To remove a message filter, call the
<A HREF="M2MP.html#removeMessageFilter(byte[])"><TT>removeMessageFilter(byte[])</TT></A>
method. Thereafter,
the M2MP Layer will no longer receive incoming M2MP messages that match
the message filter, unless they match another still-registered message
filter.

<P>
The M2MP Layer receives any M2MP message sent anywhere in the system,
regardless of its source, provided the M2MP message matches one of the
registered message filters. A different device may have sent the M2MP
message, or a different process on the same device may have sent the M2MP
message. There is one exception: An outgoing message created by a certain
M2MP instance will not be received by that same M2MP instance. In other
words, an instance of the M2MP Layer broadcasts outgoing messages everywhere,
except to itself.

<P>
<H3>2.4. Writing an M2MP Channel</H3>

<P>
An M2MP <I>channel</I> interfaces the M2MP Layer
to the underlying network.
While the M2MP Library comes with several channel implementations,
you may wish to write your own custom channel implementations.
Every M2MP channel implementation must extend
class <A HREF="Channel.html">Channel</A>.
See class <A HREF="Channel.html">Channel</A>
for information about writing a channel implementation.
Also, study the channel implementations
included in the M2MP Library:
class <A HREF="DaemonChannel.html">DaemonChannel</A>,
class <A HREF="udp/UDPChannel.html">UDPChannel</A>,
class <A HREF="udp/UDPMulticastChannel.html">UDPMulticastChannel</A>,
and class <A HREF="udp/UDPUnicastChannel.html">UDPUnicastChannel</A>.

<P>
<HR>
<A NAME="packets"><H2>5. M2MP Packet Format and Processing</H2></A>
<P>
Using M2MP, a group of devices
transmit a series of M2MP packets to each other
over a shared broadcast channel.
The packets convey information
for two logically independent sublayers:
the flow control sublayer and the message transfer sublayer.
The flow control sublayer tries to ensure that
a transmitting device does not send messages
faster than the receiving devices can handle.
The message transfer sublayer
transfers the actual M2MP message data
between the devices.
<P>
<B>Packet Format</B>
<P>
The maximum size of an M2MP packet is 508 bytes.
This number is chosen so that an M2MP packet
will not be fragmented if carried over an IP network layer.
<P>
The format of an M2MP packet is as follows.
Multibyte fields are stored in big-endian order
(most significant byte first).
Bits within a 32-bit field
are numbered from 31 (most significant bit) to 0 (least significant bit).
<P>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>
<TR BGCOLOR="#CCCCCC">
<TD ALIGN="center" VALIGN="bottom"><I>Length<BR>(bytes)</I></TD>
<TD ALIGN="center" VALIGN="bottom"><I>Bits</I></TD>
<TD ALIGN="center" VALIGN="bottom"><I>Contents</I></TD>
</TR>
<TR>
<TD ALIGN="center" VALIGN="center">4</TD>
<TD ALIGN="center" VALIGN="center">31&nbsp;..&nbsp;0</TD>
<TD ALIGN="center" VALIGN="center">Message&nbsp;ID</TD>
</TR>
<TR>
<TD ALIGN="center" VALIGN="center" ROWSPAN=2>4</TD>
<TD ALIGN="center" VALIGN="center">31</TD>
<TD ALIGN="center" VALIGN="center">Last&nbsp;packet&nbsp;flag</TD>
</TR>
<TR>
<TD ALIGN="center" VALIGN="center">30&nbsp;..&nbsp;0</TD>
<TD ALIGN="center" VALIGN="center">Fragment&nbsp;number</TD>
</TR>
<TR>
<TD ALIGN="center" VALIGN="center">0&nbsp;..&nbsp;500</TD>
<TD ALIGN="center" VALIGN="center">&nbsp;</TD>
<TD ALIGN="center" VALIGN="center">Message&nbsp;fragment</TD>
</TR>
</TABLE>
<P>
The fields' contents are as follows:
<UL>
<LI>
<B>Message ID</B> -- A 32-bit number that uniquely identifies an M2MP message.
All data packets of the same message
have the same value in the message ID field.
Used by the receiving M2MP Layer to piece multi-packet messages back
together. Each message's message ID comes from a
<A HREF="../crypto/MuH1Random.html">MuH1Random</A>
pseudorandom number
generator which is seeded differently in each device. Even if multiple
devices are sending M2MP messages at the same time, the chance of having two
messages with the same message ID is negligible.
<BR>&nbsp;
<LI>
<B>Last packet flag</B> -- 0 if this is not the last data packet in the
message, 1 if this is the last data packet in the message.
<BR>&nbsp;
<LI>
<B>Fragment number</B> -- The number of the message fragment contained in
this data packet. Fragments of a message are numbered sequentially starting
with 0.
<BR>&nbsp;
<LI>
<B>Message fragment</B> -- The fragment of the message (data bytes) contained
in this data packet. The number of bytes in the message fragment is the
number of bytes in the packet minus the overhead size (8 bytes). The number of
bytes in the packet is reported to the M2MP Layer by the underlying data link
layer. Each message fragment is from 0 to 500 bytes long.
</UL>
<P>
An M2MP message is divided into message fragments as follows. Let the message
length in bytes <I>n</I> = <I>q</I> * 500 + <I>r,</I> where <I>q</I> &gt;= 0
and 0 &lt;= <I>r</I> &lt; 500. Then there are <I>q</I> message fragments
of length 500 bytes,
followed by one message fragment of length <I>r</I> bytes
if <I>r</I> &gt; 0.
<P>
<B>Flow Control Sublayer</B>
<P>
When two devices communicate over a network,
<I>flow control</I> prevents the transmitter
from sending data faster than the receiver can handle it,
causing the receiver's transport layer buffers to overflow
and packets to be lost.
Flow control is usually done using <I>acknowledgments:</I>
After sending a certain amount of data,
the transmitter stops
until it receives an acknowledgment from the receiver
that the data has been processed,
then the transmitter resumes sending data.
While acknowledgments are easy to implement
in a point-to-point connection with only one receiver,
acknowledgments are more difficult to implement
when there are multiple receivers,
as in the applications M2MP targets.
The difficulties are compounded in an <I>ad hoc</I> network
where devices arrive and depart constantly.
To keep M2MP simple,
hence better suited for small mobile devices,
the M2MP Layer does not use acknowledgments for flow control.
<P>
When the transmitting device's M2MP Layer
sends a packet onto the external network,
the M2MP Layer also receives that packet.
In other words, outgoing packets are "looped back"
and received from the external network
along with incoming packets from other devices.
All the looped-back and incoming packets go into a queue
and are processed in sequence.
After sending an outgoing packet,
the M2MP Layer waits to send the next outgoing packet
until (a) the looped-back copy of the outgoing packet
has been received and removed from the queue
(the looped-back packet is discarded
and not passed up to higher layers), and
(b) any other incoming packets after the looped-back packet
have also been removed from the queue
(these packets are passed up to higher layers).
The M2MP Layer then sends the next outgoing packet,
and the process repeats.
While waiting for the looped-back packet to show up,
the M2MP Layer does a timeout for the interval
given by the <TT>edu.rit.m2mp.flowtimeout</TT> property
in the M2MP properties file.
If the timeout expires before the looped-back packet shows up,
the M2MP Layer assumes the looped-back packet got lost
and proceeds to send the next outgoing packet.
<P>
The idea behind this flow control scheme
is that by making the transmitting device
receive and process its own outgoing packets,
the transmitting device is performing flow control on itself.
If the transmitting device can keep up with itself,
it assumes that the other receiving devices
can keep up with the transmitting device.
While this flow control scheme is simple,
this scheme does not guarantee
that some device's transport layer buffer won't overflow,
as an acknowledgment-based scheme does.
However, if M2MP messages are not being sent continuously
(a situation for which M2MP was not designed),
this flow control scheme only occasionally loses a packet
due to buffer overflow.
<P>
The flow control sublayer
does not address the issue
of contention for the broadcast medium;
it assumes that contention is resolved
at the data link layer.
The wired Ethernet data link layer, for example,
does do contention resolution.
The wireless Ethernet data link layer, on the other hand,
does contention resolution for unicast packets
but not for multicast or broadcast packets.
<P>
Also, the flow control sublayer
does not provide reliable packet delivery.
This is not a problem on a wired Ethernet
which very rarely loses packets.
A wireless Ethernet, on the other hand,
occasionally loses packets,
resulting in M2MP message failures.
The application using M2MP must compensate
for failed M2MP messages if necessary.
<P>
<B>Message Transfer Sublayer</B>
<P>
The message transfer sublayer
sits on top of the flow control sublayer.
The flow control sublayer accepts outgoing message fragments
from the message transfer sublayer
and provides incoming message fragments
to the message transfer sublayer.
<P>
On the outgoing side,
the message transfer sublayer
breaks each outgoing M2MP message into message fragments
and sends them one at a time
to the flow control sublayer.
The flow control sublayer blocks
until the packet has been transmitted and looped back
as described above,
then the flow control sublayer
accepts the next outgoing message fragment.
<P>
On the incoming side,
whenever an incoming packet (not a looped-back packet) is received,
the flow control sublayer
passes the packet up to the message transfer sublayer.
The message transfer sublayer uses the packet's
message ID, fragment number, and last packet flag fields
to reassemble the message fragments back into messages.
The first fragment of each message
is compared to all the registered message filters.
Messages matching a message filter
are passed on up to higher layers;
messages not matching a message filter are discarded.
<P>
Once the message transfer sublayer
receives a particular message fragment of a message,
the message transfer sublayer starts a timeout
while waiting for the next message fragment of the message.
The timeout interval is given by the
<TT>edu.rit.m2mp.messagetimeout</TT> property
in the M2MP properties file.
If the timeout occurs before the next message fragment arrives,
the message transfer sublayer abandons the message
and signals an exception to the application receiving the message.
<P>
While M2MP is not a reliable data transfer protocol,
M2MP does include a feature
intended to compensate for packets lost at the data link layer.
(A wireless Ethernet, for example,
loses packets more frequently than we'd like.)
The message transfer sublayer
sends each outgoing packet <I>N</I> times,
where <I>N</I> is given by
the <TT>edu.rit.m2mp.redundancy</TT> property
in the M2MP properties file.
If <TT>edu.rit.m2mp.redundancy</TT> = 2, for example,
each outgoing packet is sent twice.
That way, if one copy of a packet is lost,
the devices may still receive the other copy,
and the M2MP message will not be aborted.
(If both copies of a packet are received,
the message transfer sublayer discards the redundant copy.)
This can greatly reduce the incidence of aborted M2MP messages
when using a less-than-reliable data link layer.
If the data link layer is reliable --
such as a wired Ethernet which almost never loses packets --
then set the <TT>edu.rit.m2mp.redundancy</TT> property to 1.
<P>

<P>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../edu/rit/m2mi/test/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../edu/rit/m2mp/udp/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<FONT SIZE="-2">Copyright &copy; 2001-2004 by Alan Kaminsky. All rights reserved. Send comments to ark</FONT><FONT SIZE="1" COLOR="#FFFFFF">&shy;</FONT><FONT SIZE="-2">&#64;</FONT><FONT SIZE="1" COLOR="#FFFFFF">&shy;</FONT><FONT SIZE="-2">cs.rit.edu.</FONT>
</BODY>
</HTML>
