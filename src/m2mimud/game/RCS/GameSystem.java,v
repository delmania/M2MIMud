head	1.33;
access;
symbols;
locks
	rjw2183:1.33; strict;
comment	@# @;


1.33
date	2005.01.13.15.47.18;	author rjw2183;	state Exp;
branches;
next	1.32;

1.32
date	2005.01.12.14.03.17;	author rjw2183;	state Exp;
branches;
next	1.31;

1.31
date	2004.12.16.16.39.44;	author rjw2183;	state Exp;
branches;
next	1.30;

1.30
date	2004.12.14.17.22.47;	author rjw2183;	state Exp;
branches;
next	1.29;

1.29
date	2004.12.10.02.29.05;	author rjw2183;	state Exp;
branches;
next	1.28;

1.28
date	2004.11.11.04.28.30;	author rjw2183;	state Exp;
branches;
next	1.27;

1.27
date	2004.10.21.02.47.38;	author rjw2183;	state Exp;
branches;
next	1.26;

1.26
date	2004.09.24.03.43.04;	author rjw2183;	state Exp;
branches;
next	1.25;

1.25
date	2004.09.23.03.58.46;	author rjw2183;	state Exp;
branches;
next	1.24;

1.24
date	2004.09.22.03.27.25;	author rjw2183;	state Exp;
branches;
next	1.23;

1.23
date	2004.09.17.04.04.43;	author rjw2183;	state Exp;
branches;
next	1.22;

1.22
date	2004.09.10.02.32.49;	author rjw2183;	state Exp;
branches;
next	1.21;

1.21
date	2004.08.17.17.53.26;	author rjw2183;	state Exp;
branches;
next	1.20;

1.20
date	2004.08.16.18.30.30;	author rjw2183;	state Exp;
branches;
next	1.19;

1.19
date	2004.08.12.01.21.11;	author rjw2183;	state Exp;
branches;
next	1.18;

1.18
date	2004.08.11.20.06.44;	author rjw2183;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.22.19.33.44;	author rjw2183;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.16.18.35.57;	author rjw2183;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.06.19.57.41;	author rjw2183;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.01.19.49.42;	author rjw2183;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.29.20.00.18;	author rjw2183;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.23.19.57.24;	author rjw2183;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.22.15.19.32;	author rjw2183;	state Exp;
branches;
next	1.10;

1.10
date	2004.06.22.15.18.58;	author rjw2183;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.22.15.18.42;	author rjw2183;	state Exp;
branches;
next	1.8;

1.8
date	2004.06.17.15.53.18;	author rjw2183;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.16.19.58.35;	author rjw2183;	state Exp;
branches;
next	1.6;

1.6
date	2004.06.16.00.51.32;	author rjw2183;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.15.19.51.41;	author rjw2183;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.11.19.16.08;	author rjw2183;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.11.17.22.37;	author rjw2183;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.10.18.22.40;	author rjw2183;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.10.17.14.37;	author rjw2183;	state Exp;
branches;
next	;


desc
@@


1.33
log
@*** empty log message ***
@
text
@/**
 * The GameSystem object serves two roles.  The first role is that of the
 * command executor.  When the user inputs a command, it is turned from a string into
 * the appropiate Command object and then passed to this class to be executed.  The other role,
 * which is tied to that of its first role, is the Game object.  The Game object is what is used
 * by the members of the session to communicate what their player is doing.  As such, the GameSystem
 * object can be seen as the controller for the entire system.  Commands are processe by it,
 * sent out by it, and received by it.  This is intentional, as one of the aims was to have 
 * the message that concern the state of the session to be sent and recieved by only on object
 * in order to ensure that one event happens at a time.  Of course, this comes at a price.
 * This class is very large. In fact it is the single largest class in the system.
 * 
 * @@author: Robert Whitcomb
 * @@version: $Id: GameSystem.java,v 1.32 2005/01/12 14:03:17 rjw2183 Exp rjw2183 $
 */

package m2mimud.game;

import java.io.*;
import java.util.Iterator;
import java.util.Vector;
import java.util.Random;
import java.awt.Color;
import edu.rit.util.Timer;
import edu.rit.util.TimerTask;
import edu.rit.util.TimerThread;
import edu.rit.m2mi.M2MI;
import edu.rit.m2mi.Eoid;
import edu.rit.m2mi.Multihandle;
import edu.rit.m2mi.Unihandle;
import m2mimud.communications.*;
import m2mimud.command.*;
import m2mimud.command.special.*;
import m2mimud.state.*;
import java.util.Date;

public class GameSystem
extends SessionAdvertiser
implements Game, GCWindowListener,
TimeListener, MerchantListener,
MobListener, PlayerCacheListener 
{
	// Session related data members
	private Game myHandle;  // this unit's unihandle
	private boolean inSession; // indicates if the unit is in a session
	private String mySessionName; // name of the session the unit isa member of
	private Game mySession; // handle to the session this game is a part of

	// State related state members
	private PlayerCharacter myPlayer; // the player for this unit
	private World myMap; // the world for this unit
	private GameState myState; // the state of this game
	private GameState incomingState; // used when joining a session, this is the incoming state of the game
	private TimeManager myTimeManager; // the manager for the passage of time
	private ItemData myItemData;  // the item data of the game
	String stateName; // the file name of that state, this is sed for the shortcut save command

	// combat related data members
	private Mob theMobTarget; // The mob target the player is attacking
	private PlayerCharacter thePlayerTarget; // the player target the player is currently fighting.
	private boolean hasBalance; // indicated if this persdon curretly has balance
	private int round; // the round of attack this is
	private boolean consideringDuel; // indicates if this toon is currently considering a duel
	private Eoid currentChallenger; // the current duel challenger
	private Timer attackTimer; // timer used to notify when the player has balance
	boolean ignoreBroadcasts; // a flag to indicate if a unit needs to ignore a broadcast


	// Misc data members
	private PlayerCommunicator comm; // used to talk to the player
	private String[] attacks; // an array used to print out the type of attack
	private MapWindow myMapWindow; // the map windoe
	private Random mobMover; //  A random used to generate the movement of the next mob
	private Vector lookupVector; // the vector which stores the data from a lookup
	private FriendsList myFriendsList; // a friends' listing for this user
	private int myPartNum;
	boolean leftSession; //  A boolean to indicate if the user left a session
	private PlayerRefresher myPlayerRefresher; // used as a heartbeat

    	SessionFinder sessionFinder; // the object used to find sessions.

	// Used for synchronization
	private boolean available;

	private class AttackTimerTask
	implements TimerTask
        {
		public AttackTimerTask() 
		{
        	}

        	public void action( Timer theTimer ) 
		{
           		setAttack( theTimer );
        	}
    	}

	private void setAttack( Timer theTimer ) 
	{    
        	setBalance( true );
	}
/********************************************************************************************************************************/
	/**
	 * Constructor
	 */
	public GameSystem( PlayerCommunicator theComm )
	throws Exception 
	{
		// Basically this initializes the program's data members
		super();
		comm = theComm;
		// check to make sure that the required game directories are present and valid
		createDirectory( "players" );
		createDirectory( "maps" );
		createDirectory( "states" );
		createDirectory( "data" );								
		leftSession = false;

		// Set up the combat and report timers
		intervalPRNG = new Random();
        	attackTimer = TimerThread.getDefault().createTimer( new AttackTimerTask() );

		// Set up the M2MI communications
       		M2MI.export( this, Game.class );
		M2MI.export( this, GameDiscovery.class );
        	myHandle = (Game)M2MI.getUnihandle( this, Game.class );
        	stateName = null;
        	myPartNum = 0;

        	myTimeManager = new TimeManager( this );
        	lookupVector = new Vector();
        	loadItemData();
        	available = true;
        	attacks = new String[4];
        	attacks[0] = "punch";
        	attacks[1] = "kick";
        	attacks[2] = "slash";
        	attacks[3] = "thrust";
        	hasBalance = true;
        	round = 0;
		consideringDuel = false;
        	currentChallenger = null;
		incomingState = null;
        	myMapWindow = new MapWindow();
        	myPlayer = null;
        	myMap = null;
        	comm.printMessage( "Welcome to M2MIMud! Please create or load a new character." );
        	comm.printMessage( "Upon obtaining a character, s/he will be placed into the default world, " +
        	"from where you can load up another world (or map) to begin play." );


		// Other data member initalization
        	inSession = false;
        	mySession = null;
        	mobMover = new Random();
	}
/********************************************************************************************************************************/
        /*
         * These two functions provide some synchronization for the game system.
         * Their sole function is to ensure that the game system performs one task at a time,
         * so that the task is completed in the state that it started in, and that the task is not lost
         */

	/**
	 * Attempts to lock the GameSystem
	 */
    	private void attemptLock() 
	{
		while( available == false ) 
		{
			try 
			{
				wait();
			}
			catch( Exception e ) 
			{
			}
        	}
		available = false;
	}

	/**
	 * Unlocks the game system, and notifes all waiting threads that the
 	 * system in now available.
	*/
	private void unlock() 
	{
        	available = true;
        	notifyAll();
	}
/********************************************************************************************************************************/
	// The functions of the Game interface, which are used to maintain state and such

	/**
	 * Prints out the user's message.  Unlike a say, this is broadcast to everyone on the map.
	 * @@param: message The message from the user
	 * @@param: handle The handle of the game which controls the player
	 * @@param: playerName The name of the player
	 */
	public synchronized void yell( SayData theMessage, int partition ) 
	{
		if( partition == myPartNum ) 
		{
			attemptLock();
			if( !myPlayer.getId().equals( theMessage.playerId ) ) 
			{
				PlayerCharacter thePlayer = checkId( theMessage.playerId );
				String name = "Someone";
				if( thePlayer != null )
					name = thePlayer.getName();
				comm.printMessage( name + " yells, \"" + theMessage.myMessage + "\"" );
			}
			unlock();
		}
	}

	/**
	 * Performs a say, which causes the message to be displayed if this unit's
	 * player is in the same room as the player who did the say
	 * @@param the Message The object that contains the information needed to do the message.
	 */
	public synchronized void say( SayData theMessage, int partition )
	{
		if( partition == myPartNum )
		{
			attemptLock();
			if( !myPlayer.getId().equals( theMessage.playerId ) )
			{
				PlayerCharacter thePlayer = checkId( theMessage.playerId );
				String name = "Someone";
				if( thePlayer != null ) 
				{
					name = thePlayer.getName();
					checkLocation( thePlayer, theMessage.playerLoc );
        	        	}
				if( myMap.checkLoc( theMessage.playerLoc ) )
				comm.printMessage( name + " says, \"" + theMessage.myMessage + "\"" );
            		}
			unlock();
		}
	}


	/**
	 * Tells the session someone is joining.
	 * @@param: handle The handle of the joining game unit
	 * @@param: player The player character data of the player
	 * @@param: newState the state of the world which is joining
	*/
	public synchronized void joinSession( PlayerCharacter player, int partition )
	{
        	if( partition == myPartNum )
		{
			attemptLock();
	
			// First things first - stop the report
			// timer and add the player.
			reportTimer.stop();
		
			// Reset the time
			myState.setTime( myTimeManager.getTime() );

			// Print out the notification
			comm.printMessage( player.getName() + " has joined our world." );

			if( myFriendsList.hasPlayer( player.getId() ) )
				comm.printMessage( "Your friend, " + player.getName() + 
				                   " has joined this session." );

			// Restart the timer
			scheduleNormalReport();

			// display the current world
			if( myPlayer.getId().equals( player.getId() ) )
				printCurrentRoom();

			// Final step! If my player is in combat, remnd everyone.
			if( myPlayer.isInCombat() )
			{
				if( myPlayer.hasMobTarget() )
				{
					mySession.registerAttacker
					( myPlayer.getLocation(), theMobTarget.getKey(),
					myPlayer.getId(),  theMobTarget.getCombatTimeStamp(),
					myPartNum );
				}
			}
			unlock();
		}
	}

	/**
	* Tells the session someone is leaving.
	* @@param: handle The handle to the game unit which is leaving
	*/
	public synchronized void leaveSession( Eoid playerId, int partition )	
	{
		if( partition == myPartNum ) 
		{
			attemptLock();
			reportTimer.stop();
			PlayerCharacter leavingPlayer = checkId( playerId );
			if( leavingPlayer != null ) 
			{
				String name = leavingPlayer.getName();

				// If the leaving player is in combat, the unit
				// needs to drop the targets from that fight.
				// Obviously since, at this point, something is wrong,
				// the system will then request an emergency transmission
				// in an attempt to perform state synchronization.
				if( leavingPlayer.isInCombat() ) 
				{
						if( leavingPlayer.hasMobTarget() )
					{
						MobKey theKey = (MobKey)leavingPlayer.getTarget();
						Mob theMob = (Mob)myState.get( GameState.MOB, theKey );
						if( !theMob.getKey().equals( myPlayer.getTarget() ) )
							theMob.stopAttack();
						else
							mySession.errorDetected( myPlayer.getId(), myPartNum );
					}
					else
					{
						PlayerCharacter thePlayer = checkId(
						(Eoid)leavingPlayer.getTarget() );
						if( thePlayer != null )
							thePlayer.clearTargetData();
						if( myPlayer.getId().equals( thePlayer.getId() ) ) 
						{
							thePlayerTarget = null;
							comm.printError( "Your fight has been ended." );
							comm.clearCombatLog();
	                        		}
        	            		}
                		}

				if( consideringDuel &&
					leavingPlayer.getId().equals( currentChallenger ) )
				{	
					consideringDuel = false;
					comm.printMessage( "Duel challenge cancelled" );
				}

                		if( consideringDuel && thePlayerTarget != null &&
	                		leavingPlayer.getId().equals( thePlayerTarget.getId() ) ) 
				{
					consideringDuel = false;
					comm.printMessage( "Duel challenge cancelled." );
                		}


                		if( !myPlayer.getId().equals( playerId ) ) 
				{
					myState.remove( GameState.PLAYER, leavingPlayer.getId() );
					comm.printMessage( name + " has left our world." );
					if( myFriendsList.hasPlayer( playerId ) )
						comm.printMessage( "Your friend, " + name +
							   " has left this session." );
					myMap.removePlayer( playerId );
        		    	}
			}
			scheduleNormalReport();
			unlock();
		}
	}

	/**
	 * Moves a player or a mob
	 * @@param theMove An object which contains the data need to perform the move
	 */
	public synchronized void processMove( MoveData aMove, int partition ) 
	{
		if( partition == myPartNum )
		{
			attemptLock();
			switch( aMove.getType() )
	    		{
				case MoveData.PLAYER:
				{
					UserMove theMove = (UserMove)aMove;
					if( !myPlayer.getId().equals( theMove.getUser() ) )
					{
						PlayerCharacter thePlayer = checkId( theMove.getUser() );
						if( thePlayer != null )
						{
							 String name = thePlayer.getName();
							// If the player is in combat....
							// Moving causes the monster they are fighting to
							// stop attacking them.
							if( thePlayer.isInCombat() )
							{
								if( thePlayer.hasMobTarget() )
								{
									Mob theMob = (Mob)myState.get(
									             GameState.MOB,
								                     (MobKey)thePlayer.getTarget() );
									theMob.stopAttack();
									thePlayer.clearTargetData();
                                    					comm.printMessage( thePlayer.getName() +
                                    					" disengages combat with " +
                                   					 theMob.getName() );
                                				}
                               					else 
								{
                                   					PlayerCharacter player =
                                    					checkId( (Eoid)thePlayer.getTarget() );
                                    					if( player != null )
                                      						player.clearTargetData();
                                   
				    					thePlayer.clearTargetData();
                                    					if( myPlayer.equals( player ) ) 
				    					{
                                      						comm.printError
										( "Your fight has been ended." );
                                        					comm.clearCombatLog();
										thePlayerTarget = null;
                                    					}
                                				}
                            				}

                            				// If my player is not in a house and is in either the
                            				// to or from tiles, display something.
                            				if( myMap.checkLoc( theMove.getLoc( MoveData.FROM ) )
                            					&& !myPlayer.isInHouse() ) 
							{
                               					String[] directions = { "north", "south", "east", "west" };
                                				comm.printMessage( name + " leaves to the " +
                                				directions[theMove.getDirection()] );
                            				}
                            				else if( myMap.checkLoc( theMove.getLoc( MoveData.TO ) ) &&
                            					!myPlayer.isInHouse() )
							{
								String[] directions = { "south", "north", "west", "east" };
								comm.printMessage( name + " enters from the " +
								directions[theMove.getDirection()] );
							}
							myMap.processMove( theMove );
						}
					}
                		}
                		break;
               			case MoveData.MOB: 
				{
					MobMove theMove = (MobMove)aMove;
					Mob theMob = (Mob)myState.get( GameState.MOB, theMove.getKey() );
					// Yep.   If the mob is dead or fighting.. there's an error.
					if( !theMob.isAlive() || theMob.isUnderAttack() )
						mySession.errorDetected( myPlayer.getId(), myPartNum );
					else
					{
						myMap.refreshMobTimer( theMove.getKey() );
						if( theMove.getDirection() != -1 ) 
						{
							String name = theMob.getName();
							boolean validMob = myMap.moveMob( theMove );
							if( myMap.checkLoc( theMove.getLoc( MoveData.FROM ) ) && validMob )
							{
								String[] directions = { "north", "south", "east", "west" };
								comm.printMessage("A " + name + " leaves to the " +
								directions[theMove.getDirection()] );
                            				}
                            				else if( myMap.checkLoc( theMove.getLoc( MoveData.TO ) ) && validMob )
							{
								String[] directions = { "south", "north", "west", "east" };
								comm.printMessage(  "A " + name + " enters from the " +
								directions[theMove.getDirection()] );
                            				}
                       				}
                    			
                			}
				 }
               			 break;
			}
			unlock();
		}
	}
    
	/**
	 * Notifies this unit that a player has timed out and must thus be removed.
	 * @@param: handle The unihande of the game unit which has timed out.
	 */
	public synchronized void notifyPlayerTimeout( Eoid playerId, int partition ) 
	{
		if( partition == myPartNum ) 
		{
			attemptLock();
			if( myPlayer.getId().equals( playerId ) && inSession )
			{
				leave();
				comm.printMessage( "Disconnected from the session as there has " +
				"been no activity for 10 minutes." );
			}
			else 
				mySession.leaveSession( playerId, myPartNum );
            	}
           	unlock();
        }    


	/**
         * Sets a pond at the given location
	 * @@param location The location to place the pond at
	 * @@param playerId The id of the player who dug the pond
	 */
	public synchronized void setPond( XYloc location, Eoid playerId, int partition )
	{
		if( partition == myPartNum ) 
		{
			attemptLock();
			if( !myPlayer.getId().equals( playerId ) )
			{
				PlayerCharacter thePlayer = checkId( playerId );
				String name = "Someone";
				if( thePlayer != null )
					name = thePlayer.getName();
				checkLocation( thePlayer, location );
				myMap.setPondAt( location );
				if( myMap.checkLoc( location ) )
					comm.printMessage( name + " digs a small pond in the ground." );
            		}
			myState.add( GameState.POND, location );
			unlock();
		}
	}

	/**
	 * Warps the player from one location to another
	 * @@param playerId The id of the player who warped
	 * @@param: from The location the player warped from
	 * @@param: to The location the player warped to
	 */
	public synchronized void warp( Eoid playerId, XYloc from, XYloc to, int partition ) 
	{
		if( partition == myPartNum ) 
		{
			attemptLock();
			if( !myPlayer.getId().equals( playerId ) )
			{
				PlayerCharacter thePlayer = checkId( playerId );
				if( thePlayer != null )
				{
					String name = thePlayer.getName();
					if( myMap.checkLoc( from ) )
						comm.printMessage( name + " suddenly vanishes from sight!" );
					myMap.performWarp( playerId, to );
					if( myMap.checkLoc( to ) )
						comm.printMessage( name + " suddenly phases into view!" );
				}

			}
			unlock();
		}
	}

	/**
	 * Sets up a house
	 * @@param theHouse The house object which contains the location and owner of the house
	 */
	public synchronized void addHouse( House theHouse, int partition ) 
	{
		if( partition == myPartNum )
		{
			attemptLock();
			if( !theHouse.getOwner().equals( myPlayer.getId() ) )
			{
				// Place the house onto the map, checking to make sure
				// that the person who is setting up the house
				// is at the appropiate location
				myMap.placeHouse( theHouse );
				PlayerCharacter thePlayer = checkId( theHouse.getOwner() );
				String name = "Someone";
				if( thePlayer != null ) 
				{
					name = thePlayer.getName();
					checkLocation( thePlayer, theHouse.getLocation() );
				}
				if( myMap.checkLoc( theHouse.getLocation() ) )
					comm.printMessage( name + " builds their house here." );

            		}
			unlock();
		}
	}

	/**
	 * Notifies the system that the time has changed
	 * @@param newTime The new time of the game
	 */
	public synchronized void notifyTimePassage( int newTime, int partition ) 
	{
		if( partition == myPartNum ) 
		{
			attemptLock();
			myTimeManager.synchronize( newTime );
			myState.setTime( newTime );
			myMapWindow.updateTime( newTime );
			comm.printMessage( myTimeManager.getTimePassageString( newTime ) );
			unlock();
		}
	}

	/**
	 * Inform the system that it is time to perform a merchant broadcast, which
	 * causes it to print out the merchant's advertisment message
	 * @@param merchantType The type of merchant which is broadcasting
	 * @@param location The location of the merchant
	 */
	public synchronized void merchantBroadcast( int merchantType, XYloc location, int partition ) 
	{
		if( partition == myPartNum )
		{
			attemptLock();
			if( myMap.checkLoc( location ) )
				comm.printMessage( myMap.getMerchantBroadcast( merchantType ) );
			Merchant theMerch = (Merchant)myState.get( GameState.MERCHANT, location );
			theMerch.scheduleNextMessage();
			unlock();
		}
	}

	/**
	 * Recieves a private message from a player
	 * @@param playerId The id of the player who sent the message
	 * @@param message The message they sent
	 */
	public synchronized void sendPM( Eoid playerId, String message, int partition ) 
	{
		if( partition == myPartNum ) 
		{
			attemptLock();
			String name = "Someone";
			PlayerCharacter thePlayer = checkId( playerId );
			if( thePlayer != null )
				name = thePlayer.getName();
			comm.printMessage( name + " sends, \"" + message + "\"" );
		unlock();
		}
	}

	/**
	 * Tells the system that the given mob is under attack by the given player
	 * This causes the mob to silently register the player as its attack,
	 * which means it stops its movement, but it doesn't inform the system when it attacks
	 * is targets.  Players, however, are told that the mob is fighting a player when
	 * they enter the room and/or perform the /look command.  They are also notifed that the given player
	 * begins attack the monster
	 * @@param loc The location where the mob is
	 * @@param theKey The MobKey of the mob in question
	 * @@param playerId the id of the player.
	 */
	public synchronized void registerAttacker( XYloc loc, MobKey theKey, Eoid playerId, Date ts, int partition )
	{
		if( partition == myPartNum ) 
		{
			attemptLock();
			Mob theMob = (Mob)myState.get( GameState.MOB, theKey );
			if( !myPlayer.getId().equals( playerId ) )
			{
				if( theKey.equals( myPlayer.getTarget() ) )
					mySession.errorDetected( myPlayer.getId(), myPartNum );
				else 
				{
					PlayerCharacter thePlayer = checkId( playerId );
					if( thePlayer != null ) 
					{			
						if( thePlayer.getId().equals( myPlayer.getTarget() ) )
		    				{			 	
			 				comm.printError( "Your fight has been ended." );
							comm.clearCombatLog();
							thePlayerTarget = null;
						}
						myState.clearPlayerTarget( thePlayer );
						thePlayer.registerTarget( theKey );
                        			checkLocation( thePlayer, loc );
                    			}
					theMob.startAttackSilent( playerId, ts );
					if( !theMob.getCurrentLocation().equals( loc ) )
						myMap.moveMob( theMob.getKey(), loc );			
		   
					if( myMap.checkLoc( loc ) )
					{
						String pName = "Someone";
						if( thePlayer != null )
						pName = thePlayer.getName();
						comm.printMessage( pName + " begins attacking the " + theMob.getName() + "!",
						Color.red.darker() );
					}
                		}
			}
			unlock();
		}
	}

	/**
	 * Tells this unit that the 2 players are in combat.
	 * @@param p1 The id of one of the players in combat
	 * @@param p2 The id of the other player in combat
 	 * @@param loc The location where the teo are fighting
	 */
	public synchronized void notifyFight( Eoid p1, Eoid p2, XYloc loc, int partition )
	{
		if( partition == myPartNum ) 
		{
			attemptLock();
			PlayerCharacter playerOne = checkId( p1 );
			PlayerCharacter playerTwo = checkId( p2 );
			String name1 = "Someone";
			String name2 = "someone else";


			// A bit of error detection.  If p1 or p2 are the local player's target,
			// then check to see if they are still fighting the local player.  If not
			// stop combat 
			if( p1.equals( myPlayer.getTarget() ) && !p2.equals( myPlayer.getId() ) ||
			    p2.equals( myPlayer.getTarget() ) && !p1.equals( myPlayer.getId() ) )
				endFightError();

			// Place the 2 players into combat with one another
			if( playerOne != null ) 
			{
				playerOne.clearTargetData();
				playerOne.registerTarget( p2 );
                		name1 = playerOne.getName();
				checkLocation( playerOne, loc );
			}

			if( playerTwo != null ) 
			{
				playerTwo.clearTargetData();
				playerTwo.registerTarget( p1 );
				name2 = playerTwo.getName();
				checkLocation( playerTwo, loc );
			}

			boolean isMe = myPlayer.getId().equals( p1 ) ||
				myPlayer.getId().equals( p2 );

			// Inform the player of the combat
			if( myMap.checkLoc( loc ) && !isMe )
				comm.printMessage( name1 + " and " + name2 + " begin fighting!" );
			unlock();
		}
	}

	/**
	 * Tells this unit to print damage
	 * @@param damage The base amount of damage to do
	 * @@param pId The id of the player who did the damage.  This is passed to make
	 *            sure that the unit that called this function is indeed the person who
	 *           the local player believes she is fighting
	 */
	public synchronized void printAttack( int damage, int partition, Eoid pId ) 
	{
		if( partition == myPartNum &&
			( myPlayer.isInCombat() &&
			pId.equals( myPlayer.getTarget() ) ) ) 
		{
			attemptLock();
			String pName = thePlayerTarget.getName();
			
			// Determine the amount of damage done.  This is done by suvtracting
			// the armor's combat bonus value from the base damage
			int bonus = myItemData.getCombatBonus( myPlayer.getGear( PlayerCharacter.BODY ) );
			if( bonus != -1 )
				damage -= bonus;
			if( damage < 0 )
				damage = 0;
			
			// Report back to the other player the amount of damage she did 
			// to the local player
			thePlayerTarget.getHandle().reportBackDamage( damage, myPartNum );
			comm.printCombatMessage( pName + " attacks you for " + damage + 
				               " damage!", Color.red.darker(), true );
			
			myPlayer.adjustHP( -1 * damage );
			comm.setActivePlayer( myPlayer );
			
			// If the attack has killed the local player, end combat, 
			// and place the local player back at location (0,0) 
			// Also, infoem everyone of the death
			if( !myPlayer.isAlive() )
			{
				comm.printMessage( "You were just killed by " + pName );
				myPlayer.clearTargetData();
				thePlayerTarget.clearTargetData();
				myMap.warp( 0, 0 );
				myPlayer.ressurect();
				comm.setActivePlayer( myPlayer );
				comm.clearCombatLog();
				printCurrentRoom();
				DeathData theInfo =
					new DeathData( myPlayer.getId(), thePlayerTarget.getId() );
				thePlayerTarget = null;
                		mySession.notifyPlayerDeath( theInfo, myPartNum );
            		}
            		unlock();
		}
	}

	/**
	 * Tells this unit to respawn the mob of the given key.
	 * @@param theKey They key of the mob to respawn
	 */
	public synchronized void notifyMobRespawn( MobKey theKey, int partition ) 
	{
		if( partition == myPartNum ) 
		{
			attemptLock();
			Mob theMob = (Mob)myState.get( GameState.MOB, theKey );

			// This is part of the state checking mechanism.
			// If the a respawn is rec'd, but the monster is not
			// dead, something's gone wrong. In this situation,
			// the game requests it's session to perform an emergency report.
			if( !theMob.isAlive()  ) 
			{
                		theMob.respawn();
                		if( myMap.checkLoc( theMob.getCurrentLocation() ) )
                   			comm.printMessage( theMob.getName() + " is restored back to life." );
            		}
            		else
                		mySession.errorDetected( myPlayer.getId(), myPartNum );
            		unlock();
        	}
	}

	/**
	 * Informs this unit that the player was just killed
	 * @@param id The id of the player
	 * @@param loc The location where the player was killed
	 */
	public synchronized void notifyPlayerDeath( DeathData theInfo, int partition ) 
	{
		if( myPartNum == partition ) 
		{
			attemptLock();
			if( !myPlayer.getId().equals( theInfo.getKilled() ) ) 
			{
				PlayerCharacter thePlayer = checkId( theInfo.getKilled() );
				String name = "Someone";
				String name2 = "someone";
				if( thePlayer != null ) 
				{
					name = thePlayer.getName();
					thePlayer.clearTargetData();
					myMap.performWarp( thePlayer.getId(), new XYloc( 0, 0 ) );
                		}

				if( theInfo.getCombatType() == DeathData.MOB ) {
				
					// Error detection - if the player was killed
					// by the mob this unit's player is fighting, something
					// is wrong.
					if( theInfo.getMob().equals( myPlayer.getTarget() ) ||
                    			theInfo.getKilled().equals( myPlayer.getTarget() ) ) 				
						endFightError();
					                    
					Mob theMob = (Mob)myState.get( GameState.MOB,
					                       theInfo.getMob() );
					theMob.stopAttack();
					name2 = theMob.getName();

				}
				else 
				{
                    			PlayerCharacter theOtherPlayer =
                    				checkId( theInfo.getKiller() );
                    			// If the person who killed the player was the person'
                    			// ths unit is fighting, something is wrong.
                   			// also if the person killed was this unit's target
                    			// AND the killer was not this unit, something
                    			// is wrong
					if( theInfo.getKiller().equals( myPlayer.getTarget() ) ||
					  ( theInfo.getKilled().equals( myPlayer.getTarget() ) &&
					    !theInfo.getKiller().equals( myPlayer.getId() ) ) )
						endFightError();				

					if( theOtherPlayer != null ) 
					{
						theOtherPlayer.clearTargetData();
						name2 = theOtherPlayer.getName();
						if( myPlayer.getId().equals( theOtherPlayer.getId() ) ) 
						{
							thePlayerTarget = null;
							comm.clearCombatLog();
						}
					}
                		}
                		comm.printMessage( name + " was killed by " + name2 );
			}
			unlock();
		}
	}
	
	/**
	 * Informs this unit to merge its state with incoming state.  Called when a
	 * a new unit joins the session.
	 * @@param theState The state to merge with
	 */
	public synchronized void updateState( GameState theState, int partition ) 
	{
		if( myPartNum == partition ) 
		{
			attemptLock();
			
			// Straightforward - this simply calls merge on the state
			myState.merge( theState, myMap );
			unlock();
		}
	}

	/**
	 * Refreshes the player's timers
	 * @@param: Eoid The id of the player
	 * @@param: partNum The partion number
	 */
	public synchronized void refreshPlayer( Eoid playerId, int partNum ) 
	{
        	if( myPartNum == partNum ) 
		{
			attemptLock();
			PlayerCharacter thePlayer = checkId( playerId );
			if( thePlayer != null )
				myState.refreshPlayer( playerId );
			unlock();
		}
	}

    
	/**
	 * Moves the given player into the listed house
 	 * @@param pId the id of the player
	 * @@param houseId the id of the house
 	 */
	public synchronized void moveHouse( Eoid pId, Eoid houseId, boolean enter, int partNum ) 
	{
		if( myPartNum == partNum && !myPlayer.getId().equals( pId ) ) 
		{
			attemptLock();
			boolean inRoom = false;
			String which = null;
			PlayerCharacter thePlayer = checkId( pId );
			House theHouse = (House)myState.get( GameState.HOUSE, houseId );
			
			// Error detection, if the house is null, something is wrong
			if( theHouse == null )
				mySession.errorDetected( myPlayer.getId(), myPartNum );

			if( thePlayer != null && theHouse != null ) 
			{
				// Determine what to do: either move the player into, or out of,
				// the house and notify the local playrr of this
				checkLocation( thePlayer, theHouse.getLocation() );
				if( enter == false ) 
				{
					myMap.removePlayerFromHouse( pId, houseId );
                    			which = "leaves";
				}
				else 
				{
					myMap.movePlayerIntoHouse( pId, houseId );
					which = "enters";
				}
				XYloc houseLoc = theHouse.getLocation();
				if( myMap.checkLoc( houseLoc ) ) 
				{
					String pName = thePlayer.getName();
					String hName = theHouse.getOwnerName();
					comm.printMessage( pName + " " + which + " " + hName + "\'s house." );
				}
			}
			unlock();
		}
	}

	/**
	 * This function notifes this unit that caller has a state issue,
	 * and that this unit needs to schedule an emergency report in hopes
	 * that the state can be fixed
	 * @@param pId The id of the unit that called this
	 */
	public synchronized void errorDetected( Eoid pId, int partNum ) 
	{
		if( myPartNum == partNum ) 
		{
			attemptLock();
			// One of the aspects of M2MIMud is that there is no "one" state
			// that units can rely on when the realize their state is no longer
			// in sync with the global state. When an error is detected, the only
			// thing that can be done is to begin te process of state healing, which
			// takes into account a state.  Therefore, when this function is called,
			// the notion is that this unit has detected an error.  The error could come from
			// a unit which has been partitioned, or perhaps the unit itself was partitioned.
			// In any event, the only thing the unit can rely on is itself.  As a result,
			// this function causes all other session members to restart their report timers,
			// and causes this unit to schedule an emergency broadcast in an attempt
			// to fix the global state.
			if( myPlayer.getId().equals( pId ) )
				scheduleEmergencyReport();
			else
				scheduleNormalReport();
			unlock();
		}
	}

/********************************************************************************************************************************/
// These are the duel functions used when one player challenges another player.

	/**
	 * Informs this system that a challeneg to a duel has been issued
	 * @@param: pId The player if of the person who issued the duel
	 */
	public synchronized void requestDuel( Eoid pId, int partition ) 
	{
		if( myPartNum == partition ) 
		{
			attemptLock();
			PlayerCharacter challenger = checkId( pId );
			if( challenger != null ) 
			{
				// A player may only consider one duel at a time.  If someone has already challenged
				// this player to a duel, then any further challenges (until the player either accepts 
				// or declines the duel) is ignored.
				if( consideringDuel )
					challenger.getHandle().declineDuel( " is already considering another duel.",
					                                 myPlayer.getId(), myPartNum );
				else 
				{
					comm.printMessage( challenger.getName() + 
					                   " has challenged you to a duel!" );
					consideringDuel = true;
					currentChallenger = pId;
				}
			}
			else
				mySession.errorDetected( myPlayer.getId(), myPartNum );
			unlock();
		}
	}

	/**
	* Tells the player that the person has decline the duel
	* @@param reason The reason the player declined the duel
	* @@param pId The id of the person who declined the duel
	*/
	public synchronized void declineDuel( String reason, Eoid pId, int partition )
	{
		if( partition == myPartNum ) 
		{
			attemptLock();
			String pName = ((PlayerCharacter)myState.get( GameState.PLAYER, pId )).getName();
			comm.printMessage( pName + reason );
			consideringDuel = false;
			unlock();
		}
	}

	/**
	 * Informs the unit that duel challenge has been accepted.
	 * @@param pId The id of the player who accepted the duel.
	 */
	public synchronized void acceptDuel( Eoid pId, int partition ) 
	{
		if( partition == myPartNum ) 
		{
			attemptLock();
			PlayerCharacter thePlayer = (PlayerCharacter)myState.get( GameState.PLAYER, pId );
			comm.printMessage( thePlayer.getName() + " has accepted your challenge! Begin fighting!" );
			consideringDuel = false;
			thePlayerTarget = thePlayer;
			myPlayer.registerTarget( pId );
			comm.setTarget( thePlayer.getName() );
			unlock();
		}
	}

/********************************************************************************************************************************/
// These functions are the ones used to do the reporting of this game and any session it is a part of to to the world

	/**
	 * Receives a session report.  If this report constans the data for
	 * the session this unit is a part of, then the state it contains is checked with
	 * the game's current state to makes sure that it is consistent.
	 * Also, the timer is restarted to reduce network traffic.
	 * @@param theAd An ad for a game session.
	 */
	public synchronized void report( SessionAd theAd ) 
	{

		if(
		  ( mySession != null && mySession.equals( theAd.sessionHandle ) ) &&
		    theAd.sessionState.getPartNum() == myPartNum
		  ) 
		{
			attemptLock();
			
			// If the states are equal, simple schedule the next broadcast
			if( myState.equals( theAd.sessionState ) ||
			   myPlayer.getId().equals( theAd.sessionState.getPlayer().getId() ) )
				scheduleNormalReport();
			else 
			{
				// The states are not equal.  Run the synchronization
				// routine.
				comm.disable();
				boolean wasInCombat = myPlayer.isInCombat();
				myState.synchronize( theAd.sessionState, myMap );
				
				// If theplayer was in combat, but is no longer,
				// stop the fight and inform her of this
				if( wasInCombat && !myPlayer.isInCombat() ) 
				{
					comm.printMessage( "The gods have ended your fight." );
					theMobTarget = null;
					thePlayerTarget = null;
					comm.clearCombatLog();
				}
				currentChallenger = null;
				comm.enable();

				// Since things were changed, schedule an
				// emergency report to get out the changes asap.
				scheduleEmergencyReport();
			}
			unlock();
		}
	}

    
	/**
	 * This is the method called when the reportTimer go off.
	 * @@param theTimer The timer that went off
	 */
	protected synchronized void invokeReport( Timer theTimer ) 
	{
		if( theTimer.isTriggered() ) 
		{
			allGameUnits.report
				( new SessionAd( mySessionName, mySession,
				myState ) );
		}
	}
/********************************************************************************************************************************/
// Helper functions used to join and leave sessions

	/**
	 * The listener function for this game System, this is called when the user has
	 * selected a session (or hit the cancel button) on the game selection window.
	 * @@param: theAd The session ad which contains the information about the session the user selected.
	 */
	public void sessionSelected( SessionAd theAd ) 
	{
		comm.enable();
		
		// A value of null for the session ad indicates they hit the 'cancel' button
		if( theAd != null ) 
		{
			inSession = true;
			mySession = theAd.sessionHandle;
			mySessionName = theAd.sessionName;
			incomingState = theAd.sessionState;
			myMap.warp( 0, 0 );
			
			if( incomingState.getConfig() != null &&
			   !incomingState.getConfig().equals( myState.getConfig() ) )
			// recreate the world using this configuration
			myMap.createWorld( incomingState.getConfig() );
			else 
			{

				// This is rather special case.  This deals with situation when the
				// the user has a non default state, but is joininga session which is using
				// the default state.  What happens is the the syste, defaults to this case,
				// because the incoming state does not have a configuration.  This is case is
				// partially appropiate, because what the system will do it to load the default
				// state.
				if( incomingState.getConfig() == null && myState.getConfig() != null ) 
				{
					myMap = myMap.getWorld( "default" );
					myState = myMap.getState();
					myState.add( GameState.PLAYER, myPlayer );
					myState.setPCList( this );
					myState.setId( myPlayer.getId() );
				}
			}

			mySession.updateState( myState, myPartNum );
			myState.merge( incomingState, myMap );
			myState.updateListeners( this, this, myMap );

			myTimeManager.synchronize( theAd.sessionState.getTime() );
			myTimeManager.start();

			((Multihandle)mySession).attach( this );
			mySession.joinSession( myPlayer, myPartNum );
			myPlayerRefresher = new PlayerRefresher( myPlayer.getId(), mySession );
			myPlayerRefresher.start();

			myMap.setViewer( myMapWindow );
			comm.clear();
			comm.setStateName( stateName );
			myMap.setViewer( myMapWindow );
			comm.printMessage( "Joining session: " + theAd.sessionName );
			printCurrentRoom();

			sessionFinder.unexport();
			sessionFinder = null;
		}
	}

	/**
         * Leaves a session
         */
	private void leave()
	{
		// Leave the session, save all the data, and then quit out
		if( consideringDuel )
			cancelDuel( " has left the game. Challenge cancelled." );
		if( mySession != null )
			mySession.leaveSession( myPlayer.getId(), myPartNum );
		((Multihandle)mySession).detach( this );
		myPlayerRefresher.stop();
		myState.clear( GameState.PLAYER );
		myMap.clearSessionInfo();
		M2MI.unexport( this );
		myPlayer.save();
		myFriendsList.save();
		leftSession = true;
		inSession = false;
		myState.add( GameState.PLAYER, myPlayer );
	}
/********************************************************************************************************************************/
// These are the non Game interface functions

	/**
	* The function for the time listener interface.  Used to tell the session that time has changed.
	* @@param newTime The new time
	*/
	public void timeChanged( int newTime ) 
	{
		if( mySession != null )
			mySession.notifyTimePassage( newTime, myPartNum );
		else 
		{
			myMapWindow.updateTime( newTime );
			comm.printMessage( myTimeManager.getTimePassageString( newTime ) );
		}
	}

	/**
	* The function for the merchant listener, if the user is in the current
	* location it prints out the merchant's message
	* @@param: merchantType  The type of merchant
	* @@param: location The location the merchant is
	*/
	public synchronized void sendMessage( int merchantType, XYloc location ) 
	{
		attemptLock();
		
		// The check for null here is if a merchant times out
		// when the game is in the process of leaving the session
		if( mySession != null )
			mySession.merchantBroadcast( merchantType, location, myPartNum );
		unlock();
	}

	/**
	 * This informs the game unit that the mob is attacking the target
	 * @@param Eoid target The target the mob is attacking, since only the game unit which has
	 *        player cares about this, nothing happens if this is not the target
	 * @@param damage The base damage the mob has done
	 * @@param key The id of the mob which is fighting
	 */
	public synchronized void attackTarget(  int damage, String name ) 
	{
		doAttack( damage, name );
	}

	/**
	 * Tells the game system that the mob has respawned at the given location
	 * @@param  key The key of the mob that respawned
     	 * @@param loc The location the mob spawned at
	 */
	public synchronized void respawnMob( MobKey key ) 
	{
		attemptLock();
		if( mySession != null )
			mySession.notifyMobRespawn( key, myPartNum );
		unlock();
	}

	/**
	 * Informs ths unit to tell everyone that a mob is moving and need to update
	 * @@param theMove The object which contains the movement data
	 */
	public synchronized void moveMob( MobMove theMove ) 
	{
        	attemptLock();
		if( mySession != null && theMove != null )
			mySession.processMove( theMove, myPartNum );
		unlock();
	}


	/**
	 * This is called to indicate that a player has time out
	 * @@param playerId The id of the player who has timed out
	 */
	public synchronized void playerTimeout( Eoid playerId ) 
	{
		attemptLock();
		if( mySession != null ) 
		{
			PlayerCharacter thePlayer = checkId( playerId );
			mySession.notifyPlayerTimeout( playerId, myPartNum );
		}
		unlock();
	}

	/**
	 * Called when a mob attacks the player
	 * @@param damage The base damage of the mob
	 * @@param name The name of the mob that attacked
	 */
	private synchronized void doAttack( int damage, String name ) 
	{
		attemptLock();
		int bonus = myItemData.getCombatBonus( myPlayer.getGear( PlayerCharacter.BODY ) );
		// The amount of damage done is (damage - armor combar bonus)
		if( bonus != -1 )
			damage -= bonus;

		if( 0 > damage )
			damage = 0;

		Color[] theColors = { Color.red, Color.black, Color.blue };
		comm.printCombatMessage( "The " + name + " attacks you and hits for " + damage + " hit points!",
		theColors[round].darker(), true );
		myPlayer.adjustHP( -1*damage );
		comm.setActivePlayer( myPlayer );
		round++;
		if( round > 2 )
			round = 0;

		// If the player has been killed by the mob, several things happen.  The lose experience,
		// and they are warped back to location (0,0).  The mob stops fighting and is healed
		// back to full.  Then the entire session is notifed of the death which causes them
		// to remove their copy of the player from combat with the mob.
		if( !myPlayer.isAlive() ) 
		{
			theMobTarget.stopAttack();
			int exp = theMobTarget.getExp();
			myPlayer.incrementExp( -1 * exp );
			comm.printMessage( "You were just killed by the " + name );
			comm.printMessage( "You have lost " + exp + " exp points." );
			myMap.warp( 0, 0 );
			myPlayer.ressurect();
			comm.setActivePlayer( myPlayer );
			comm.clearCombatLog();
			printCurrentRoom();
			DeathData theInfo = new DeathData( myPlayer.getId(),
			theMobTarget.getKey() );
			mySession.notifyPlayerDeath( theInfo, myPartNum );
			theMobTarget = null;
		}
		unlock();
	}

	/**
	 * Informs the session that a monster has been killed.
	 * @@param loc The location where the mob was killed.
	 * @@param pId The id of the player who kill te mob
	 */
	 public synchronized void notifyMobDeath( DeathData theInfo, int partition ) 
	 {
		if( partition == myPartNum ) 
		{
			attemptLock();
			// For a mob's death, this method returns
			if( !myPlayer.getId().equals( theInfo.getKilled() ) ) 
			{
				String name = "Someone";
				Mob theMob = (Mob)myState.get( GameState.MOB, theInfo.getMob() );
				PlayerCharacter thePlayer = checkId( theInfo.getKilled() );
				
				// Lookup the character
				if( thePlayer != null ) 
				{
					name = thePlayer.getName();
					thePlayer.clearTargetData();
					checkLocation( thePlayer, theMob.getCurrentLocation() );
				}

				// If either the player of the mob was registered as
				// the target of the home character, some is wrong.
				// stop the fight, and request a state transmission
				if( ( thePlayer != null &&
				      thePlayer.getId().equals( myPlayer.getTarget() ) ) ||
				      theInfo.getMob().equals( myPlayer.getTarget() )) 
					endFightError();                    

				// Finally, kill the mob and report it
				theMob.kill();
				if( myMap.checkLoc( theMob.getCurrentLocation()))
					comm.printMessage( name + " kills the " + theMob.getName() );

			}
			 unlock();
		}        
	}

	/**
	 * Informs the player of how much damage he or she did to his or her target
	 * @@param damage The amount of damage done
	 */
	public synchronized void reportBackDamage( int damage, int partNum )
	{
		if( partNum == myPartNum ) 
		{
			attemptLock();
			comm.printCombatMessage( "You hit " + thePlayerTarget.getName() + " for " + damage + " damage!",
			Color.red.darker(), false );
			unlock();
		}
	}


	public synchronized void surrender( int partNum, Eoid pId ) 
	{
		if( partNum == myPartNum ) 
		{
			attemptLock();
			if( !myPlayer.getId().equals( pId ) ) 
			{
				if( pId.equals( myPlayer.getTarget() ) ) 
				{
					comm.printMessage( thePlayerTarget.getName() + " surrenders." );
					thePlayerTarget.clearTargetData();
					thePlayerTarget = null;
					myPlayer.clearTargetData();
					comm.clearCombatLog();
				}
				else 
				{
					PlayerCharacter p1 = checkId( pId );
					if( p1 != null ) 
					{
						if( !p1.hasMobTarget() ) 
						{
							Eoid p2Id = (Eoid)p1.getTarget();
							PlayerCharacter p2 = checkId( p2Id );
							p1.clearTargetData();
							if( p2 != null )
								p2.clearTargetData();
						}
					}
				}
			}
			unlock();
		}
	}

/********************************************************************************************************************************/
    // These are private functions designed to help the game system perform its tasks

	/**
	 * Prints the current room
	 */
	private synchronized void printCurrentRoom()
	{
		TextMessage desc = myMap.currentAreaDescription();
		if( myPlayer.isInHouse() )
			printHouse( desc );
		else
			printRoom( desc );
	}

	/**
	 * Prints out a room
	 * @@param roomDesc The TextMessage object that contains the description of the room
	 */
	private void printRoom( TextMessage roomDesc ) 
	{
		// Print out the message from the room
		comm.printTextMessage( roomDesc );

		// Print out the mobs that are fighting other players
		for( int i = 0; i < roomDesc.getNumAttackedMobs(); i++ )
		{
			Eoid pId = roomDesc.getPlayer( i );
			String pName = ((PlayerCharacter)myState.get( GameState.PLAYER, pId )).getName();
			String mName = roomDesc.getMobName( i );
			comm.printMessage( "You see " + pName + " attacking a " +
			                    mName + ".", Color.red.brighter() );
		}

		// Print out the players
		printPlayers();
	}

	/**
	 * Prints a house.
	 * @@param houseDesc The TextMessage object which contains the house's description
	 */
	private void printHouse( TextMessage houseDesc ) 
	{
		comm.printMessage( houseDesc.getMessage( 0 ) );
		comm.printMessage( houseDesc.getMessage( 1 ) );
		printPlayers();
	}

	/**
	 * Prints out the players in the current area
	 */
	private void printPlayers() 
	{
		if( myMap.currentAreaHasPlayers() ) 
		{

			Iterator playerIter = myMap.getCurrentAreaPlayers();
			StringBuffer playerName = new StringBuffer( "You see the following players: " );
			StringBuffer combatPlayers = new StringBuffer();
			boolean hasCombat = false;
			boolean hasNonCombat = false;
			while( playerIter.hasNext() ) 
			{
				Eoid temp = (Eoid)playerIter.next();
				PlayerCharacter thePlayer = checkId( temp );
				if( thePlayer != null && !myPlayer.getId().equals( temp ) ) 
				{
					// Simply print out the name if the player is not in comabt
					if( !thePlayer.isInCombat() ) 
					{
						playerName.append( thePlayer.getName() + " " );
						hasNonCombat = true;
					}
					else 
					{
						// If the player is fighting another player, inform them.
						// However, if the player is fighting as mob, there is no need,
						// since that has all ready been reported
						hasCombat = true;
						if( !thePlayer.hasMobTarget() ) 
						{
							Eoid pId = (Eoid)thePlayer.getTarget();
							if( !myPlayer.getId().equals( pId ) ) 
							{
								String pName = "someone";
								PlayerCharacter theTarget = checkId( pId );
								if( theTarget != null )
									pName = theTarget.getName();
								combatPlayers.append( thePlayer.getName() + 
								                      " is fighting " + pName + "\n" );
                            				}
                        			}
                        			else 
						{
							MobKey key = (MobKey)thePlayer.getTarget();
							String name = ((Mob)myState.get( GameState.MOB, key )).getName();
							combatPlayers.append( thePlayer.getName() + " is fighting a " + 
							                      name + "!" );
						}
					}
				}
			}

			if( hasNonCombat )
				comm.printMessage( playerName, Color.gray );

			if( hasCombat )
				comm.printMessage( combatPlayers, Color.blue.darker() );
		}
	}

    
	/**
	 * Prints the lookup vector
	 */
	private synchronized void printLookup()
	{
		if( lookupVector.size() == 0 )
			comm.printMessage( "There is no lookup data." );
		else 
		{
			StringBuffer desc = new StringBuffer( "Lookup listing:\n" );
			Iterator lookupIter = lookupVector.iterator();
			while( lookupIter.hasNext() ) 
			{
				Eoid tempId = (Eoid)lookupIter.next();
				int i = lookupVector.indexOf( tempId );
				PlayerCharacter thePlayer = checkId( tempId );
				if( thePlayer != null )
					desc.append( "(" + i + ") " + thePlayer + "\n" );
				if( lookupIter.hasNext() )
					desc.append( "\n" );

			}
			comm.printMessage( desc );
		}
	}

	/**
	 * Loads the item data from the items.dat file.
	 */
	private synchronized void loadItemData()
	throws Exception 
	{
		File itemFile = new File( "data/items.dat" );
		if( itemFile.exists() ) 
		{
			// The items.dat file contains an ItemData object already,
			// so all this function needs to do is open the file and
			// read the object in.
			FileInputStream itemStream = new FileInputStream( itemFile );
			ObjectInputStream objStream = new ObjectInputStream( itemStream );
			myItemData = (ItemData)objStream.readObject();
			objStream.close();
			itemStream.close();
		}
		else
			throw new Exception( "Item data not found." );
	}

    	/**
	 * This is a private function that is used to print out the equipment
	 * that the player is using in a given slot.
	 * @@param slot An integet code that refers to slot to look at
	 */
	private synchronized void printGear( int slot ) 
	{
		String id = myPlayer.getGear( slot );
		if( id != null ) 
		{
			String desc = myItemData.getDesc( id );
			String[] parts = { "body", "two hand", "right hand", "left hand" };
			comm.printMessage( parts[slot] + ": " + desc );
		}
	}

	/**
	 * Some of the commands require the user to enter in a name to perform. An
	 * example of this would be the send command.  However, there is no way 
	 * to ensure that users do not use duplicate names.  Thus, this function
	 * checks to see if there is more than one player with the same name in the session.
	 * If so, it prints an error message and returns a value of false, which indicated to the system
	 * that the command that the user entered can not be processed.
	 * @@param name The name of the player to check
	 */
	private boolean checkPlayerName( String name ) 
	{
		boolean retVal = false;
		int numPlayers = myState.getCount( name );
		if( numPlayers == 0 )
			comm.printError( name + " is not in this world." );
		else if( numPlayers > 1 )
		{
			comm.printError( "There are too many characters of that name.  If you want " +
		                         "to send a private message or add this player to your friends' listing, you " +
			 	          "must perform a lookup on that name and use the index of the lookup listing " +
					  "along with an l command (lsend, ladd) to perform that action."  );
		}
		else
			retVal = true;
		
		return retVal;
	}

	/**
	 * Sets the balance setting.  True is used to indicate that the user
	 * can move or perform an attack.
	 * @@patam balance If the user has regained their balance, this value is true.
	 */
	private synchronized void setBalance( boolean balance ) 
	{
		attemptLock();
		hasBalance = balance;
		comm.setStatus( true, hasBalance );
		unlock();
	}

	/**
	 * Sts the consideringDuel variable, which indicated
	 * if this user is consdiering a duel
	 * @@param status The value to set the variable to
	 */
	private synchronized void setConsideringDuel( boolean status ) 
	{
		consideringDuel = status;
	}

	/**
	 * While in combat, the user can only perform certain commands.
	 * This functions determines if the given command can be executed while in 
	 * combat
	 * @@param type The type of the command
	 */
	private synchronized boolean checkValidCombatCommand( int type ) 
	{
		boolean retVal = false;
		switch( type ) 
		{
			case Command.ATTACK:
			case Command.SAY:
			case Command.YELL:
			case Command.SEND:
			case Command.LOOK:
			case Command.CHECK_FRIENDS:
			case Command.ATTACK_NO_TARG:
			case Command.MOVE:
			case Command.LIST:
			case Command.CAST:
			case Command.CAST_NO_TARG:
			case Command.PARTITION:
			case Command.DISPLAY_PART:
			case Command.WHO:
			case Command.DO_REPORT_NOW:
			case Command.CLEAR_SCREEN:
			case Command.SURRENDER:
				retVal = true;
			break;
		}
		return retVal;
	}

	/**
	 *  Kills the player's mob target, prints out the rewards, and informs the session
	 */
	private synchronized void killMob()
	{
		String mobName = theMobTarget.getName();
		
		// The mob object carries the amount of gold and exp
		// they reward when then die. However, the only carry the itemId
		// of the item they drop (if any).
		int gold = theMobTarget.getGold();
		int exp = theMobTarget.getExp();
		String dropId = theMobTarget.getDrop();
		String desc = myItemData.getDesc( dropId );
		comm.printMessage( "You kill the " + mobName + "." );
		comm.printMessage( "You get " + gold + " gold pieces." );
		comm.printMessage( "You earn " + exp + " experience points." );
		
		// If the value of desc is null, this means that the mob does not drop an item
		if( desc != null ) 
		{
			comm.printMessage( "You get a " + desc );
			myPlayer.addItem( dropId, 1 );
		}

		// Reward the player
		myPlayer.incrementExp( exp );
		myPlayer.incrementGold( gold );
		myPlayer.clearTargetData();
		
		// Inform the session that the player has defeat the monster
		DeathData theInfo = new DeathData( myPlayer.getId(),
		theMobTarget.getKey() );
		comm.clearCombatLog();
		comm.setActivePlayer( myPlayer );
		if( mySession != null )
			mySession.notifyMobDeath( theInfo, myPartNum );
		theMobTarget = null;
	}

	/**
	 * This declines a duel challenge, and sends back the other player for the reason
	 * @@pram reason A string that contains the reason why the player declined the duel
	 */
	private synchronized void cancelDuel( String reason ) 
	{
		if( currentChallenger == null ) 
		{
			thePlayerTarget.getHandle().declineDuel( reason, myPlayer.getId(), myPartNum );
			comm.printMessage( "You leave the area and cancel your challenge." );
			setConsideringDuel( false );
			thePlayerTarget = null;
		}
		else 
		{
			PlayerCharacter thePlayer = (PlayerCharacter)myState.get( GameState.PLAYER, currentChallenger );
			thePlayer.getHandle().declineDuel( reason, thePlayer.getId(), myPartNum );
			comm.printMessage( "Duel challenge cancelled." );
			setConsideringDuel( false );
			currentChallenger = null;
		}
	}

	/**
	 * This checks to see if a directory with the given name exists.
	 * If it doesn't, it creates the directory.  If It does, this checks to see
	 * that file with that name is indeed a directory.
	 * @@param dirName The directory name to check.
	 */
	private synchronized void createDirectory( String dirName ) 
	{
		
		File theDirectory = new File( dirName );
		if( !theDirectory.exists() )
			theDirectory.mkdir();
		else
		{
			if( !theDirectory.isDirectory() )
			{
				System.err.println( "There is a file names \""+ dirName + "\" but it is not " +
				                    "a directory. Please move this file to anoter location." );
				System.exit( 1 );
			}
		}
	}				

	/**
 	 * Called whenever the player is changed.  This function first
	 * determines if there is already a world.  If so, it removes the player
	 * from the  player cache, adds the new player character and then sets the myPlayer
	 * variable.  If not, this loads up the default world.
	 * @@param theChar the new player character to use
	 */
	private synchronized void charChanged( PlayerCharacter theChar )
	throws Exception 
	{
		// If the world is null, load up the default world.
		// This is primarily for the situation in which the user
		// has just started the game and is creating a new character
		// or loading one.
		if( myMap == null ) 
		{
			myMap = World.getWorld( "default" );
			if( myMap == null ) 
			{
				myMap = new World( new GameState( myHandle, myTimeManager.getTime(),
					theChar.getId(), this ) );
				myMap.saveWorldData( "default" );
			}
			myState = myMap.getState();
			myState.setPCList( this );
			stateName = "default";
			comm.setStateName( stateName );
		}

		// Save the previous player data, if need be,
		if( myPlayer != null ) 
		{
			myPlayer.save();
			myState.remove( GameState.PLAYER, myPlayer.getId() );
			myPlayer = null;
		}

		// Clear out the player cache, then add the player.
		// Also, set up the state to use this player's id.
		// Finally set up the map viewer.
		myState.clear( GameState.PLAYER );
		myState.add( GameState.PLAYER, theChar );
		myPlayer = (PlayerCharacter)myState.get( GameState.PLAYER, theChar.getId() );
		myState.setId( myPlayer.getId() );
		myMap.setViewer( myMapWindow );

		// Attempt to load the friends' listing
		myFriendsList = FriendsList.loadFromFile();
		if( myFriendsList == null || !myFriendsList.getPlayerId().equals( myPlayer.getId() ) )
			myFriendsList = new FriendsList();

		myTimeManager.start();

		// All set!  print out the room and start things going
		comm.setActivePlayer( myPlayer );
		comm.clear();
		myMap.warp( 0, 0 );
		printCurrentRoom();
	}

	/**
	 * a player can only perform a slash or thrust attack if they have a 
	 * a weapon equipped.  However, they can perform a kick or punch
	 * regardless of what gear they have.  This function determines if the 
	 * player has the correct gear for the attack they want to perform.  
	 * It also returns the name of the weapon the player is using.
         * @@param atkType The type of attack to perform
         */
	private String checkAttack( int atkType ) 
	{
		String retVal = null;
        
		// A player can kick or punch without a weapon,
		// but to perform a slash or a thrust attack, they
		// must have something armed.
		if( atkType == StringIntCommand.KICK )
			retVal = new String( "kick" );
		else if( atkType == StringIntCommand.PUNCH )
			retVal = new String( "punch" );
		else 
		{
			retVal = myPlayer.getEquippedWeapon();
			if( retVal == null )
				comm.printError( "You cannot perform that attack without a weapon." );
		}
		return retVal;
	}

	/**
	 * This returns whether or not te player can use the spell indicated.
	 * To use a spell, the player must have the scroll in their inventory
	 * and must be of the right level and class type (i.e. fighters may not cast spells).
	 * @@param splId The id of the spell
	 */
	private boolean checkSpell( String id ) 
	{
		boolean retVal = false;
		int amount = myPlayer.getItemAmount( id );
		int level = myItemData.getSpellLevel( id );

		// A player can not cast a spell if they are a fighter,
		// not of the correct level, or have none in their
		// inventory
		if( !myItemData.canEquip( id, myPlayer.getPlayerClass() ) )
			comm.printError( "You cannot cast spells." );
		else if( level > 0 &&
		       ( amount > 0 && myPlayer.getLevel() >= level ) )
			retVal = true;
		else 
		{
			comm.printError( id + ": You can not cast that spell. " +
			"You either do not meet the level requirement or you do not have " +
			"a scroll of that spell in your inventory." );
		}
		return retVal;
	}

	/**
	 * Attacks the player's mob target.
	 * @@param damage the amount of base damage the player does to the mob.
	 */
	private void attackMob( int damage ) 
	{
		theMobTarget.damageMob( damage );
		String mobName = theMobTarget.getName();
		comm.printCombatMessage(
			"You attack the " + mobName + " for " + damage + " damage!",
			Color.yellow.darker(), false );
		if( !theMobTarget.isAlive() )
			killMob();
	}

	/**
	 * Attacks the player's player target
	 * @@param damage The amount of base damage done.
	 */
	private void attackPlayer( int damage ) 
	{
		thePlayerTarget.getHandle().printAttack( damage, myPartNum,
		myPlayer.getId() );
		comm.printCombatMessage( "You attack " + thePlayerTarget.getName() + "!",
		Color.blue.darker(), false );
	}

	/**
	 * When the player attacks with a weapon, there is a combat
	 * delay that prevents them from moving or attacking again. This
	 * function starts the timer that counts that delay.  When it goes off,
	 * the player regains their balance and can act again.
	 * @@param id The item id of the weapon that was used to perform the attack.
	 *           This is given because the delay varies from weapon to weapon.	 
	 */
	private void startBalanceTimer( String id ) 
	{
		hasBalance = false;
		comm.setStatus( true, hasBalance );
		long timer = myItemData.getWeaponDelay( id );
		attackTimer.start( timer );
	}

	/**
	 * Determins whether or not the player can perform an attack
	 * also, this will clear out duel data if the player
	 * has been challenged to a fight
	 * @@param nonTarget If this is true, this means that the player has issued
	 *                  a non target combat command ("slash" as opposed to "slash goblin")      
	 */
	private boolean canAttack( boolean nonTarget ) 
	{
		boolean retVal = true;

		// If the player is already fighting something, they must use
		// the non combat version of the command ('sl' as opposed to 'sl <target>'
		// Also, a player may not fight something if they have issued a duel
		// challenge.
		if( myPlayer.isInCombat() && !nonTarget ) 
		{
			retVal = false;
			comm.printError( "You are already in combat. " +
					 "Please use the non-target version of these commands." );
		}
		else if( consideringDuel && thePlayerTarget != null ) 
		{
			retVal = false;
			comm.printError( "You have issued a duel challenge and may not attack." );
		}		
		
		if( consideringDuel && currentChallenger != null ) 
		{
			//If the player has been issued a duel challenge, clear it
			PlayerCharacter temp =
				(PlayerCharacter)myState.get( GameState.PLAYER, currentChallenger );
			if( temp != null )
				temp.getHandle().declineDuel
				( " engages in combat.", myPlayer.getId(), myPartNum );
			consideringDuel = false;
			currentChallenger = null;
		}
		return retVal;
	}

	/**
	 * Starts a fight with the player's mob target.
	 * @@param dmgId The id of the weapon the player is using.  Passed for
	 *              damage and delay values.
	 */
	private void startFight( String dmgId ) 
	{
		if( theMobTarget != null ) 
		{
			// Get the timestamp, then register the two combatants
			Date ts = theMobTarget.startAttack( myPlayer.getId(), myPlayer.getLocation() );
			myPlayer.registerTarget( theMobTarget.getKey() );
			mySession.registerAttacker
			( myPlayer.getLocation(), theMobTarget.getKey(),
			myPlayer.getId(), ts, myPartNum );

			// Deduct from the monster the amount of damage the player did.
			int damage = myItemData.getCombatBonus( dmgId );
			attackMob( damage );
			startBalanceTimer( dmgId );
			comm.setTarget( theMobTarget.getName() );
		}
	}

    
	/**
	 * This helper function is used whenever a command comes in to perform
	 * something that another player does.  Basically,
	 * it checks to see if the other player is in the state.  If so,
	 * is returns it, if not, it informs the session that an error has been detected
	 * and reports back null
	 * @@param pId The id of the player to check
	 */
	private PlayerCharacter checkId( Eoid pId ) 
	{
		PlayerCharacter retVal = null;
		if( myState.has( GameState.PLAYER, pId ) )
			retVal = (PlayerCharacter)myState.get( GameState.PLAYER, pId );
		else
			mySession.errorDetected( myPlayer.getId(), myPartNum );
		return retVal;
	}

	/**
	 * When the unit detects that something is amiss with the player's
	 * combat (i.e. whatever they are fighting is suddenly killed by 
	 * someone else) this function stops the player's fight and informs the 	 
	 */
    	private void endFightError() 
	{
		myPlayer.clearTargetData();
		thePlayerTarget = null;
		theMobTarget = null;
		comm.clearCombatLog();
		comm.printError( "Your fight has been ended due to a " +
				 "synchronization error." );
        	mySession.errorDetected(  myPlayer.getId(), myPartNum );
	}

	/**
	 * This functions determines if the given player is at the locations
	 * specified.  If not, it moves them there.
	 * @@param thePlayer The player to check
	 * @@param theLoc The location they should be at
     	 */
	private void checkLocation( PlayerCharacter thePlayer, XYloc theLoc ) 
	{
		if( !thePlayer.getLocation().equals( theLoc ) && theLoc != null )
			myMap.performWarp( thePlayer.getId(), theLoc );
	}
/********************************************************************************************************************************/
    
	/**
	 * Given a Command object, this function performs the steps needed
	 * to execute that command.
	 * @@param command The command object that represents the command to execute
	 */
	public synchronized void execute( Command command )
	throws Exception 
	{
		/* 
		 * It sounds so simple.  Given a command, perform the appropiate actions
		 * and then wait for the next command.  However, this function is large.
		 * Very large. 
		 */
		attemptLock();
		// If there is no player, a user may only execute a create or load player command
        	if( myPlayer == null &&
		  ( command.getType() != Command.CREATE &&
	            command.getType() != Command.LOAD  &&
	            command.getType() != Command.INVALID_COMMAND )
	          ) 
		{		  
			comm.printError( "Cannot execute other commands without having a character." +
                             " Please load a character or create a new one." );
		}
		// users can only perform certain commands while in combat
		else if( ( myPlayer != null && myPlayer.isInCombat() )
		       && !checkValidCombatCommand( command.getType() ) ) 
		{
		       comm.printError( "You are in combat and may not perform that command!" );
		}
		else 
		{
			switch( command.getType() ) 
			{
				case Command.CREATE: 
				{
					if( inSession )
						comm.printError( "You are already in a session." );
					else 
					{
						// Character creation
						PlayerCharacter temp = 
						   PlayerCharacter.loadCharacterDataFromFile
						  ( mySession, ((PlayerCreationCommand)command).name );
						if( temp != null ) 
						{
							// If a character already exists with the given name,
							// the user may not reuse that name
							comm.printError( "That character already exists." +
							"Please delete the character or create one " +
							"with a different name");
						}
						else 
						{

							// Create the new character, and then place them into the
							// default world
							temp = PlayerCharacter.createNewCharacter(
							(PlayerCreationCommand)command, myHandle );
							if( temp != null )
								charChanged( temp );
							else 
							{
								String className = ((PlayerCreationCommand)command).clas;
								comm.printError( className + ": invalid player class." );
							}
						}
					}

				}
				break;
				case Command.LOOK: 
				{
					printCurrentRoom();
				}
				break;
				case Command.LIST:
				{
					comm.printMessage( myPlayer );
				}
				break;
				case Command.MOVE: 
				{
					// You can't move if you are in combat with another player, in a house,
					// or have just taken an action
					if( !hasBalance )
						comm.printError( "You are regaining your balance and may not move yet." );
					else if( myPlayer.isInHouse() )
						comm.printError( "You are in a house and cannot move in any direction.  You must "+
							"leave the house first." );
					else if( myPlayer.isInCombat() && theMobTarget == null )
						comm.printError( "You are engaged in combat with another player and can not leave " +
								"the area until combat is done." );
					else 
					{
						// Otherwise, if the player is in combat with a mob and the move,
						// they are running from the mob
						if( myPlayer.isInCombat() && thePlayerTarget == null ) 
						{
							Mob theMob = (Mob)myState.get( GameState.MOB,
							(MobKey)myPlayer.getTarget() );
							theMob.stopAttack( );
							myPlayer.clearTargetData();
							comm.clearCombatLog();
							comm.printMessage( "You disengage combat with " + theMob.getName() + "!" );
						}
						// Have the map create the move data
						UserMove movement = myMap.doPlayerMove( ((IntCommand)command).getIntData() );
						if( movement != null ) 
						{
							myPlayer.updateLocation( movement.getLoc( MoveData.TO ) );
							// Prints out the room, finish filling in the data
							printCurrentRoom();
							movement.setUser( myPlayer.getId() );

							// If the user is considering a duel, cancel it
							if( consideringDuel )
								cancelDuel( " has left the area. Challenge Cancelled." );
							// Finally inform everyone of the move
							if( mySession != null ) 
								mySession.processMove( movement, myPartNum );

						}
						else
							comm.printError( "You can not move in that direction." );
					}
				}
				break;
				case Command.YELL: 
				{
					comm.printMessage( "You yell, \"" + ((StringCommand)command).getStringData() + "\"" );
					SayData sd = new SayData( myPlayer.getId(), myPlayer.getLocation(),
						((StringCommand)command).getStringData()  );
					if( mySession != null )
						mySession.yell( sd, myPartNum );
				}
				break;
				case Command.CREATE_GAME: 
				{
					if( inSession )
						comm.printError( "You are already in a session." );
					else if( leftSession )
						comm.printError( "You have left your session or have been removed.  Please " +
							"exit out of the game before trying to create a new one." );
					else 
					{
						// Set up the Session handle, create the merchants and
						// the mobs, start the player refreshers
						inSession = true;
						mySessionName = ((StringCommand)command).getStringData();
						mySession = (Game)M2MI.getMultihandle( Game.class );
						((Multihandle)mySession).attach( this );
						myMap.spawnMerchants( this );
						myMap.spawnMobs( this );
						scheduleNormalReport();
						myPlayerRefresher = new PlayerRefresher( myPlayer.getId(), mySession );
						myPlayerRefresher.start();
						comm.printMessage( "\nGame " + mySessionName + " created!" );
					}
				}
				break;
				case Command.FIND_GAMES: 
				{
					// Can't look for a new game if the user is one already.
					// Also, after leaving a game, they must quit out of the program first.
					if( inSession )
						comm.printError( "You must first leave your current " +
						"session before joining a new one." );
					else if( leftSession )
						comm.printError( "You have left your session, or have been removed.  Please" +
						"quit the game before trying to find a new one." );
					else 
					{
						comm.printMessage( "Looking for games" );
						comm.disable();
						GameChooser gameChooser = new GameChooser();
						sessionFinder = new SessionFinder( gameChooser );
						sessionFinder.export();
						GameChooserWindow gameChooserWindow = new GameChooserWindow( gameChooser, this );
						gameChooserWindow.setVisible( true );
					}
				}
				break;
				case Command.LEAVE_SESSION: 
				{
					if( !inSession )
						comm.printError( "You are not currently in a session." );
					else 
					{
						comm.printMessage( "You leave your session." );
						leave();
					}
				}
				break;
				case Command.WHO: 
				{
					comm.printMessage( "\nPlayer currently in the session: " );
					comm.printMessage( myState.getPlayerCacheString() );
				}
				break;
				case Command.SAY: 
				{
					comm.printMessage( "You say, \"" + ((StringCommand)command).getStringData() + "\"" );
					if( mySession != null ) 
					{
						SayData myMessage = new SayData( myPlayer.getId(), myPlayer.getLocation(),
							((StringCommand)command).getStringData() );
						mySession.say( myMessage, myPartNum );
					}
				}
				break;
				case Command.DIG_POND: 
				{
					if( myMap.getCurrentRoomType() == Room.WATER )
						comm.printError( "You can not dig a pond where there is water!" );
					else if( myMap.digPond() == false )
						comm.printError( "There is already a pond here." );
					else 
					{
						comm.printMessage( "You dig a small pond in the earth." );
						if( mySession != null )
							mySession.setPond( myPlayer.getLocation(), 
							myPlayer.getId(), myPartNum );
					}
				}
				break;
				case Command.HOUSE_CREATE: 
				{
					if( !myState.has( GameState.HOUSE, myPlayer.getId() ) ) 
					{
						if( myMap.getCurrentRoomType() != Room.WATER ) 
						{
							House newHouse = new House( myPlayer,
								        (HouseCreationCommand)command );
							myMap.placeHouse( newHouse );
							comm.printMessage( "You place your house at " + newHouse.getLocation() );
							if( mySession != null )
								mySession.addHouse( newHouse, myPartNum );
						}
						else
							comm.printError( "You may not build a house on water!" );
					}
					else 
					{
						House temp = (House)myState.get( GameState.HOUSE, myPlayer.getId() );
						comm.printError( "You already have a house at " + temp.getLocation() );
					}
				}
				break;
				case Command.TIME: 
				{
					String times[] = { "early morning", "morning", "early afternoon",
					"late afternoon", "early evening", "evening" };
					String timeMessage = new String( "It is " + times[myTimeManager.getTime()] + "." );
					comm.printMessage( timeMessage );
				}
				break;
				case Command.GOTO: 
				{
					// The coordinates the player gives must be withing the bounds of the map.
					int x = ((GotoCommand)command).getLoc().x;
					int y = ((GotoCommand)command).getLoc().y;
					if( ( 0 <= x && x < myMap.getMaxX() ) &&
					    ( 0 <= y && y < myMap.getMaxY() ) ) 
					{
						// Don't warp if the player is staying in the same location
						if( !myPlayer.getLocation().equals( new XYloc( x, y ) ) ) 
						{
							XYloc temp = new XYloc( myPlayer.getLocation() );
							comm.printMessage( "Warping you to location (" + x + ", " + y + ")" );
							myMap.warp( x, y );
							printCurrentRoom();
							if( mySession != null )
								mySession.warp( myPlayer.getId(), temp,
							myPlayer.getLocation(), myPartNum );
						}
					}
					else
						comm.printError( "You cannot warp to that location." );
				}
				break;
				case Command.LIST_WARES: 
				{
					// This is simple: get the merchant type, then use the ItemData
					// object to get the list of all the items that merchant sells.
					int type = myMap.getMerchantType();
					if( type != -1 ) 
					{
						comm.printMessage( "\nThe merchant has the following items for sale: " );
						Iterator itemId = myItemData.getIdVector( type ).iterator();
						while( itemId.hasNext() ) 
						{
							String id = (String)itemId.next();
							String desc = myItemData.getDesc( id );
							int cost = myItemData.lookupCost( id );
							if( cost > 0 )
								comm.printMessage( id + ": " + desc + ", cost " + cost + "gold pieces" );
						}
					}
					else
						comm.printError( "There is no merchant here." );
				}
				break;
				case Command.BUY: 
				{
					int type = myMap.getMerchantType();
					if( type != -1 ) 
					{
						String id = ((StringIntCommand)command).getStringData();
						int amount = ((StringIntCommand)command).getIntData();
						Vector merchItems = myItemData.getIdVector( type );
                        
						// Obviously, in order to buy something, them merchant must
						// have the item in stock, and the user must be able to afford
						// the quantity they have specifed.
						if( merchItems.indexOf( id ) != -1 ) 
						{
							int totalCost = amount * myItemData.lookupCost( id );
							if( myPlayer.canAfford( totalCost ) ) 
							{
								// Adjust the user's inventory and gold
								myPlayer.addItem( id, amount );
								myPlayer.decrementGold( totalCost );
								String desc = myItemData.getDesc( id );
								comm.printMessage
								( "You buy the " + desc + " for " + totalCost +
								" gold pieces." );
								comm.setActivePlayer( myPlayer );
							}
							else
								comm.printMessage( "You can't afford that!" );
						}
						else
							comm.printMessage( "That item is not for sale." );
					}
					else
						comm.printError( "There is no merchant here." );
				}
				break;
				case Command.SELL: 
				{
						int type = myMap.getMerchantType();
					if( type != -1 ) 
					{
						String id = ((StringIntCommand)command).getStringData();
						int amount = ((StringIntCommand)command).getIntData();
						int sellAmount = myPlayer.getItemAmount( id );
        	               
						// To be able to sell something, the user must
						// have at least one in their inventory.
						if( sellAmount > 0 ) 
						{
							int finalAmount = 0;
							
							// the user can only sell what they have.  
							// So if they indicate that they want to 
							// sell 4 potions, but they only have 3
							// they will onluy get the gold for 3
							if( amount > sellAmount )
								finalAmount = sellAmount;
							else
								finalAmount = amount;
						
							// Again, adjust the user's inventory and gold space
							myPlayer.addItem( id, -1 * finalAmount );
							int amountEarned = finalAmount * myItemData.lookupSellValue( id );
							myPlayer.incrementGold( amountEarned );
							comm.printMessage( "You sell " + finalAmount + " of " +
							myItemData.getDesc( id ) + " for " + amountEarned +
							" goldPieces." );
							comm.setActivePlayer( myPlayer );
						}
						else
							comm.printMessage( "You do not have any of that item." );
					}
					else
						comm.printMessage( "There is no merchant here." );
				}
				break;
				case Command.LOOKUP: 
				{
					// The lookup gets all the players that have the given name and places
					// them into a list with their player ID
					String pName = ((StringCommand)command).getStringData();
					comm.printMessage( "Performing lookup for " + pName );
					lookupVector.clear();
					myState.doLookup( pName, lookupVector );
					printLookup();
				}
				break;
				case Command.ADD: 
				{
					// Adds a player to the friends' list
					String pName = ((StringCommand)command).getStringData();
					if( checkPlayerName( pName ) ) 
					{
						myFriendsList.addPlayer( myState.getPlayerByName( pName ) );
						comm.printMessage( pName + " has been added to your friends\' "
						+ " listing." );
					}
				}
				break;
				case Command.SEND: 
				{
					String pName = ((SendCommand)command).getUserName();
					if( checkPlayerName( pName ) ) 
					{
						Game theHandle = myState.getPlayerByName( pName ).getHandle();
						theHandle.sendPM( myPlayer.getId(), ((SendCommand)command).getStringData(), myPartNum );
						comm.printMessage( "You send, \"" + ((SendCommand)command).getStringData() +
						"\" to " + pName + "." 	);
					}
				}
				break;
				case Command.INVENTORY: 
				{
					// Print out the user's inventory and gold
					comm.printMessage( "\nYou have the following items in your inventory: " );
					comm.printMessage( myPlayer.getCurrentGold() + " gold pieces." );
					Iterator items = myPlayer.getInventoryKeys();
					while( items.hasNext() ) 
					{
						String id = (String)items.next();
						int amount = myPlayer.getItemAmount( id );
						String desc = myItemData.getDesc( id );
						if( amount > 0 )
							comm.printMessage( id + ": " + desc +  ", number: " + amount );
					}
					
					// Print out the user's equipment
					comm.printMessage( "\nYou are equiped in the follow gear: " );
					printGear( PlayerCharacter.BODY );
					printGear( PlayerCharacter.RIGHT_HAND );
					printGear( PlayerCharacter.LEFT_HAND );
					printGear( PlayerCharacter.TWO_HAND );
				}
				break;
				case Command.CHECK_FRIENDS: 
				{
					// This simply prints out whether or not a player on the user's
					// friends' listing is in the same sessin as she is.
					if( myFriendsList.size() == 0 )
						comm.printMessage( "There are no players on your friends listing." );
					else 
					{
						Iterator friends = myFriendsList.getPlayers();
						int i = 0;
						while( friends.hasNext() ) 
						{
							Eoid tempKey = (Eoid)friends.next();
							String name = myFriendsList.getName( tempKey );
							if( myState.has( GameState.PLAYER, tempKey )  )
								comm.printMessage(
								"(" + i + ") " + name + " (" + tempKey + ") " +
								" is in this session." );
							else
								comm.printMessage(
								"(" + i + ") " + name + " (" + tempKey + ") " +
								" is not in this session." );
							i++;
						}
					}
				}
				break;	
				case Command.LCHECK: 
				{
					// This allows a player to see if a player on the lookup listing
					// is in their friends' listing.
					IntCommand iComm = (IntCommand)command;
					Eoid playerId = null;
					if( lookupVector.size() > iComm.getIntData() )
						playerId = (Eoid)lookupVector.elementAt( iComm.getIntData() );
					
					PlayerCharacter thePlayer = checkId( playerId );
					if( myFriendsList.hasPlayer( playerId ) ) 
					{
						comm.printMessage( thePlayer.getName() + " (" +
						playerId + ") is in your friends' listing." );
					}
					else 
					{
						comm.printMessage( thePlayer.getName() + " (" +
						playerId + ") is not in your friends' listing." );
					}
				}
				break;
				case Command.LSEND: 
				{
					// A send command, but this sends the message to the user
					// with associated with the given index in the lookup listing, rather than
					// the give name.
					if( lookupVector.size() <= 0 )
						comm.printError( "There is no lookup data.  Please perform a lookup." );
					else 
					{
						SendCommand sComm = (SendCommand)command;
						Eoid playerId = null;
						if( lookupVector.size() > sComm.getLookupIndex() ) 
						{
							playerId = (Eoid)lookupVector.elementAt( sComm.getLookupIndex() );
							PlayerCharacter sendPlayer =
								(PlayerCharacter)myState.get( GameState.PLAYER, playerId );
							if( sendPlayer != null ) 
							{
								Game sendHandle = sendPlayer.getHandle();
								sendHandle.sendPM( myPlayer.getId(),
								sComm.getStringData(), myPartNum );
								comm.printMessage
								( "You send, \"" + sComm.getStringData() + "\" to " +
								sendPlayer.getName() );
							}
						}
						else
							comm.printError( "That index is invalid." );
							}
				}
				break;
				case Command.LADD: 
				{
                    	
					// Adds the user at the specified position in the lookup listing
					// to the user's friends' listing.
					if( lookupVector.size() <= 0 )
						comm.printError( "There is no lookup data.  Please perform a lookup." );
					else 
					{
						IntCommand iComm = (IntCommand)command;
						Eoid playerId = null;
						if( lookupVector.size() > iComm.getIntData() ) 
						{
							playerId = (Eoid)lookupVector.elementAt( iComm.getIntData() );
							PlayerCharacter temp = (PlayerCharacter)myState.get( GameState.PLAYER, playerId );
							if( temp != null ) 
							{
								myFriendsList.addPlayer( temp );
								comm.printMessage
								( temp.getName() + " has been added from your friends' listing." );
							}
						}
						else
							comm.printError( "That index is invalid." );
					}
				}
				break;
				case Command.LLIST: 
				{
					printLookup();
				}                
				break;
				case Command.REMOVE: 
				{
					// Removes the player from the friends' listing.
					String name = myFriendsList.removePlayer( ((IntCommand)command).getIntData() );
					if( name != null )
						comm.printMessage( name + "  has been removed from your friends' listing." );
					else
						comm.printError( "That index is not valid." );
				}
				break;
				case Command.EQUIP: 
				{
					StringCommand eComm = (StringCommand)command;
					String id = eComm.getStringData();
					int slot = -1;
	
					// First check to make sure the player has the given item
					if( myPlayer.getItemAmount( id ) <= 0 )
						comm.printError( "You do not have that item." );
					else if( !myItemData.canEquip( id, myPlayer.getPlayerClass() ) )
					//Then check to make sure they can equip it
						comm.printError( "Your class may not equip this item." );
					else 
					{
						// Determine which slot (if any) the given item
						// gets equipped to
						switch( myItemData.getItemType( id ) ) 
						{
							case ItemData.ARMOR:
								slot = PlayerCharacter.BODY;
							break;
							case ItemData.WEAPON_2_HAND:
								slot = PlayerCharacter.TWO_HAND;
							break;
							case ItemData.WEAPON_1_HAND:
								slot = PlayerCharacter.RIGHT_HAND;
							break;
						}
						if( slot == -1 )
							comm.printError( "You can't equip that item!" );
						else 
						{
							// Equip the item and tell the user
							myPlayer.equipItem( id, slot );
							String desc = myItemData.getDesc( id );
							if( slot == PlayerCharacter.BODY )
								comm.printMessage( "You put on " + desc );
							else
								comm.printMessage( "You begin wearing " + desc );
						}
					}
				}	
				break;
				case Command.ATTACK: 
				{
					int type = ((StringIntCommand)command).getIntData();
					String weapon = checkAttack( type );
	
					// So far, everything is good.  Begin combat on the monster
					if( canAttack( false ) && weapon != null ) 
					{
						// Ensure the mob is valid (exists and is not fighting already
						String mobName = ((StringIntCommand)command).getStringData();
						theMobTarget = myMap.getFreeMob( mobName );
						if( theMobTarget == null )
							comm.printError( "Either that mob does not exists, or all members of that species " +
							"are already in combat in this area." );
						else
	                            			startFight( weapon );
					}
					else
						comm.printError( "You may not perform that attack without a weapon." );	
				}
				break;
				case Command.ATTACK_NO_TARG: 
				{
                	    
					int type = ((IntCommand)command).getIntData();
					String weapon = checkAttack( type );
					if( weapon != null ) 
					{
						int damage = myItemData.getCombatBonus( weapon );
						if( hasBalance ) 
						{
							if( thePlayerTarget == null && theMobTarget == null )
								comm.printMessage( "You visciously attack the air around you!" );
							else if( myPlayer.hasMobTarget() )
								attackMob( damage );
							else
								attackPlayer( damage );
							startBalanceTimer( weapon );
						}
						else
							comm.printCombatMessage( "You are regaining your balance after the last" +
							" attack!", Color.yellow.darker(),false );
					}
				}
				break;
				case Command.CHALLENGE: 
				{
					boolean canAttack = true;
                 	
					// If the player is in a house they may not challenge someone, also
					// a player may only have challenge issed at on time.
					if( myPlayer.isInHouse() ) 
					{
						comm.printError( "You may not challenge while in a house." );
						canAttack = false;
					}	
					if( consideringDuel ) 
					{
						comm.printError( "You have already issued one challenge." );
						canAttack = false;
				}

					if( !myMap.currentAreaHasPlayers() ) 
					{
						comm.printError( "There are no players in this room." );
						canAttack = false;
					}

					if( canAttack ) 
					{
	
						// What this does is perform a lookup on all users of the given name
						// in the same room as the player. If there are more than one, the user
						// and her target must move to another room to fight each other.
						String pName = ((StringCommand)command).getStringData();
						Iterator players = myMap.getCurrentAreaPlayers();
						int count = 0;
						Vector ids = new Vector();
						while( players.hasNext() ) 
						{
							Eoid pId = (Eoid)players.next();
							if( pName.equals( ((PlayerCharacter)myState.get( GameState.PLAYER, pId )).getName() ) )
								ids.add( pId );
						}
						if( ids.size() == 0 ) 					
							comm.printError( "There are no players of that name here." );                        
						else if( ids.size() > 1 ) 
							comm.printError( "There are too many players here of that name." +
							"You and the player you wish to fight must move to a new location." );                        
						else 
						{
							Eoid pId = (Eoid)ids.elementAt( 0 );
							thePlayerTarget = (PlayerCharacter)myState.get( GameState.PLAYER, pId );
	
							// If the other player is already fighting or is in ahouse
							// the user may not challenge them.
							if( thePlayerTarget.isInCombat() )
							{
								comm.printMessage( "That player is in combat already." );
								thePlayerTarget = null;
							}
							else if( thePlayerTarget.isInHouse() ) 
							{
								comm.printMessage( "You may not challenge someone while " +
								"(s)he is in a house." );
							}
							else 
							{
								Game theGame = thePlayerTarget.getHandle();
								theGame.requestDuel( myPlayer.getId(), myPartNum );
								comm.printMessage( "You challenge " + thePlayerTarget.getName() +
								" to a duel!" );
								setConsideringDuel( true );
							}
						}
					}
				}
				break;
				case Command.DECLINE: 
				{
					// This declines another player's duel challenge.
					if( !consideringDuel )
						comm.printError( "You are not considering a duel." );
					else if( consideringDuel && currentChallenger == null )
						comm.printError( "You have issued a challenge, command ignored." );
					else 
					{
						String pName = ((PlayerCharacter)myState.get( GameState.PLAYER, currentChallenger )).getName();
						Game theHandle =((PlayerCharacter)myState.get( GameState.PLAYER, currentChallenger )).getHandle();
						comm.printMessage( "You have declined " + pName + "\'s challenge." );
						theHandle.declineDuel( " has declined your challenge.", myPlayer.getId(),
						myPartNum );
						setConsideringDuel( false );
						currentChallenger = null;
					}
				}
				break;
				case Command.ACCEPT: 
				{
					// This accepts the player's duel challenge and places the local player into
					// combat.
					if( !consideringDuel )
						comm.printError( "You are not considering a duel." );
					else if( consideringDuel && currentChallenger == null )
						comm.printError( "You have issued a duel challenge.  Command ignored." );
					else 	
					{
						PlayerCharacter theChallenger = checkId( currentChallenger );
						String pName = theChallenger.getName();
						Game theHandle = theChallenger.getHandle();
						theHandle.acceptDuel( myPlayer.getId(), myPartNum );
						thePlayerTarget = theChallenger;
						myPlayer.registerTarget( currentChallenger );
						currentChallenger = null;
						mySession.notifyFight( thePlayerTarget.getId(), myPlayer.getId(),
						myPlayer.getLocation(), myPartNum );
						setConsideringDuel( false );
						comm.printMessage( "You have accepted " + pName + "\'s challenge. Begin fighting!" );
						comm.setTarget( thePlayerTarget.getName() );
					}
				}
				break;
				case Command.MAP: 
				{
					myMapWindow.setVisible( !myMapWindow.isVisible() );
				}
				break;	
				case Command.LOAD: 
				{
					if( inSession )
						comm.printError( "You are in a session and may not change any data." );
					else 	
					{
						StringIntCommand siComm = (StringIntCommand)command;
						switch( siComm.getIntData() ) 
						{
							case StringIntCommand.PLAYER: 
							{
								String pName = siComm.getStringData();
								PlayerCharacter loadPlay =
									PlayerCharacter.loadCharacterDataFromFile
									( myHandle, pName );
								if( loadPlay == null )
									comm.printError( "Player " + pName + " not found." );
								else 
								{
									PlayerCharacter temp =  
										PlayerCharacter.createNewCharacter( loadPlay, myHandle );
									charChanged( temp );
								}
							}
							break;
							case StringIntCommand.MAP: 
							{
								String fileName = new String
								( "maps/" + siComm.getStringData() + ".map" );
								File theFile = new File( fileName );							
								if( myPlayer == null )
									comm.printError( "You may not execute this command now." );
								else if( !theFile.exists() )
									comm.printError( fileName + ": map file not found." );
								else 
								{
									// This clears out the state, and then recreates
									// the world using the configuration found in the
									// file.  If then sets up the world to use the player
									myState.clear();
									WorldConfiguration theConfig = new
										WorldConfiguration( theFile );
									myMap.createWorld( theConfig );
									comm.clear();
									stateName = new String( "(No state name.)");
									comm.setStateName( stateName );
									myMap.warp( 0, 0 );
									printCurrentRoom();
									myState.add( GameState.PLAYER, myPlayer );
									myPlayer = (PlayerCharacter)myState.get( GameState.PLAYER,
									myPlayer.getId() );
								}

							}																				
	                            			break;
							case StringIntCommand.WORLD: 
							{
								if( myPlayer == null )
									comm.printError( "You may not execute this command now." );
								else 
								{
									stateName = siComm.getStringData();
									World temp = World.getWorld( stateName );
									if( temp == null )
										comm.printError( "State not found." );
									else 
									{
										// A few things to note.  A world
										// that is loaded from a file contains
										// a map and a state, so there is really
										// no need to do anything special. Simply
										// overwrite the existing world with the one
										// from the file, and then get the state information
										// from the new world.
										myMap = temp;
										myState = myMap.getState();
										myState.add( GameState.PLAYER, myPlayer );
										myState.setPCList( this );
										myState.setId( myPlayer.getId() );
	
										myMap.setViewer( myMapWindow );
										comm.clear();
										comm.setStateName( stateName );
											myMap.warp( 0, 0 );
										myMap.setViewer( myMapWindow );
										printCurrentRoom();
	
										myPlayer = (PlayerCharacter)myState.get( GameState.PLAYER,
										myPlayer.getId() );
									}
								}
							}
							break;
						}
					}
				}
				break;
				case Command.SAVE: 
				{
					StringIntCommand siComm = (StringIntCommand)command;
					switch( siComm.getIntData() ) 
					{
						case StringIntCommand.WORLD: 
						{
							if( inSession )
								comm.printError( "You must leave the session before saving the state " +
								"data." );
							else 
							{
								String fileName = "states/" + siComm.getStringData() + ".dat";
								File theFile = new File( fileName );
								if( theFile.exists() )
									comm.printError( fileName + ": file already exists." );
								else 
								{
									stateName = siComm.getStringData();
									comm.setStateName( stateName );
									myMap.saveWorldData( stateName );
									comm.printMessage( "Session saved!");
								}
							}
						}
						break;
						case StringIntCommand.MAP: 
						{
							String fileName = "maps/" + siComm.getStringData() + ".map";
							File theFile = new File( fileName );
							if( theFile.exists() )
								comm.printError( fileName + ": file already exists." );
							else 
							{			
								if( myState.getConfig() != null ) 
								{
									FileWriter fw = new FileWriter( theFile );
									BufferedWriter writer = new BufferedWriter( fw );
									String data =  myState.getConfig().toString();
									writer.write( data, 0, data.length() );
									writer.close();
									fw.close();
									comm.printMessage( "Map saved! ");
								}
							}
						}
					}
				}					  
				break;
				case Command.SAVE_QUICK: 
				{
					if( inSession )
						comm.printError( "You must leave the session before saving." );
					else 
					{
						if( stateName == null )
							comm.printError( "You must first specify a state name using the " +
							"\"save world <state-name>\" command." );
						else
							myMap.saveWorldData( stateName );
					}
					comm.printMessage( "Session saved!" );
				}	
				break;
				case Command.STATE_REMOVE: 
				{
					// This removes either a house or a pond from the game state.
					if( !inSession )
						myMap.remove( ((IntCommand)command).getIntData() );
					else	
						comm.printError( "You are in a session and can not remove that object." );
				}
				break;
				case Command.USE: 
				{
					String id = ((StringCommand)command).getStringData();
					if( myPlayer.getItemAmount( id ) == 0  )
                        			comm.printError( "You do not have any of that item." );
					else 	
					{
						int healAmount = myItemData.getHealAmount( id );
						if( healAmount == -1 )
							comm.printError( "You may not use that item." );
						else 
						{
							if( myItemData.getHealWhich( id ) == ItemData.HEALTH )
								myPlayer.adjustHP( healAmount );
							myPlayer.addItem( id, -1 );
							comm.printMessage( "You use the " + myItemData.getDesc( id ) );
							comm.setActivePlayer( myPlayer );
						}
					}
				}
				break;
				case Command.PARTITION: 
				{
					if( inSession ) 
					{
						int part = ((IntCommand)command).getIntData();
						myPartNum = part;
						myState.setPartNum( part );
						myPlayerRefresher.setPartition( part );
						comm.printMessage
						( "Partition set to " + myPartNum );
					}
						else
						comm.printError( "You need to be in a session." );
				}
				break;
				case Command.ENTER:
				case Command.HOUSE_ENTER: 
				{
					int houseNum = ((IntCommand)command).getIntData();
					// The enterhouse function takes care of moving the player into the house/
					// if it sucessful, it returns a value of true.
					if( myMap.enterHouse( houseNum ) ) 
					{
						printCurrentRoom();
						if( inSession )
							mySession.moveHouse( myPlayer.getId(), myMap.getHouseId(),
						true, myPartNum );
	
					}
					else
						comm.printError( "You can not enter that house." );
				}	
				break;
				case Command.CAST_NO_TARG: 
				{
					String splId = ((StringCommand)command).getStringData();
					if( checkSpell( splId ) ) 
					{
						if( hasBalance ) 
						{
							if( myPlayer.isInCombat() ) 
							{
								comm.printCombatMessage( "You cast a spell!", Color.black, true );
								int damage = myItemData.getCombatBonus( splId );
								if( myPlayer.hasMobTarget() )
									attackMob( damage );
								else
									attackPlayer( damage );
	
							}
							else
								comm.printMessage( "You cast a spell into the air around you!" );
							startBalanceTimer( splId );						
						}
						else	
							comm.printError( "You are recovering from your last cast!" );					
					}
				}
				break;
				case Command.CAST: 
				{
					String splId = ((CastCommand)command).getSpellId();
					String mobId = ((CastCommand)command).getMobName();
					if( canAttack( false ) && checkSpell( splId ) ) 
					{
						theMobTarget = myMap.getFreeMob( mobId );
						if( theMobTarget != null )
							startFight( splId );
						else
							comm.printError( "That mob does not exist, or all creatures " +
							"of that type are in combat already in this area." );
					}	
				}
				break;
				case Command.LEAVE_HOUSE: 
				{
					if( !myPlayer.isInHouse() )
						comm.printError( "You are not in a house." );
					else 
					{
						if( inSession )
							mySession.moveHouse( myPlayer.getId(), myMap.getHouseId(),
							false, myPartNum );
						myMap.leaveHouse();
						printCurrentRoom();
						myPlayer.leaveHouse();
					}		
				}
				break;
				case Command.DISPLAY_PART: 
				{
					comm.printMessage
					( "Current partition: "  + myPartNum );
				}	
				break;
				case Command.CLEAR_SCREEN: 
				{
					comm.clear();
					printCurrentRoom();
				}
				break;
				case Command.DO_REPORT_NOW: 
				{
					if( inSession ) 
					{
						comm.printMessage( "Doing report now." );
						reportTimer.start( 5000 );
					}
				}
				break;
				case Command.SURRENDER: 
				{
					if( !myPlayer.isInCombat() || myPlayer.hasMobTarget() )
						comm.printError( "You must be fighting another player to execute " +
						"this command." );
					else 
					{
						comm.printMessage
						( "You surrender to " +
						thePlayerTarget.getName() );
						myPlayer.clearTargetData();
						comm.clearCombatLog();
						thePlayerTarget.clearTargetData();
						thePlayerTarget = null;
						mySession.surrender( myPartNum, myPlayer.getId() );
					}
				}
				break;
				case Command.MOB_COMMAND: 
				{
					MobCommand mCommand = (MobCommand)command;
					Mob theMob = (Mob)myState.get( GameState.MOB, mCommand.getKey() );
					if( theMob != null ) 
					{
						if( mCommand.getMobCmdType() == MobCommand.KILL ) 
						{
							theMob.kill();
							DeathData info = new DeathData( myPlayer.getId(), theMob.getKey() );
							mySession.notifyMobDeath( info, myPartNum );
						}
						else if( mCommand.getMobCmdType() == MobCommand.FIND )
							comm.printMessage( theMob.getName() + ": " +
							theMob.getCurrentLocation() );
						else
							theMob.doNow( mCommand.getMobCmdType() );
					}
					else
						comm.printError( mCommand.getKey() + ": Invalid MobKey" );
				}
				break;
				case Command.PRINT_MOBS: 
				{
					Iterator theMobs = myState.getCollection( GameState.MOB );
					while( theMobs.hasNext() ) 
					{
						Mob theMob = (Mob)theMobs.next();
						comm.printMessage( theMob.getName() +
							"(" + theMob.getKey() + ")" +
							" " + theMob.getCurrentLocation( ));
					}
				}	
				break;	
				case Command.QUIT: 
				{
					if( inSession )
						comm.printError( "You may not quit until you leave the session." );
					else 
					{	
						myPlayer.save();
						System.exit( 0 );
					}
				}	
				break;
			}
		}
		unlock();
	}
}
@


1.32
log
@*** empty log message ***
@
text
@d14 1
a14 1
 * @@version: $Id: GameSystem.java,v 1.31 2004/12/16 16:39:44 rjw2183 Exp rjw2183 $
d1100 1
a1100 1
			   myPlayer.getId().equals( theAd.sessionState.getPlayerId() ) )
d2216 1
a2216 1
					SayData sd = new SayData( myPlayer.getId(), myMap.getCurrentPlayerLocation(),
d2290 1
a2290 1
						SayData myMessage = new SayData( myPlayer.getId(),myMap.getCurrentPlayerLocation(),
d2306 1
a2306 1
							mySession.setPond( myMap.getCurrentPlayerLocation(), 
d2351 1
a2351 1
						if( !myMap.getCurrentPlayerLocation().equals( new XYloc( x, y ) ) ) 
d2353 1
a2353 1
							XYloc temp = new XYloc( myMap.getCurrentPlayerLocation() );
d2359 1
a2359 1
							myMap.getCurrentPlayerLocation(), myPartNum );
d2842 1
a2842 1
						myMap.getCurrentPlayerLocation(), myPartNum );
@


1.31
log
@*** empty log message ***
@
text
@d2 11
a12 12
 * The GameSystem class is the class which is the primary controller
 * and coordinator of the game.  It's function is simple, accept an incoming
 * Command object, determine what it is, and then execute that command.
 * Thus, the largest function in this class is the execute function which
 * does all that.  Almost every other function is a helper to that function.
 * The GameSystem also serves as the primary source of communcation between
 * other units that are in the session, as well as the object which
 * controls the advertise/find session functions.  This is the closet
 * thing to a server in the game, since this is the primary controller.
 * Of course, this creates a single point of failure for the most part,
 * but that's ok since if something fails here, the game needs to exit.
 *
d14 1
a14 1
 * @@version: $Id: GameSystem.java,v 1.30 2004/12/14 17:22:47 rjw2183 Exp rjw2183 $
d41 117
a157 106
MobListener, PlayerCacheListener {
    // Session related data members
    private Game myHandle;  // this unit's unihandle
    private boolean inSession; // indicates if the unit is in a session
    private String mySessionName; // name of the session the unit isa member of
    private Game mySession; // handle to the session this game is a part of

    // State related state members
    private PlayerCharacter myPlayer; // the player for this unit
    private World myMap; // the world for this unit
    private GameState myState; // the state of this game
    private GameState incomingState; // used when joining a session, this is the incoming state of the game
    private TimeManager myTimeManager; // the manager for the passage of time
    private ItemData myItemData;  // the item data of the game
    String stateName; // the file name of that state, this is sed for the shortcut save command

    // combat related data members
    private Mob theMobTarget; // The mob target the player is attacking
    private PlayerCharacter thePlayerTarget; // the player target the player is currently fighting.
    private boolean hasBalance; // indicated if this persdon curretly has balance
    private int round; // the round of attack this is
    private boolean consideringDuel; // indicates if this toon is currently considering a duel
    private Eoid currentChallenger; // the current duel challenger
    private Timer attackTimer; // timer used to notify when the player has balance
    boolean ignoreBroadcasts; // a flag to indicate if a unit needs to ignore a broadcast


    // Misc data members
    private PlayerCommunicator comm; // used to talk to the player
    private String[] attacks; // an array used to print out the type of attack
    private MapWindow myMapWindow; // the map windoe
    private Random mobMover; //  A random used to generate the movement of the next mob
    private Vector lookupVector; // the vector which stores the data from a lookup
    private FriendsList myFriendsList; // a friends' listing for this user
    private int myPartNum;
    boolean leftSession; //  A boolean to indicate if the user left a session
    private PlayerRefresher myPlayerRefresher; // used as a heartbeat

    SessionFinder sessionFinder; // the object used to find sessions.

    // Used for synchronization
    private boolean available;

    private class AttackTimerTask
    implements TimerTask {
        public AttackTimerTask() {
        }

        public void action( Timer theTimer ) {
            setAttack( theTimer );
        }
    }

    private void setAttack( Timer theTimer ) {
        setBalance( true );
    }
    /********************************************************************************************************************************/
    /**
     * Constructor
     */
    public GameSystem( PlayerCommunicator theComm )
    throws Exception {
        super();
        comm = theComm;
        checkDirectories();
        leftSession = false;

        // Set up the combat and report timers
        intervalPRNG = new Random();
        attackTimer = TimerThread.getDefault().createTimer( new AttackTimerTask() );

        // Set up the M2MI communications
        M2MI.export( this, Game.class );
        M2MI.export( this, GameDiscovery.class );
        myHandle = (Game)M2MI.getUnihandle( this, Game.class );
        stateName = null;
        myPartNum = 0;

        myTimeManager = new TimeManager( this );
        lookupVector = new Vector();
        loadItemData();
        available = true;
        attacks = new String[4];
        attacks[0] = "punch";
        attacks[1] = "kick";
        attacks[2] = "slash";
        attacks[3] = "thrust";
        hasBalance = true;
        round = 0;
        consideringDuel = false;
        currentChallenger = null;
        incomingState = null;
        myMapWindow = new MapWindow();
        myPlayer = null;
        myMap = null;
        comm.printMessage( "Welcome to M2MIMud! Please create or load a new character." );
        comm.printMessage( "Upon obtaining a character, s/he will be placed into the default world, " +
        "from where you can load up another world (or map) to begin play." );


        // Other data member initalization
        inSession = false;
        mySession = null;
        mobMover = new Random();
    }
    /********************************************************************************************************************************/
d164 246
a409 217
    /**
     * Attempts to lock the game system
     */
    private void attemptLock() {
        while( available == false ) {
            try {
                wait();
            }
            catch( Exception e ) {
            }
        }
        available = false;
    }

    /**
     * Unlocks the game system, and notifes all waiting threads that the
     * system in now available.
     */
    private void unlock() {
        available = true;
        notifyAll();
    }
    /********************************************************************************************************************************/
    // The functions of the Game interface, which are used to maintain state and such

    /**
     * Prints out the user's message.  Unlike a say, this is broadcast to everyone on the map.
     * @@param: message The message from the user
     * .
     * @@param: handle The handle of the game which controls the player
     * @@param: playerName The name of the player
     */
    public synchronized void yell( SayData theMessage, int partition ) {
        if( partition == myPartNum ) {
            attemptLock();
            if( !myPlayer.getId().equals( theMessage.playerId ) ) {
                PlayerCharacter thePlayer = checkId( theMessage.playerId );
                String name = "Someone";
                if( thePlayer != null )
                    name = thePlayer.getName();
                comm.printMessage( name + " yells, \"" + theMessage.myMessage + "\"" );
            }
            unlock();
        }
    }

    /**
     * Performs a say, which causes the message to be displayed if this unit's
     * player is in the same room as the player who did the say
     * @@param the Message The object that contains the information needed to do the message.
     */
    public synchronized void say( SayData theMessage, int partition ) {
        if( partition == myPartNum ) {
            attemptLock();
            if( !myPlayer.getId().equals( theMessage.playerId ) ) {
                PlayerCharacter thePlayer = checkId( theMessage.playerId );
                String name = "Someone";
                if( thePlayer != null ) {
                    name = thePlayer.getName();
                    checkLocation( thePlayer, theMessage.playerLoc );
                }
                if( myMap.checkLoc( theMessage.playerLoc ) )
                    comm.printMessage( name + " says, \"" + theMessage.myMessage + "\"" );
            }
            unlock();
        }
    }


    /**
     * Tells the session someone is joining.
     * @@param: handle The handle of the joining game unit
     * @@param: player The player character data of the player
     * @@param: newState the state of the world which is joining
     */
    public synchronized void joinSession( PlayerCharacter player, int partition ) {
        if( partition == myPartNum ) {
            attemptLock();

            // First things first - stop the report
            // timer and add the player.
            reportTimer.stop();
            // Reset the time
            myState.setTime( myTimeManager.getTime() );

            // Print out the notification
            comm.printMessage( player.getName() + " has joined our world." );

            if( myFriendsList.hasPlayer( player.getId() ) )
                comm.printMessage( "Your friend, " + player.getName() + " has joined this session." );

            // Restart the timer
            scheduleNormalReport();

            // display the current world
            if( myPlayer.getId().equals( player.getId() ) )
                printCurrentRoom();

            // Final step! If my player is in combat, remnd everyone.
            if( myPlayer.isInCombat() ) {
                if( myPlayer.hasMobTarget() ) {

                    mySession.registerAttacker
                    ( myPlayer.getLocation(), theMobTarget.getKey(),
                    myPlayer.getId(),  theMobTarget.getCombatTimeStamp(),
                    myPartNum );
                }

            }
            unlock();
        }
    }

    /**
     * Tells the session someone is leaving.
     * @@param: handle The handle to the game unit which is leaving
     */
    public synchronized void leaveSession( Eoid playerId, int partition ) {
        if( partition == myPartNum ) {
            attemptLock();
            reportTimer.stop();
            PlayerCharacter leavingPlayer = checkId( playerId );
            if( leavingPlayer != null ) {

                String name = leavingPlayer.getName();

                // If the leaving player is in combat, the unit
                // needs to drop the targets from that fight.
                // Obviously since, at this point, something is wrong,
                // the system will then request an emergency transmission
                // in an attempt to perform state synchronization.
                if( leavingPlayer.isInCombat() ) {
                    if( leavingPlayer.hasMobTarget() ) {
                        MobKey theKey = (MobKey)leavingPlayer.getTarget();
                        Mob theMob = (Mob)myState.get( GameState.MOB, theKey );
                        if( !theMob.getKey().equals( myPlayer.getTarget() ) )
                            theMob.stopAttack();
                        else
                            mySession.errorDetected( myPlayer.getId(), myPartNum );
                    }
                    else {
                        PlayerCharacter thePlayer = checkId(
                        (Eoid)leavingPlayer.getTarget() );
                        if( thePlayer != null )
                            thePlayer.clearTargetData();
                        if( myPlayer.getId().equals( thePlayer.getId() ) ) {
                            thePlayerTarget = null;
                            comm.printError( "Your fight has been ended." );
                            comm.clearCombatLog();
                        }
                    }
                }

                if( consideringDuel &&
                leavingPlayer.getId().equals( currentChallenger ) ) {
                    consideringDuel = false;
                    comm.printMessage( "Duel challenge cancelled" );
                }

                if( consideringDuel && thePlayerTarget != null &&
                leavingPlayer.getId().equals( thePlayerTarget.getId() ) ) {
                    consideringDuel = false;
                    comm.printMessage( "Duel challenge cancelled." );
                }


                if( !myPlayer.getId().equals( playerId ) ) {
                    myState.remove( GameState.PLAYER, leavingPlayer.getId() );
                    comm.printMessage( name + " has left our world." );
                    if( myFriendsList.hasPlayer( playerId ) )
                        comm.printMessage( "Your friend, " + name +
                        " has left this session." );
                    myMap.removePlayer( playerId );
                }
            }
            scheduleNormalReport();
            unlock();
        }
    }

    /**
     * Moves a player or a mob
     * @@param theMove An object which contains the data need to perform the move
     */

    public synchronized void processMove( MoveData aMove, int partition ) {
        if( partition == myPartNum ) {
            attemptLock();
            switch( aMove.getType() )
	    {
                case MoveData.PLAYER:
		{
                    UserMove theMove = (UserMove)aMove;
                    if( !myPlayer.getId().equals( theMove.getUser() ) ) {
                        PlayerCharacter thePlayer = checkId( theMove.getUser() );
                        if( thePlayer != null ) {
                            String name = thePlayer.getName();
                            // If the player is in combat....
                            // Moving causes the monster they are fighting to
                            // stop attacking them.
                            if( thePlayer.isInCombat() ) {
                                if( thePlayer.hasMobTarget() ) {
                                    Mob theMob = (Mob)myState.get(
                                    GameState.MOB,
                                    (MobKey)thePlayer.getTarget() );
                                    theMob.stopAttack();
                                    thePlayer.clearTargetData();
                                    comm.printMessage( thePlayer.getName() +
                                    " disengages combat with " +
                                    theMob.getName() );
                                }
                                else 
				{
                                    PlayerCharacter player =
                                    checkId( (Eoid)thePlayer.getTarget() );
                                    if( player != null )
                                        player.clearTargetData();
d411 367
a777 223
				    thePlayer.clearTargetData();
                                    if( myPlayer.equals( player ) ) 
				    {
                                        comm.printError( "Your fight has been ended." );
                                        comm.clearCombatLog();
					thePlayerTarget = null;
                                    }
                                }
                            }

                            // If my player is not in a house and is in either the
                            // to or from tiles, display something.
                            if( myMap.checkLoc( theMove.getLoc( MoveData.FROM ) )
                            && !myPlayer.isInHouse() ) {
                                String[] directions = { "north", "south", "east", "west" };
                                comm.printMessage( name + " leaves to the " +
                                directions[theMove.getDirection()] );
                            }
                            else if( myMap.checkLoc( theMove.getLoc( MoveData.TO ) ) &&
                            !myPlayer.isInHouse() ) {
                                String[] directions = { "south", "north", "west", "east" };
                                comm.printMessage( name + " enters from the " +
                                directions[theMove.getDirection()] );
                            }
                            myMap.processMove( theMove );
                        }
                    }
                }
                break;
                case MoveData.MOB: {
                    MobMove theMove = (MobMove)aMove;
                    Mob theMob = (Mob)myState.get( GameState.MOB, theMove.getKey() );
                    // Yep.   If the mob is dead or fighting.. there's an error.
                    if( !theMob.isAlive() || theMob.isUnderAttack() )
                        mySession.errorDetected( myPlayer.getId(), myPartNum );
                    else {
                        myMap.refreshMobTimer( theMove.getKey() );
                        if( theMove.getDirection() != -1 ) {
                            String name = theMob.getName();
                            boolean validMob = myMap.moveMob( theMove );
                            if( myMap.checkLoc( theMove.getLoc( MoveData.FROM ) ) && validMob ) {
                                String[] directions = { "north", "south", "east", "west" };
                                comm.printMessage("A " + name + " leaves to the " +
                                directions[theMove.getDirection()] );
                            }
                            else if( myMap.checkLoc( theMove.getLoc( MoveData.TO ) ) && validMob ) {
                                String[] directions = { "south", "north", "west", "east" };
                                comm.printMessage(  "A " + name + " enters from the " +
                                directions[theMove.getDirection()] );
                            }
                        }
                    }
                }
                break;
            }
            unlock();
        }
    }
    /**
     * Notifies this unit that a player has timed out and must thus be removed.
     * @@param: handle The unihande of the game unit which has timed out.
     */
    public synchronized void notifyPlayerTimeout( Eoid playerId, int partition ) {
        if( partition == myPartNum ) {
            attemptLock();
            if( myPlayer.getId().equals( playerId ) && inSession ) {
                leave();
                comm.printMessage( "Disconnected from the session as there has " +
                "been no activity for 10 minutes." );
            }
            else {
                mySession.leaveSession( playerId, myPartNum );
            }
            unlock();
        }
    }


    /**
     * Sets a pond at the given location
     * @@param location The location to place the pond at
     * @@param playerId The id of the player who dug the pond
     */
    public synchronized void setPond( XYloc location, Eoid playerId, int partition ) {
        if( partition == myPartNum ) {
            attemptLock();
            if( !myPlayer.getId().equals( playerId ) ) {
                PlayerCharacter thePlayer = checkId( playerId );
                String name = "Someone";
                if( thePlayer != null )

                    name = thePlayer.getName();
                checkLocation( thePlayer, location );
                myMap.setPondAt( location );
                if( myMap.checkLoc( location ) )
                    comm.printMessage( name + " digs a small pond in the ground." );
            }
            myState.add( GameState.POND, location );
            unlock();
        }
    }

    /**
     * Warps the player from one location to another
     * @@param playerId The id of the player who warped
     * @@param: from The location the player warped from
     * @@param: to The location the player warped to
     */
    public synchronized void warp( Eoid playerId, XYloc from, XYloc to, int partition ) {
        if( partition == myPartNum ) {
            attemptLock();
            if( !myPlayer.getId().equals( playerId ) ) {
                PlayerCharacter thePlayer = checkId( playerId );
                if( thePlayer != null ) {
                    String name = thePlayer.getName();
                    if( myMap.checkLoc( from ) )
                        comm.printMessage( name + " suddenly vanishes from sight!" );
                    myMap.performWarp( playerId, to );
                    if( myMap.checkLoc( to ) )
                        comm.printMessage( name + " suddenly phases into view!" );
                }

            }
            unlock();
        }
    }

    /**
     * Sets up a house
     * @@param theHouse The house object which contains the location and owner of the house
     */
    public synchronized void addHouse( House theHouse, int partition ) {
        if( partition == myPartNum ) {
            attemptLock();
            if( !theHouse.getOwner().equals( myPlayer.getId() ) ) {
                myMap.placeHouse( theHouse );
                PlayerCharacter thePlayer = checkId( theHouse.getOwner() );
                String name = "Someone";
                if( thePlayer != null ) {
                    name = thePlayer.getName();
                    checkLocation( thePlayer, theHouse.getLocation() );
                }
                if( myMap.checkLoc( theHouse.getLocation() ) )
                    comm.printMessage( name + " builds their house here." );

            }
            unlock();
        }
    }

    /**
     * Notifies the system that the time has changed
     * @@param newTime The new time of the game
     */
    public synchronized void notifyTimePassage( int newTime, int partition ) {
        if( partition == myPartNum ) {
            attemptLock();
            myTimeManager.synchronize( newTime );
            myState.setTime( newTime );
            myMapWindow.updateTime( newTime );
            comm.printMessage( myTimeManager.getTimePassageString( newTime ) );
            unlock();
        }
    }

    /**
     * Inform the system that it is time to perdorm a merchant broadcast, which
     * causes it to print out the merchant's advertisment message
     * @@param merchantType The type of merchant which is broadcasting
     * @@param location The location of the merchant
     */
    public synchronized void merchantBroadcast( int merchantType, XYloc location, int partition ) {
        if( partition == myPartNum ) {
            attemptLock();
            if( myMap.checkLoc( location ) )
                comm.printMessage( myMap.getMerchantBroadcast( merchantType ) );
            Merchant theMerch = (Merchant)myState.get( GameState.MERCHANT, location );
            theMerch.scheduleNextMessage();
            unlock();
        }
    }

    /**
     * Recieves a private message from a player
     * @@param playerId The id of the player who sent the message
     * @@param message The message they sent
     */
    public synchronized void sendPM( Eoid playerId, String message, int partition ) {
        if( partition == myPartNum ) {
            attemptLock();
            String name = "Someone";
            PlayerCharacter thePlayer = checkId( playerId );
            if( thePlayer != null )
                name = thePlayer.getName();
            comm.printMessage( name + " sends, \"" + message + "\"" );
            unlock();
        }
    }

    /**
     * Tells the system that the given mob is under attack by the given player
     * This causes the mob to silently register the player as its attack,
     * which means it stops its movement, but it doesn't inform the system when it attacks
     * is targets.  Players, however, are told that the mob is fighting a player when
     * they enter the room and/or perform the /look command.  They are also notifed that the given player
     * begins attack the monster
     * @@param loc The location where the mob is
     * @@param theKey The MobKey of the mob in question
     * @@param playerId the id of the player.
     */
    public synchronized void registerAttacker( XYloc loc, MobKey theKey, Eoid playerId, Date ts, int partition ) {
        if( partition == myPartNum ) {
            attemptLock();
            Mob theMob = (Mob)myState.get( GameState.MOB, theKey );
            if( !myPlayer.getId().equals( playerId ) )
	    {
                if( theKey.equals( myPlayer.getTarget() ) )
                    mySession.errorDetected( myPlayer.getId(), myPartNum );
                else 
		{
                    PlayerCharacter thePlayer = checkId( playerId );
                    if( thePlayer != null ) 
		    {			
d779 11
a789 3
			if( thePlayer.getId().equals( myPlayer.getTarget() ) )
		    	{			 	
			 	comm.printError( "Your fight has been ended." );
d791 3
d795 177
d973 191
a1163 4
			myState.clearPlayerTarget( thePlayer );
			thePlayer.registerTarget( theKey );
                        checkLocation( thePlayer, loc );
                    }
d1165 46
a1210 451
		    theMob.startAttackSilent( playerId, ts );
                    if( !theMob.getCurrentLocation().equals( loc ) )
                        myMap.moveMob( theMob.getKey(), loc );			
		   
		    if( myMap.checkLoc( loc ) )
		    {
                        String pName = "Someone";
                        if( thePlayer != null )
                            pName = thePlayer.getName();
                        comm.printMessage( pName + " begins attacking the " + theMob.getName() + "!",
                        Color.red.darker() );
                    }
                }
            }
            unlock();
        }
    }

    /**
     * Tells this unit that the 2 players are in combat.
     * @@param p1 The id of one of the players in combat
     * @@param p2 The id of the other player in combat
     * @@param loc The location where the teo are fighting
     */
    public synchronized void notifyFight( Eoid p1, Eoid p2, XYloc loc, int partition ) {
        if( partition == myPartNum ) {
            attemptLock();
            PlayerCharacter playerOne = checkId( p1 );
            PlayerCharacter playerTwo = checkId( p2 );
            String name1 = "Someone";
            String name2 = "someone else";


            if( p1.equals( myPlayer.getTarget() ) && !p2.equals( myPlayer.getId() ) ||
            p2.equals( myPlayer.getTarget() ) && !p1.equals( myPlayer.getId() ) )
                endFightError();

            if( playerOne != null ) {
                playerOne.clearTargetData();
                playerOne.registerTarget( p2 );
                name1 = playerOne.getName();
                checkLocation( playerOne, loc );
            }

            if( playerTwo != null ) {
                playerTwo.clearTargetData();
                playerTwo.registerTarget( p1 );
                name2 = playerTwo.getName();
                checkLocation( playerTwo, loc );
            }

            boolean isMe = myPlayer.getId().equals( p1 ) ||
            myPlayer.getId().equals( p2 );

            if( myMap.checkLoc( loc ) && !isMe )
                comm.printMessage( name1 + " and " + name2 + " begin fighting!" );
            unlock();
        }
    }

    /**
     * Tells this unit to print damage
     */
    public synchronized void printAttack( int damage, int partition, Eoid pId ) {
        if( partition == myPartNum &&
        ( myPlayer.isInCombat() &&
        pId.equals( myPlayer.getTarget() ) )
        ) {
            attemptLock();
            String pName = thePlayerTarget.getName();
            int bonus = myItemData.getCombatBonus( myPlayer.getGear( PlayerCharacter.BODY ) );
            if( bonus != -1 )
                damage -= bonus;
            if( damage < 0 )
                damage = 0;
            thePlayerTarget.getHandle().reportBackDamage( damage, myPartNum );
            comm.printCombatMessage( pName + " attacks you for " + damage + " damage!", Color.red.darker(), true );
            myPlayer.adjustHP( -1 * damage );
            comm.setActivePlayer( myPlayer );
            if( !myPlayer.isAlive() ) {
                comm.printMessage( "You were just killed by " + pName );
                myPlayer.clearTargetData();
                thePlayerTarget.clearTargetData();
                myMap.warp( 0, 0 );
                myPlayer.ressurect();
                comm.setActivePlayer( myPlayer );
                comm.clearCombatLog();
                printCurrentRoom();
                DeathData theInfo =
                new DeathData( myPlayer.getId(), thePlayerTarget.getId() );
                thePlayerTarget = null;
                mySession.notifyPlayerDeath( theInfo, myPartNum );
            }
            unlock();
        }
    }

    /**
     * Tells this unit to respawn the mob of the given key.
     * @@param theKey They key of the mob to respawn
     */
    public synchronized void notifyMobRespawn( MobKey theKey, int partition ) {
        if( partition == myPartNum ) {
            attemptLock();
            Mob theMob = (Mob)myState.get( GameState.MOB, theKey );

            // This is part of the state checking mechanism.
            // If the a respawn is rec'd, but the monster is not
            // dead, something's gone wrong. In this situation,
            // the game requests it's session to perform an emergency report.
            if( !theMob.isAlive()  ) {
                theMob.respawn();
                if( myMap.checkLoc( theMob.getCurrentLocation() ) )
                    comm.printMessage( theMob.getName() + " is restored back to life." );
            }
            else
                mySession.errorDetected( myPlayer.getId(), myPartNum );
            unlock();
        }
    }

    /**
     * Informs this unit that the player was just killed
     * @@param id The id of the player
     * @@param loc The location where the player was killed
     */
    public synchronized void notifyPlayerDeath( DeathData theInfo, int partition ) {
        if( myPartNum == partition ) {
            attemptLock();
            if( !myPlayer.getId().equals( theInfo.getKilled() ) ) {
                PlayerCharacter thePlayer = checkId( theInfo.getKilled() );
                String name = "Someone";
                String name2 = "someone";
                if( thePlayer != null ) {
                    name = thePlayer.getName();
                    thePlayer.clearTargetData();
                    myMap.performWarp( thePlayer.getId(), new XYloc( 0, 0 ) );
                }

                if( theInfo.getCombatType() == DeathData.MOB ) {
                    // Error detection - if the player was killed
                    // by the mob this unit's player is fighting, something
                    // is wrong.
                    if( theInfo.getMob().equals( myPlayer.getTarget() ) ||
                    theInfo.getKilled().equals( myPlayer.getTarget() ) ) {
                        endFightError();
                    }
                    Mob theMob = (Mob)myState.get( GameState.MOB,
                    theInfo.getMob() );
                    theMob.stopAttack();
                    name2 = theMob.getName();

                }
                else {
                    PlayerCharacter theOtherPlayer =
                    checkId( theInfo.getKiller() );
                    // If the person who killed the player was the person'
                    // ths unit is fighting, something is wrong.
                    // also if the person killed was this unit's target
                    // AND the killer was not this unit, something
                    // is wrong
                    if( theInfo.getKiller().equals( myPlayer.getTarget() ) ||
                    ( theInfo.getKilled().equals( myPlayer.getTarget() ) &&
                    !theInfo.getKiller().equals( myPlayer.getId() ) ) ) {
                        endFightError();
                    }

                    if( theOtherPlayer != null ) {
                        theOtherPlayer.clearTargetData();
                        name2 = theOtherPlayer.getName();
                        if( myPlayer.getId().equals( theOtherPlayer.getId() ) ) {
                            thePlayerTarget = null;
                            comm.clearCombatLog();
                        }
                    }
                }
                comm.printMessage( name + " was killed by " + name2 );
            }
            unlock();
        }
    }

    public synchronized void updateState( GameState theState, int partition ) {
        if( myPartNum == partition ) {
            attemptLock();
            // Straightforward - this simply calls merge on the state
            myState.merge( theState, myMap );
            unlock();
        }
    }

    /**
     * Refreshes the player's timers
     * @@param: Eoid The id of the player
     * @@param: partNum The partion number
     */
    public synchronized void refreshPlayer( Eoid playerId, int partNum ) {
        if( myPartNum == partNum ) {
            attemptLock();
            PlayerCharacter thePlayer = checkId( playerId );
            if( thePlayer != null )
                myState.refreshPlayer( playerId );
            unlock();
        }
    }

    /**
     * Moves the given player into the listed house
     * @@param pId the id of the player
     * @@param houseId the id of the house
     */
    public synchronized void moveHouse( Eoid pId, Eoid houseId, boolean enter, int partNum ) {
        if( myPartNum == partNum && !myPlayer.getId().equals( pId ) ) {
            attemptLock();
            boolean inRoom = false;
            String which = null;
            PlayerCharacter thePlayer = checkId( pId );
            House theHouse = (House)myState.get( GameState.HOUSE, houseId );
            if( theHouse == null )
                mySession.errorDetected( myPlayer.getId(), myPartNum );

            if( thePlayer != null && theHouse != null ) {
                checkLocation( thePlayer, theHouse.getLocation() );
                if( enter == false ) {
                    myMap.removePlayerFromHouse( pId, houseId );
                    which = "leaves";
                }
                else {
                    myMap.movePlayerIntoHouse( pId, houseId );
                    which = "enters";
                }

                XYloc houseLoc = theHouse.getLocation();
                if( myMap.checkLoc( houseLoc ) ) {
                    String pName = thePlayer.getName();
                    String hName = theHouse.getOwnerName();
                    comm.printMessage( pName + " " + which + " " + hName + "\'s house." );
                }
            }
            unlock();
        }
    }

    /**
     * This function notifes this unit that caller has a state issue,
     * and that this unit needs to schedule an emergency report in hopes
     * that the state can be fixed
     * @@param pId The id of the unit that called this
     */
    public synchronized void errorDetected( Eoid pId, int partNum ) {
        if( myPartNum == partNum ) {
            attemptLock();
            // One of the aspects of M2MIMud is that there is no "one" state
            // that units can rely on when the realize their state is no longer
            // in sync with the global state. When an error is detected, the only
            // thing that can be done is to begin te process of state healing, which
            // takes into account a state.  Therefore, when this function is called,
            // the notion is that this unit has detected an error.  The error could come from
            // a unit which has been partitioned, or perhaps the unit itself was partitioned.
            // In any event, the only thing the unit can rely on is itself.  As a result,
            // this function causes all other session members to restart their report timers,
            // and causes this unit to schedule an emergency broadcast in an attempt
            // to fix the global state.
            if( myPlayer.getId().equals( pId ) )
                scheduleEmergencyReport();
            else
                scheduleNormalReport();
            unlock();
        }
    }

    /********************************************************************************************************************************/
    // These are the duel functions used when one player challenges another player.

    /**
     * Informs this system that a challeneg to a duel has been issued
     * @@param: pId The player if of the person who issued the duel
     */
    public synchronized void requestDuel( Eoid pId, int partition ) {
        if( myPartNum == partition ) {
            attemptLock();
            PlayerCharacter challenger = checkId( pId );
            if( challenger != null ) {
                if( consideringDuel )
                    challenger.getHandle().declineDuel( " is already considering another duel.",
                    myPlayer.getId(), myPartNum );
                else {
                    comm.printMessage( challenger.getName() + " has challenged you to a duel!" );
                    consideringDuel = true;
                    currentChallenger = pId;
                }
            }
            else
                mySession.errorDetected( myPlayer.getId(), myPartNum );
            unlock();
        }
    }

    /**
     * Tells the player that the person has decline the duel
     * @@param reason The reason the player declined the duel
     * @@param pId The id of the person who declined the duel
     */
    public synchronized void declineDuel( String reason, Eoid pId, int partition ) {
        if( partition == myPartNum ) {
            attemptLock();
            String pName = ((PlayerCharacter)myState.get( GameState.PLAYER, pId )).getName();
            comm.printMessage( pName + reason );
            consideringDuel = false;
            unlock();
        }
    }

    /**
     * Informs the unit that duel challenge has been accepted.
     * @@param pId The id of the player who accepted the duel.
     */
    public synchronized void acceptDuel( Eoid pId, int partition ) {
        if( partition == myPartNum ) {
            attemptLock();
            PlayerCharacter thePlayer = (PlayerCharacter)myState.get( GameState.PLAYER, pId );
            comm.printMessage( thePlayer.getName() + " has accepted your challenge! Begin fighting!" );
            consideringDuel = false;
            thePlayerTarget = thePlayer;
            myPlayer.registerTarget( pId );
            comm.setTarget( thePlayer.getName() );
            unlock();
        }
    }

    /********************************************************************************************************************************/
    // These functions are the ones used to do the reporting of this game and any session it is a part of to to the world

    /**
     * Receives a session report.  If this report constans the data for
     * the session this unit is a part of, then the state it contains is checked with
     * the game's current state to makes sure that it is consistent.
     * Also, the timer is restarted to reduce network traffic.
     * @@param theAd An ad for a game session.
     */
    public synchronized void report( SessionAd theAd ) {

        if(
        ( mySession != null && mySession.equals( theAd.sessionHandle ) ) &&
        theAd.sessionState.getPartNum() == myPartNum
        ) {

            attemptLock();

            if( myState.equals( theAd.sessionState ) ||
            myPlayer.getId().equals( theAd.sessionState.getPlayerId() ) )
                scheduleNormalReport();
            else {
                comm.disable();
                boolean wasInCombat = myPlayer.isInCombat();
                myState.synchronize( theAd.sessionState, myMap );
                if( wasInCombat && !myPlayer.isInCombat() ) {
                    comm.printMessage( "The gods have ended your fight." );
                    theMobTarget = null;
                    thePlayerTarget = null;
                    comm.clearCombatLog();
                }
                currentChallenger = null;
                comm.enable();

                // Since things were changed, schedule an
                // emergency report to get out the changes asap.
                scheduleEmergencyReport();
            }
            unlock();
        }
    }

    /**
     * This is the method called when the reportTimer go off.
     * @@param theTimer The timer that went off
     */
    protected synchronized void invokeReport( Timer theTimer ) {
        if( theTimer.isTriggered() ) {
            allGameUnits.report
            ( new SessionAd( mySessionName, mySession,
            myState ) );
        }
    }
    /********************************************************************************************************************************/
    // Helper functions used to join and leave sessions

    /**
     * The listener function for this game System, this is called when the user has
     * selected a session (or hit the cancel button) on the game selection window.
     * @@param: theAd The session ad which contains the information about the session the user selected.
     */

    public void sessionSelected( SessionAd theAd ) {
        comm.enable();
        // A value of null for the session ad indicates they hit the 'cancel' button
        if( theAd != null ) {

            inSession = true;
            mySession = theAd.sessionHandle;
            mySessionName = theAd.sessionName;
            incomingState = theAd.sessionState;
            myMap.warp( 0, 0 );

            if( incomingState.getConfig() != null &&
            !incomingState.getConfig().equals( myState.getConfig() ) )
                // recreate the world using this configuration
                myMap.createWorld( incomingState.getConfig() );

            else {

                // This is rather special case.  This deals with situation when the
                // the user has a non default state, but is joininga session which is using
                // the default state.  What happens is the the syste, defaults to this case,
                // because the incoming state does not have a configuration.  This is case is
                // partially appropiate, because what the system will do it to load the default
                // state.
                if( incomingState.getConfig() == null && myState.getConfig() != null ) {
                    myMap = myMap.getWorld( "default" );
                    myState = myMap.getState();
                    myState.add( GameState.PLAYER, myPlayer );
                    myState.setPCList( this );
                    myState.setId( myPlayer.getId() );
                }
            }

            mySession.updateState( myState, myPartNum );

            myState.merge( incomingState, myMap );
            myState.updateListeners( this, this, myMap );

            myTimeManager.synchronize( theAd.sessionState.getTime() );
            myTimeManager.start();


            ((Multihandle)mySession).attach( this );
            mySession.joinSession( myPlayer, myPartNum );
            myPlayerRefresher = new PlayerRefresher( myPlayer.getId(), mySession );
            myPlayerRefresher.start();

            myMap.setViewer( myMapWindow );
            comm.clear();
            comm.setStateName( stateName );
            myMap.setViewer( myMapWindow );
            comm.printMessage( "Joining session: " + theAd.sessionName );
            printCurrentRoom();

            sessionFinder.unexport();
            sessionFinder = null;
        }
    }
d1212 1
a1212 1
        /*
d1215 213
a1427 226
    private void leave() {
        // Leave the session, save all the data, and then quit out
        if( consideringDuel )
            cancelDuel( " has left the game. Challenge cancelled." );
        if( mySession != null )
            mySession.leaveSession( myPlayer.getId(), myPartNum );
        ((Multihandle)mySession).detach( this );
        myPlayerRefresher.stop();
        myState.clear( GameState.PLAYER );
        myMap.clearSessionInfo();
        M2MI.unexport( this );
        myPlayer.save();
        myFriendsList.save();
        leftSession = true;
        inSession = false;
        myState.add( GameState.PLAYER, myPlayer );
    }
    /********************************************************************************************************************************/
    // These are the non Game interface functions

    /**
     * The function for the time listener interface.  Used to tell the session that time has changed.
     * @@param newTime The new time
     */
    public void timeChanged( int newTime ) {
        if( mySession != null )
            mySession.notifyTimePassage( newTime, myPartNum );
        else {
            myMapWindow.updateTime( newTime );
            comm.printMessage( myTimeManager.getTimePassageString( newTime ) );
        }
    }

    /**
     * The function	for the merchant listener, if the user is in the current
     * location it prints out the merchant's message
     * @@param: merchantType  The type of merchant
     * @@param: location The location the merchant is
     */
    public synchronized void sendMessage( int merchantType, XYloc location ) {
        attemptLock();
        // The check for null here is if a merchant times out
        // when the game is in the process of leaving the session
        if( mySession != null )
            mySession.merchantBroadcast( merchantType, location, myPartNum );
        unlock();
    }

    /**
     * This informs the game unit that the mob is attacking the target
     * @@param Eoid target The target the mob is attacking, since only the game unit which has
     *        player cares about this, nothing happens if this is not the target
     * @@param damage The base damage the mob has done
     * @@param key The id of the mob which is fighting
     */
    public synchronized void attackTarget(  int damage, String name ) {
        doAttack( damage, name );
    }

    /**
     * Tells the game system that the mob has respawned at the given location
     * @@param  key The key of the mob that respawned
     * @@param loc The location the mob spawned at
     */
    public synchronized void respawnMob( MobKey key ) {
        attemptLock();
        if( mySession != null )
            mySession.notifyMobRespawn( key, myPartNum );
        unlock();
    }

    /**
     * Informs ths unit to tell everyone that a mob is moving and need to update
     * @@param theMove The object which contains the movement data
     */
    public synchronized void moveMob( MobMove theMove ) {
        attemptLock();
        if( mySession != null && theMove != null )
            mySession.processMove( theMove, myPartNum );
        unlock();
    }


    /**
     * This is called t indicate that a player has time out
     * @@param playerId The id of the player who has timed out
     */
    public synchronized void playerTimeout( Eoid playerId ) {
        attemptLock();
        if( mySession != null ) {
            PlayerCharacter thePlayer = checkId( playerId );
            mySession.notifyPlayerTimeout( playerId, myPartNum );
        }
        unlock();
    }

    /**
     * Called when a mob attack the player
     * @@param damage The base damage of the mob
     * @@param name The name of the mob that attacked
     */
    private synchronized void doAttack( int damage, String name ) {
        attemptLock();
        int bonus = myItemData.getCombatBonus( myPlayer.getGear( PlayerCharacter.BODY ) );
        if( bonus != -1 )
            damage -= bonus;

        if( 0 > damage )
            damage = 0;

        Color[] theColors = { Color.red, Color.black, Color.blue };
        comm.printCombatMessage( "The " + name + " attacks you and hits for " + damage + " hit points!",
        theColors[round].darker(), true );
        myPlayer.adjustHP( -1*damage );
        comm.setActivePlayer( myPlayer );
        round++;
        if( round > 2 )
            round = 0;

        if( !myPlayer.isAlive() ) {
            theMobTarget.stopAttack();
            int exp = theMobTarget.getExp();
            myPlayer.incrementExp( -1 * exp );
            comm.printMessage( "You were just killed by the " + name );
            comm.printMessage( "You have lost " + exp + " exp points." );
            myMap.warp( 0, 0 );
            myPlayer.ressurect();
            comm.setActivePlayer( myPlayer );
            comm.clearCombatLog();
            printCurrentRoom();
            DeathData theInfo = new DeathData( myPlayer.getId(),
            theMobTarget.getKey() );
            mySession.notifyPlayerDeath( theInfo, myPartNum );
            theMobTarget = null;
        }
        unlock();

    }

    /**
     * Informs the session that a monster has been killed.
     * @@param loc The location where the mob was killed.
     * @@param pId The id of the player who kill te mob
     */
    public synchronized void notifyMobDeath( DeathData theInfo, int partition ) {
        try {
            if( partition == myPartNum ) {
                attemptLock();
                // For a mob's death, this method returns
                if( !myPlayer.getId().equals( theInfo.getKilled() ) ) {
                    String name = "Someone";
                    Mob theMob = (Mob)myState.get( GameState.MOB, theInfo.getMob() );
                    PlayerCharacter thePlayer = checkId( theInfo.getKilled() );
                    // Lookup the character
                    if( thePlayer != null ) {
                        name = thePlayer.getName();
                        thePlayer.clearTargetData();
                        checkLocation( thePlayer, theMob.getCurrentLocation() );
                    }

                    // If either the player of the mob was registered as
                    // the target of the home character, some is wrong.
                    // stop the fight, and request a state transmission
                    if( ( thePlayer != null &&
                    thePlayer.getId().equals( myPlayer.getTarget() ) ) ||
                    theInfo.getMob().equals( myPlayer.getTarget() )) {
                        endFightError();
                    }

                    // Finally, kill the mob and report it


                    theMob.kill();
                    if( myMap.checkLoc( theMob.getCurrentLocation()))
                        comm.printMessage( name + " kills the " + theMob.getName() );

                }
                unlock();
            }
        }
        catch( Exception e ) {
            e.printStackTrace();
        }
    }

    /**
     * Informs the player of how much damage he or she did to his or her target
     * @@param damage The amount of damage done
     */
    public synchronized void reportBackDamage( int damage, int partNum ) {
        if( partNum == myPartNum ) {
            attemptLock();
            comm.printCombatMessage( "You hit " + thePlayerTarget.getName() + " for " + damage + " damage!",
            Color.red.darker(), false );
            unlock();
        }
    }

    public synchronized void surrender( int partNum, Eoid pId ) {
        if( partNum == myPartNum ) {
            attemptLock();
            if( !myPlayer.getId().equals( pId ) ) {
                if( pId.equals( myPlayer.getTarget() ) ) {
                    comm.printMessage(
                    thePlayerTarget.getName() + " surrenders." );
                    thePlayerTarget.clearTargetData();
                    thePlayerTarget = null;
                    myPlayer.clearTargetData();
                    comm.clearCombatLog();
                }
                else {
                    PlayerCharacter p1 = checkId( pId );
                    if( p1 != null ) {
                        if( !p1.hasMobTarget() ) {
                            Eoid p2Id = (Eoid)p1.getTarget();
                            PlayerCharacter p2 = checkId( p2Id );
                            p1.clearTargetData();
                            if( p2 != null )
                                p2.clearTargetData();
                        }
                    }
                }
            }
            unlock();
        }
    }
d1429 36
a1464 1
    /********************************************************************************************************************************/
d1467 53
a1519 18
    /**
     * Prints the current room
     */
    private synchronized void printCurrentRoom() {
        TextMessage desc = myMap.currentAreaDescription();
        if( myPlayer.isInHouse() )
            printHouse( desc );
        else
            printRoom( desc );
    }

    /**
     * Prints out a room
     * @@param roomDesc The TextMessage object that contains the description of the room
     */
    private void printRoom( TextMessage roomDesc ) {
        // Print out the message from the room
        comm.printTextMessage( roomDesc );
d1521 49
a1569 9
        // Print out the mobs which are nder attack by another player
        for( int i = 0; i < roomDesc.getNumAttackedMobs(); i++ )
        {
            Eoid pId = roomDesc.getPlayer( i );
            String pName = ((PlayerCharacter)myState.get( GameState.PLAYER, pId )).getName();
            String mName = roomDesc.getMobName( i );
            comm.printMessage( "You see " + pName + " attacking a " +
            mName + ".", Color.red.brighter() );
        }
d1571 26
a1596 3
        // Print out the players
        printPlayers();
	
d1598 213
a1810 1
    }
d1812 28
a1839 336
    /**
     * Prints a house.
     * @@param houseDesc The TextMessage object which contains the house's description
     */
    private void printHouse( TextMessage houseDesc ) {
        comm.printMessage( houseDesc.getMessage( 0 ) );
        comm.printMessage( houseDesc.getMessage( 1 ) );
        printPlayers();
    }

    /**
     * Prints out the players in the current area
     */
    private void printPlayers() {
        if( myMap.currentAreaHasPlayers() ) {

            Iterator playerIter = myMap.getCurrentAreaPlayers();
            StringBuffer playerName = new StringBuffer( "You see the following players: " );
            StringBuffer combatPlayers = new StringBuffer();
            int nonCombat = 0;
            int combat = 0;
            while( playerIter.hasNext() ) {
                Eoid temp = (Eoid)playerIter.next();
                PlayerCharacter thePlayer = checkId( temp );
                if( thePlayer != null && !myPlayer.getId().equals( temp ) ) {
                    // Simply print out the name if the player is not in comabt
                    if( !thePlayer.isInCombat() ) {
                        playerName.append( thePlayer.getName() + " " );
                        nonCombat++;
                    }
                    else {
                        // If the player is fighting another player, inform them.
                        // However, if the player is fighting as mob, there is no need,
                        // since that has all ready been reported
                        combat++;
                        if( !thePlayer.hasMobTarget() ) {
                            Eoid pId = (Eoid)thePlayer.getTarget();
                            if( !myPlayer.getId().equals( pId ) ) {

                                String pName = "someone";
                                PlayerCharacter theTarget = checkId( pId );
                                if( theTarget != null )
                                    pName = theTarget.getName();
                                combatPlayers.append( thePlayer.getName() + " is fighting " +
                                pName + "\n" );
                            }
                        }
                        else {
                            MobKey key = (MobKey)thePlayer.getTarget();
                            String name = ((Mob)myState.get( GameState.MOB, key )).getName();
                            combatPlayers.append( thePlayer.getName() + " is fighting a " + name + "!" );
                        }
                    }
                }
            }
           if( nonCombat > 0 )
                comm.printMessage( playerName, Color.gray );

           if( combat > 0 )
           	comm.printMessage( combatPlayers, Color.blue.darker() );
        }
    }

    /**
     * Prints the lookup vector
     */
    private synchronized void printLookup() {

        if( lookupVector.size() == 0 )
            comm.printMessage( "There is no lookup data." );
        else {
            StringBuffer desc = new StringBuffer( "Lookup listing:\n" );
            Iterator lookupIter = lookupVector.iterator();
            while( lookupIter.hasNext() ) {
                Eoid tempId = (Eoid)lookupIter.next();
                int i = lookupVector.indexOf( tempId );
                desc.append( "(" + i + ") " + (PlayerCharacter)myState.get( GameState.PLAYER, tempId ) + "\n" );
                if( lookupIter.hasNext() )
                    desc.append( "\n" );

            }
            comm.printMessage( desc );
        }
    }

    /**
     * loads the item data froma file
     */
    private synchronized void loadItemData()
    throws Exception {
        File itemFile = new File( "data/items.dat" );
        if( itemFile.exists() ) {
            FileInputStream itemStream = new FileInputStream( itemFile );
            ObjectInputStream objStream = new ObjectInputStream( itemStream );
            myItemData = (ItemData)objStream.readObject();
            objStream.close();
            itemStream.close();
        }
        else
            throw new Exception( "Item data not found." );
    }

    private synchronized void printGear( int slot ) {
        String id = myPlayer.getGear( slot );
        if( id != null ) {
            String desc = myItemData.getDesc( id );
            String[] parts = { "body", "two hand", "right hand", "left hand" };
            comm.printMessage( parts[slot] + ": " + desc );
        }
    }

    /**
     * Determines if there is only one player of that name in the session.  If  so, this
     * returns true, if not, it prints out an error message and returns false.
     * @@param name The name of the player to check
     */
    private boolean checkPlayerName( String name ) {
        boolean retVal = false;
        int numPlayers = myState.getCount( name );
        if( numPlayers == 0 )
            comm.printError( name + " is not in this world." );
        else if( numPlayers > 1 ) {
            comm.printError( "There are too many characters of that name.  If you want " +
            "to send a private message or add this player to your friends' listing, you " +
            "must perform a lookup on that name and use the index of the lookup listing " +
            "along with an l command (lsend, ladd) to perform that action."  );
        }
        else
            retVal = true;
        return retVal;
    }

    /**
     * Sets the balance.
     * @@param balance The setting
     */
    private synchronized void setBalance( boolean balance ) {
        attemptLock();
        hasBalance = balance;
        comm.setStatus( true, hasBalance );
        unlock();
    }

    /**
     * Sets the consideringDuel variable, which indicated
     * if this user is consdiering a duel
     * @@param status The value to set the variable to
     */
    private synchronized void setConsideringDuel( boolean status ) {
        consideringDuel = status;
    }

    /**
     * Determines if the given command type is a valid in combat
     * command.
     * @@param type The type of the command
     */
    private synchronized boolean checkValidCombatCommand( int type ) {
        boolean retVal = false;
        switch( type ) {
            case Command.ATTACK:
            case Command.SAY:
            case Command.YELL:
            case Command.SEND:
            case Command.LOOK:
            case Command.CHECK_FRIENDS:
            case Command.ATTACK_NO_TARG:
            case Command.MOVE:
            case Command.LIST:
            case Command.CAST:
            case Command.CAST_NO_TARG:
            case Command.PARTITION:
            case Command.DISPLAY_PART:
            case Command.WHO:
            case Command.DO_REPORT_NOW:
            case Command.CLEAR_SCREEN:
            case Command.SURRENDER:
                retVal = true;
                break;
        }
        return retVal;

    }

    /**
     *  Kills the  mob target and prints out the spoils
     */
    private synchronized void killMob() {
        String mobName = theMobTarget.getName();
        int gold = theMobTarget.getGold();
        int exp = theMobTarget.getExp();
        String dropId = theMobTarget.getDrop();
        String desc = myItemData.getDesc( dropId );
        comm.printMessage( "You kill the " + mobName + "." );
        comm.printMessage( "You get " + gold + " gold pieces." );
        comm.printMessage( "You earn " + exp + " experience points." );
        if( desc != null ) {
            comm.printMessage( "You get a " + desc );
            myPlayer.addItem( dropId, 1 );
        }

        myPlayer.incrementExp( exp );
        myPlayer.incrementGold( gold );
        myPlayer.clearTargetData();
        DeathData theInfo = new DeathData( myPlayer.getId(),
        theMobTarget.getKey() );
        comm.clearCombatLog();
        comm.setActivePlayer( myPlayer );
        if( mySession != null )
            mySession.notifyMobDeath( theInfo, myPartNum );
        theMobTarget = null;

    }

    /**
     * Cancels an impendind duel challenge
     */
    private synchronized void cancelDuel( String reason ) {
        if( currentChallenger == null ) {
            thePlayerTarget.getHandle().declineDuel( reason, myPlayer.getId(), myPartNum );
            comm.printMessage( "You leave the area and cancel your challenge." );
            setConsideringDuel( false );
            thePlayerTarget = null;
        }
        else {
            PlayerCharacter thePlayer = (PlayerCharacter)myState.get( GameState.PLAYER, currentChallenger );
            thePlayer.getHandle().declineDuel( reason, thePlayer.getId(), myPartNum );
            comm.printMessage( "Duel challenge cancelled." );
            setConsideringDuel( false );
            currentChallenger = null;
        }
    }

    /**
     * This function checks to make sure that the directories needed by the game exist and are valid
     */
    private synchronized void checkDirectories() {
        File playerDir = new File( "players" );
        File worldDir = new File( "states" );
        File mapDir = new File( "maps" );
        File dataDir = new File( "data" );

        if( !playerDir.exists() )
            playerDir.mkdir();
        else
            if( !playerDir.isDirectory() ) {
                System.err.println( "There is a file names \"players\" but it is not " +
                "a directory. Please move this file to anoter location." );
                System.exit( 1 );
            }

        if( !worldDir.exists() 	)
            worldDir.mkdir();
        else
            if( !worldDir.isDirectory() ) {
                System.err.println( "There is a file names \"states\" but it is not " +
                "a directory. Please move this file to anoter location." );
                System.exit( 1 );
            }

        if( !mapDir.exists() )
            mapDir.mkdir();
        else
            if( !mapDir.isDirectory() ) {
                System.err.println( "There is a file names \"maps\" but it is not " +
                "a directory. Please move this file to anoter location." );
                System.exit( 1 );
            }

        if( !dataDir.exists() )
            dataDir.mkdir();
        else
            if( !dataDir.isDirectory() ) {
                System.err.println( "There is a file names \"maps\" but it is not " +
                "a directory. Please move this file to anoter location." );
                System.exit( 1 );
            }

    }

    /**
     * Called whenever the player is changed.  This function first
     * determines if there is already a world.  If so, it removes the player
     * from the  player cache, adds the new player character and then sets the myPlayer
     * variable.  If not, this loads up the default world.
     * @@param theChar the new player character to use
     */
    private synchronized void charChanged( PlayerCharacter theChar )
    throws Exception {
        // If the world is null, load up the default world.
        // This is primarily for the situation in which the user
        // has just started the game and is creating a new character
        // or loading one.
        if( myMap == null ) {

            myMap = World.getWorld( "default" );
            if( myMap == null ) {
                myMap = new World( new GameState( myHandle, myTimeManager.getTime(),
                theChar.getId(), this ) );
                myMap.saveWorldData( "default" );
            }
            myState = myMap.getState();
            myState.setPCList( this );
            stateName = "default";
            comm.setStateName( stateName );
        }

        // Save the previous player data, if need be,
        if( myPlayer != null ) {
            myPlayer.save();
            myState.remove( GameState.PLAYER, myPlayer.getId() );
            myPlayer = null;
        }

        // Clear out the player cache, then add the player.
        // Also, set up the state to use this player's id.
        // Also set up the map viewer.
        myState.clear( GameState.PLAYER );
        myState.add( GameState.PLAYER, theChar );
        myPlayer = (PlayerCharacter)myState.get( GameState.PLAYER, theChar.getId() );
        myState.setId( myPlayer.getId() );
        myMap.setViewer( myMapWindow );

        // Attempt to load the friends' listing
        myFriendsList = FriendsList.loadFromFile();
        if( myFriendsList == null || !myFriendsList.getPlayerId().equals( myPlayer.getId() ) )
            myFriendsList = new FriendsList();

        myTimeManager.start();

        // All set!  print out the room and start things going
        comm.setActivePlayer( myPlayer );
        comm.clear();
        myMap.warp( 0, 0 );
        printCurrentRoom();
    }
d1841 37
a1877 2
        /*
         * Checks to make sure the user can perform the attack
d1880 227
a2106 199
    private String checkAttack( int atkType ) {
        String retVal = null;
        // A player can kick or punch without a weapon,
        // but to perform a slash or a thrust attack, they
        // must have something armed.
        if( atkType == StringIntCommand.KICK )
            retVal = new String( "kick" );
        else if( atkType == StringIntCommand.PUNCH )
            retVal = new String( "punch" );
        else {
            retVal = myPlayer.getEquippedWeapon();
            if( retVal == null )
                comm.printError( "You cannot perform that attack without a weapon." );
        }
        return retVal;
    }

    /**
     * This returns whether or not te player can use the spell indicated.
     * To use a spell, the player must have the scroll in their inventory
     * and must be of the right level
     * @@param splId The id of the spell
     */
    private boolean checkSpell( String id ) {
        boolean retVal = false;
        int amount = myPlayer.getItemAmount( id );
        int level = myItemData.getSpellLevel( id );

        // A player can not cast a spell if they are a fighter,
        // not of the correct level, or have none in their
        // inventory
        if( !myItemData.canEquip( id, myPlayer.getPlayerClass() ) )
            comm.printError( "You cannot cast spells." );
        else if( level > 0 &&
        ( amount > 0 && myPlayer.getLevel() >= level ) )
            retVal = true;
        else {
            comm.printError( id + ": You can not cast that spell. " +
            "You either do not meet the level requirement or you do not have " +
            "a scroll of that spell in your inventory." );
        }

        return retVal;
    }

    /**
     * Attack the player's mob target
     * @@param damage the amount of damage to do
     */
    private void attackMob( int damage ) {
        theMobTarget.damageMob( damage );
        String mobName = theMobTarget.getName();
        comm.printCombatMessage(
        "You attack the " + mobName + " for " + damage + " damage!",
        Color.yellow.darker(), false );
        if( !theMobTarget.isAlive() )
            killMob();
    }

    /**
     * Attack a player
     * @@param damage the damage to do
     */
    private void attackPlayer( int damage ) {
        thePlayerTarget.getHandle().printAttack( damage, myPartNum,
        myPlayer.getId() );
        comm.printCombatMessage( "You attack " + thePlayerTarget.getName() + "!",
        Color.blue.darker(), false );
    }

    /**
     * Starts the balance timer
     * @@param id The id of the weapon to look at
     */
    private void startBalanceTimer( String id ) {
        hasBalance = false;
        comm.setStatus( true, hasBalance );
        long timer = myItemData.getWeaponDelay( id );
        attackTimer.start( timer );
    }

    /**
     * Determins whether or not the player can fight
     * also, this will clear out duel data if the player
     * has been challenged to a fight
     * @@param nonTarget true iff this came from a non target command
     *
     */
    private boolean canAttack( boolean nonTarget ) {
        boolean retVal = true;

        // If the player is already fighting something, they must use
        // the non combat version of the command ('sl' as opposed to 'sl <target>'
        // Also, a player may not fight something if they have issued a duel
        // challenge.
        if( myPlayer.isInCombat() && !nonTarget ) {
            retVal = false;
            comm.printError( "You are already in combat. " +
            "Please use the non-target version of these commands." );
        }
        else if( consideringDuel && thePlayerTarget != null ) {
            retVal = false;
            comm.printError( "You have issued a duel challenge and may not attack." );
        }

        //If the player has been issued a duel challenge, clear it
        if( consideringDuel && currentChallenger != null ) {
            PlayerCharacter temp =
            (PlayerCharacter)myState.get( GameState.PLAYER, currentChallenger );
            if( temp != null )
                temp.getHandle().declineDuel
                ( " engages in combat.", myPlayer.getId(), myPartNum );
            consideringDuel = false;
            currentChallenger = null;
        }
        return retVal;
    }

    /**
     * Begins fight ont he player's mob target
     * @@param dmgId The id of the weapon to use
     */
    private void startFight( String dmgId ) {
        if( theMobTarget != null ) {
            // Get the timestamp, then register the two combatants
            Date ts = theMobTarget.startAttack( myPlayer.getId(), myPlayer.getLocation() );
            myPlayer.registerTarget( theMobTarget.getKey() );
            mySession.registerAttacker
            ( myPlayer.getLocation(), theMobTarget.getKey(),
            myPlayer.getId(), ts, myPartNum );

            // Deduct from the monster the amount of damage the player did.
            int damage = myItemData.getCombatBonus( dmgId );
            attackMob( damage );
            startBalanceTimer( dmgId );
            comm.setTarget( theMobTarget.getName() );
        }
    }

    /**
     * This helper function is used whenever a command comes in to perform
     * something that another player does.  Basically,
     * it checks to see if the other player is in the state.  If so,
     * is returns it, if not, it informs the session that an error has been detected
     * and reports back null
     * @@param pId The id of the player to check
     */
    private PlayerCharacter checkId( Eoid pId ) {
        PlayerCharacter retVal = null;
        if( myState.has( GameState.PLAYER, pId ) )
            retVal = (PlayerCharacter)myState.get( GameState.PLAYER, pId );
        else
            mySession.errorDetected( myPlayer.getId(), myPartNum );

        return retVal;
    }

    /**
     * This function is primarily used in the notifyXDeath functions.
     * It clears the user's local combat information, and then reports
     * an error to it's session
     */
    private void endFightError() {
        myPlayer.clearTargetData();
        thePlayerTarget = null;
        theMobTarget = null;
        comm.clearCombatLog();
        comm.printError( "Your fight has been ended due to a " +
        "synchronization error." );
        mySession.errorDetected(  myPlayer.getId(), myPartNum );
    }

    /**
     * This function checks to see if the player is at the given location
     * if not, it moves them there
     * @@param thePlayer The player to check
     * @@param theLoc The location they should be at
     */
    private void checkLocation( PlayerCharacter thePlayer, XYloc theLoc ) {
        if( !thePlayer.getLocation().equals( theLoc ) && theLoc != null )
            myMap.performWarp( thePlayer.getId(), theLoc );
    }
    /********************************************************************************************************************************/
    /**.
     * This is the primary function of the GameSystem, the execute function.
     * The purpose of this function is to execute the user's command to the system,
     * which has been packaged by the Parser.
     * @@param command The command to execute
     */
    public synchronized void execute( Command command )
    throws Exception {
        attemptLock();
        // If there is no player, a user may only execute a create or load player command
        if( myPlayer == null &&
        ( command.getType() != Command.CREATE &&
        command.getType() != Command.LOAD  &&
        command.getType() != Command.INVALID_COMMAND )
        ) {
            comm.printError( "Cannot execute other commands without having a character." +
d2108 1114
a3221 978
        }
        // users can only perform certain commands while in combat
        else if( ( myPlayer != null && myPlayer.isInCombat() )
        && !checkValidCombatCommand( command.getType() ) ) {
            comm.printError( "You are in combat and may not perform that command!" );
        }
        else {
            switch( command.getType() ) {
                case Command.CREATE: {

                    if( inSession )
                        comm.printError( "You are already in a session." );
                    else {
                        // Character creation
                        PlayerCharacter temp = PlayerCharacter.loadCharacterDataFromFile
                        ( mySession, ((PlayerCreationCommand)command).name );
                        if( temp != null ) {
                            // If a character already exists with the given name,
                            // the user may not reuse that name
                            comm.printError( "That character already exists." +
                                             "Please delete the character or create one " +
                            "with a different name");
                        }
                        else {

                            // Create the new character, and then place them into the
                            // default world
                            temp = PlayerCharacter.createNewCharacter(
                            (PlayerCreationCommand)command, myHandle );
                            if( temp != null )
                                charChanged( temp );
                            else {
                                String className = ((PlayerCreationCommand)command).clas;
                                comm.printError( className + ": invalid player class." );
                            }
                        }
                    }

                }
                break;
                case Command.LOOK: {
                    printCurrentRoom();
                }
                break;
                case Command.LIST:
                    comm.printMessage( myPlayer );
                    break;
                case Command.MOVE: {
                    // You can't move if you are in combat with another player, in a house,
                    // or have just taken an action
                    if( !hasBalance )
                        comm.printError( "You are regaining your balance and may not move yet." );
                    else if( myPlayer.isInHouse() )
                        comm.printError( "You are in a house and cannot move in any direction.  You must "+
                        "leave the house first." );
                    else if( myPlayer.isInCombat() && theMobTarget == null )
                        comm.printError( "You are engaged in combat with another player and can not leave " +
                        "the area until combat is done." );
                    else {
                        // Otherwise, if the player is in combat with a mob and the move,
                        // they are running from the mob
                        if( myPlayer.isInCombat() && thePlayerTarget == null ) {
                            Mob theMob = (Mob)myState.get( GameState.MOB,
                            (MobKey)myPlayer.getTarget() );
                            theMob.stopAttack( );
                            myPlayer.clearTargetData();
                            comm.clearCombatLog();
                            comm.printMessage( "You disengage combat with " + theMob.getName() + "!" );
                        }

                        // Have the map create the move data
                        UserMove movement = myMap.doPlayerMove( ((IntCommand)command).getIntData() );
                        if( movement != null ) {
                            myPlayer.updateLocation( movement.getLoc( MoveData.TO ) );

                            // Prints out the room, finish filling in the data
                            printCurrentRoom();
                            movement.setUser( myPlayer.getId() );

                            // If the user is considering a duel, cancel it
                            if( consideringDuel )
                                cancelDuel( " has left the area. Challenge Cancelled." );

                            // Finally inform everyone of the move
                            if( mySession != null ) {
                                mySession.processMove( movement, myPartNum );
                            }
                        }
                        else
                            comm.printError( "You can not move in that direction." );
                    }
                }

                break;
                case Command.YELL: {
                    comm.printMessage( "You yell, \"" + ((StringCommand)command).getStringData() + "\"" );
                    SayData sd = new SayData( myPlayer.getId(), myMap.getCurrentPlayerLocation(),
                    ((StringCommand)command).getStringData()  );
                    if( mySession != null )
                        mySession.yell( sd, myPartNum );
                }
                break;
                case Command.CREATE_GAME: {
                    if( inSession )
                        comm.printError( "You are already in a session." );
                    else if( leftSession )
                        comm.printError( "You have left your session or have been removed.  Please " +
                        "exit out of the game before trying to create a new one." );
                    else {
                        // Set up the Session handle, create the merchants and
                        // the mobs, start the player refreshers
                        inSession = true;
                        mySessionName = ((StringCommand)command).getStringData();
                        mySession = (Game)M2MI.getMultihandle( Game.class );
                        ((Multihandle)mySession).attach( this );
                        myMap.spawnMerchants( this );
                        myMap.spawnMobs( this );
                        scheduleNormalReport();
                        myPlayerRefresher = new PlayerRefresher( myPlayer.getId(), mySession );
                        myPlayerRefresher.start();
                        comm.printMessage( "\nGame " + mySessionName + " created!" );
                    }
                }
                break;

                case Command.FIND_GAMES: {
                    // Can't look for a new game if the user is one already.
                    // Also, after leaving a game, they must quit out of the program first.
                    if( inSession )
                        comm.printError( "You must first leave your current session before joining a new one." );
                    else if( leftSession )
                        comm.printError( "You have left your session, or have been removed.  Please" +
                        "quit the game before trying to find a new one." );
                    else {
                        comm.printMessage( "Looking for games" );
                        comm.disable();
                        GameChooser gameChooser = new GameChooser();
                        sessionFinder = new SessionFinder( gameChooser );
                        sessionFinder.export();
                        GameChooserWindow gameChooserWindow = new GameChooserWindow( gameChooser, this );
                        gameChooserWindow.setVisible( true );
                    }
                }
                break;
                case Command.LEAVE_SESSION: {
                    if( !inSession )
                        comm.printError( "You are not currently in a session." );
                    else {
                        comm.printMessage( "You leave your session." );
                        leave();
                    }
                }
                break;
                case Command.WHO: {

                    comm.printMessage( "\nPlayer currently in the session: " );
                    comm.printMessage( myState.getPlayerCacheString() );

                }
                break;
                case Command.SAY: {
                    comm.printMessage( "You say, \"" + ((StringCommand)command).getStringData() + "\"" );
                    if( mySession != null ) {
                        SayData myMessage = new SayData( myPlayer.getId(),myMap.getCurrentPlayerLocation(),
                        ((StringCommand)command).getStringData() );
                        mySession.say( myMessage, myPartNum );
                    }
                }
                break;
                case Command.DIG_POND: {

                    if( myMap.getCurrentRoomType() == Room.WATER )
                        comm.printError( "You can not dig a pond where there is water!" );
                    else if( myMap.digPond() == false )
                        comm.printError( "There is already a pond here." );

                    else {

                        comm.printMessage( "You dig a small pond in the earth." );
                        if( mySession != null )
                            mySession.setPond( myMap.getCurrentPlayerLocation(), myPlayer.getId(), myPartNum );
                    }
                }
                break;
                case Command.HOUSE_CREATE: {
                    if( !myState.has( GameState.HOUSE, myPlayer.getId() ) ) {
                        if( myMap.getCurrentRoomType() != Room.WATER ) {
                            House newHouse = new House( myPlayer,
                            (HouseCreationCommand)command );
                            myMap.placeHouse( newHouse );
                            comm.printMessage( "You place your house at " + newHouse.getLocation() );
                            if( mySession != null )
                                mySession.addHouse( newHouse, myPartNum );
                        }
                        else
                            comm.printError( "You may not build a house on water!" );
                    }
                    else {
                        House temp = (House)myState.get( GameState.HOUSE, myPlayer.getId() );
                        comm.printError( "You already have a house at " + temp.getLocation() );
                    }
                }
                break;
                case Command.SESSION_COMMAND: {

                }
                break;
                case Command.TIME: {
                    String times[] = { "early morning", "morning", "early afternoon",
                    "late afternoon", "early evening", "evening" };
                    String timeMessage = new String( "It is " + times[myTimeManager.getTime()] + "." );
                    comm.printMessage( timeMessage );
                }
                break;
                case Command.GOTO: {
                    // The coordinates the player gives must be withing the bounds of the map.
                    int x = ((GotoCommand)command).getLoc().x;
                    int y = ((GotoCommand)command).getLoc().y;
                    if( ( 0 <= x && x < myMap.getMaxX() ) &&
                    ( 0 <= y && y < myMap.getMaxY() ) ) {
                        // Don't warp if the player is staying in the same location
                        if( !myMap.getCurrentPlayerLocation().equals( new XYloc( x, y ) ) ) {
                            XYloc temp = new XYloc( myMap.getCurrentPlayerLocation() );
                            comm.printMessage( "Warping you to location (" + x + ", " + y + ")" );
                            myMap.warp( x, y );
                            printCurrentRoom();
                            if( mySession != null )
                                mySession.warp( myPlayer.getId(), temp,
                                myMap.getCurrentPlayerLocation(), myPartNum );
                        }

                    }
                    else
                        comm.printError( "You cannot warp to that location." );
                }
                break;
                case Command.LIST_WARES: {
                    // This is simple: get the merchant type, then use the ItemData
                    // object to get the list of all the items that merchant sells.
                    int type = myMap.getMerchantType();
                    if( type != -1 ) {
                        comm.printMessage( "\nThe merchant has the following items for sale: " );
                        Iterator itemId = myItemData.getIdVector( type ).iterator();
                        while( itemId.hasNext() ) {
                            String id = (String)itemId.next();
                            String desc = myItemData.getDesc( id );
                            int cost = myItemData.lookupCost( id );
                            if( cost > 0 )
                                comm.printMessage( id + ": " + desc + ", cost " + cost + "gold pieces" );
                        }
                    }
                    else
                        comm.printError( "There is no merchant here." );
                }
                break;
                case Command.BUY: {
                    int type = myMap.getMerchantType();
                    if( type != -1 ) {
                        String id = ((StringIntCommand)command).getStringData();
                        int amount = ((StringIntCommand)command).getIntData();
                        Vector merchItems = myItemData.getIdVector( type );
                        // Obviously, in order to buy something, them merchant must
                        // have the item in stock, and the user must be able to afford
                        // the quantity they have specifed.
                        if( merchItems.indexOf( id ) != -1 ) {
                            int totalCost = amount * myItemData.lookupCost( id );
                            if( myPlayer.canAfford( totalCost ) ) {
                                // Adjust the user's inventory and gold
                                myPlayer.addItem( id, amount );
                                myPlayer.decrementGold( totalCost );
                                String desc = myItemData.getDesc( id );
                                comm.printMessage
                                ( "You buy the " + desc + " for " + totalCost +
                                " gold pieces." );
                                comm.setActivePlayer( myPlayer );
                            }
                            else
                                comm.printMessage( "You can't afford that!" );
                        }
                        else
                            comm.printMessage( "That item is not for sale." );
                    }
                    else
                        comm.printError( "There is no merchant here." );
                }
                break;
                case Command.SELL: {
                    int type = myMap.getMerchantType();
                    if( type != -1 ) {
                        String id = ((StringIntCommand)command).getStringData();
                        int amount = ((StringIntCommand)command).getIntData();
                        int sellAmount = myPlayer.getItemAmount( id );
                        // To be able to sell something, the user must
                        // have at least one in their inventory.
                        if( sellAmount > 0 ) {
                            int finalAmount = 0;
                            if( amount > sellAmount )
                                finalAmount = sellAmount;
                            else
                                finalAmount = amount;
                            // Again, adjust the user's inventory and gold space
                            myPlayer.addItem( id, -1 * finalAmount );
                            int amountEarned = finalAmount * myItemData.lookupSellValue( id );
                            myPlayer.incrementGold( amountEarned );
                            comm.printMessage( "You sell " + finalAmount + " of " +
                            myItemData.getDesc( id ) + " for " + amountEarned +
                            " goldPieces." );
                            comm.setActivePlayer( myPlayer );
                        }
                        else
                            comm.printMessage( "You do not have any of that item." );
                    }
                    else
                        comm.printMessage( "There is no merchant here." );
                }
                break;
                case Command.LOOKUP: {
                    // The lookup gets all the players that have the given name and places
                    // them into a list with their player ID
                    String pName = ((StringCommand)command).getStringData();
                    comm.printMessage( "Performing lookup for " + pName );
                    lookupVector.clear();
                    myState.doLookup( pName, lookupVector );
                    printLookup();
                }
                break;
                case Command.ADD: {
                    // Adds a player to the friends' list
                    String pName = ((StringCommand)command).getStringData();
                    if( checkPlayerName( pName ) ) {
                        myFriendsList.addPlayer( myState.getPlayerByName( pName ) );
                        comm.printMessage( pName + " has been added to your friends\' "
                        + " listing." );
                    }

                }
                break;
                case Command.SEND: {
                    String pName = ((SendCommand)command).getUserName();
                    if( checkPlayerName( pName ) ) {
                        Game theHandle = myState.getPlayerByName( pName ).getHandle();
                        theHandle.sendPM( myPlayer.getId(), ((SendCommand)command).getStringData(), myPartNum );
                        comm.printMessage( "You send, \"" + ((SendCommand)command).getStringData() +
                        "\" to " + pName + "." 	);
                    }
                }
                break;
                case Command.INVENTORY: {
                    // Print out the user's inventory and gold
                    comm.printMessage( "\nYou have the following items in your inventory: " );
                    comm.printMessage( myPlayer.getCurrentGold() + " gold pieces." );
                    Iterator items = myPlayer.getInventoryKeys();
                    while( items.hasNext() ) {
                        String id = (String)items.next();
                        int amount = myPlayer.getItemAmount( id );
                        String desc = myItemData.getDesc( id );
                        if( amount > 0 )
                            comm.printMessage( id + ": " + desc +  ", number: " + amount );
                    }

                    // Print out the user's equipment
                    comm.printMessage( "\nYou are equiped in the follow gear: " );
                    printGear( PlayerCharacter.BODY );
                    printGear( PlayerCharacter.RIGHT_HAND );
                    printGear( PlayerCharacter.LEFT_HAND );
                    printGear( PlayerCharacter.TWO_HAND );
                }
                break;
                case Command.CHECK_FRIENDS: {
                    // This simply prints out whether or not a player on the user's
                    // friends' listing is in the same sessin as she is.
                    if( myFriendsList.size() == 0 )
                        comm.printMessage( "There are no players on your friends listing." );
                    else {
                        Iterator friends = myFriendsList.getPlayers();
                        int i = 0;
                        while( friends.hasNext() ) {
                            Eoid tempKey = (Eoid)friends.next();
                            String name = myFriendsList.getName( tempKey );
                            if( myState.has( GameState.PLAYER, tempKey )  )
                                comm.printMessage(
                                "(" + i + ") " + name + " (" + tempKey + ") " +
                                " is in this session." );
                            else
                                comm.printMessage(
                                "(" + i + ") " + name + " (" + tempKey + ") "
                                + " is not in this session." );
                            i++;
                        }
                    }
                }
                break;
                case Command.LCHECK: {
                    // This allows a player to see if a player on the lookup listing
                    // is in their friends' listing.
                    IntCommand iComm = (IntCommand)command;
                    Eoid playerId = null;
                    if( lookupVector.size() > iComm.getIntData() )
                        playerId = (Eoid)lookupVector.elementAt( iComm.getIntData() );

                    if( myFriendsList.hasPlayer( playerId ) ) {
                        comm.printMessage( myFriendsList.getName( playerId ) + " (" +
                        playerId + ") is in your friends' listing." );
                    }
                    else {
                        comm.printMessage( myFriendsList.getName( playerId ) + " (" +
                        playerId + ") is not in your friends' listing." );
                    }
                }
                break;
                case Command.LSEND: {
                    // A send command, but this sends the message to the user
                    // with associated with the given index in the lookup listing, rather than
                    // the give name.
                    if( lookupVector.size() <= 0 )
                        comm.printError( "There is no lookup data.  Please perform a lookup." );
                    else {
                        SendCommand sComm = (SendCommand)command;
                        Eoid playerId = null;
                        if( lookupVector.size() > sComm.getLookupIndex() ) {
                            playerId = (Eoid)lookupVector.elementAt( sComm.getLookupIndex() );
                            PlayerCharacter sendPlayer =
                            (PlayerCharacter)myState.get( GameState.PLAYER, playerId );
                            if( sendPlayer != null ) {
                                Game sendHandle = sendPlayer.getHandle();
                                sendHandle.sendPM( myPlayer.getId(),
                                sComm.getStringData(), myPartNum );
                                comm.printMessage
                                ( "You send, \"" + sComm.getStringData() + "\" to " +
                                sendPlayer.getName() );
                            }
                        }
                        else
                            comm.printError( "That index is invalid." );
                    }
                }
                break;
                case Command.LADD: {
                    // Adds the user at the specified position in the lookup listing
                    // to the user's friends' listing.
                    if( lookupVector.size() <= 0 )
                        comm.printError( "There is no lookup data.  Please perform a lookup." );
                    else {
                        IntCommand iComm = (IntCommand)command;
                        Eoid playerId = null;
                        if( lookupVector.size() > iComm.getIntData() ) {
                            playerId = (Eoid)lookupVector.elementAt( iComm.getIntData() );
                            PlayerCharacter temp = (PlayerCharacter)myState.get( GameState.PLAYER, playerId );
                            if( temp != null ) {
                                myFriendsList.addPlayer( temp );
                                comm.printMessage
                                ( temp.getName() + " has been added from your friends' listing." );
                            }
                        }
                        else
                            comm.printError( "That index is invalid." );
                    }

                }
                break;
                case Command.LLIST: {
                    printLookup();
                }
                break;
                case Command.REMOVE: {
                    // Removes the player from the friends' listing.
                    String name = myFriendsList.removePlayer( ((IntCommand)command).getIntData() );
                    if( name != null )
                        comm.printMessage( name + "  has been removed from your friends' listing." );
                    else
                        comm.printError( "That index is not valid." );
                }
                break;

                case Command.EQUIP: {
                    StringCommand eComm = (StringCommand)command;
                    String id = eComm.getStringData();
                    int slot = -1;

                    // First check to make sure the player has the given item
                    if( myPlayer.getItemAmount( id ) <= 0 )
                        comm.printError( "You do not have that item." );
                    else if( !myItemData.canEquip( id, myPlayer.getPlayerClass() ) )
                        //Then check to make sure they can equip it
                        comm.printError( "Your class may not equip this item." );
                    else {
                        // Determine which slot (if any) the given item
                        // gets equipped to
                        switch( myItemData.getItemType( id ) ) {
                            case ItemData.ARMOR:
                                slot = PlayerCharacter.BODY;
                                break;
                            case ItemData.WEAPON_2_HAND:
                                slot = PlayerCharacter.TWO_HAND;
                                break;
                            case ItemData.WEAPON_1_HAND:
                                slot = PlayerCharacter.RIGHT_HAND;
                                break;
                        }
                        if( slot == -1 )
                            comm.printError( "You can't equip that item!" );
                        else {
                            // Equip the item and tell the user
                            myPlayer.equipItem( id, slot );
                            String desc = myItemData.getDesc( id );
                            if( slot == PlayerCharacter.BODY )
                                comm.printMessage( "You put on " + desc );
                            else
                                comm.printMessage( "You begin wearing " + desc );
                        }
                    }
                }
                break;
                case Command.ATTACK: {
                    int type = ((StringIntCommand)command).getIntData();
                    String weapon = checkAttack( type );

                    // So far, everything is good.  Begin combat on the monster
                    if( canAttack( false ) && weapon != null ) {
                        // Ensure the mob is valid (exists and is not fighting already
                        String mobName = ((StringIntCommand)command).getStringData();
                        theMobTarget = myMap.getFreeMob( mobName );
                        if( theMobTarget == null )
                            comm.printError( "Either that mob does not exists, or all members of that species " +
                            "are already in combat in this area." );
                        else
                            startFight( weapon );
                    }
                    else
                        comm.printError( "You may not perform that attack without a weapon." );

                }
                break;
                case Command.ATTACK_NO_TARG: {
                    int type = ((IntCommand)command).getIntData();
                    String weapon = checkAttack( type );
                    if( weapon != null ) {
                        int damage = myItemData.getCombatBonus( weapon );
                        if( hasBalance ) {
                            if( thePlayerTarget == null && theMobTarget == null )
                                comm.printMessage( "You visciously attack the air around you!" );
                            else if( myPlayer.hasMobTarget() )
                                attackMob( damage );
                            else
                                attackPlayer( damage );
                            startBalanceTimer( weapon );
                        }
                        else
                            comm.printCombatMessage( "You are regaining your balance after the last" +
                            " attack!", Color.yellow.darker(),false );
                    }
                }
                break;
                case Command.CHALLENGE: {
                    boolean canAttack = true;
                    // If the player is in a house they may not challenge someone, also
                    // a player may only have challenge issed at on time.
                    if( myPlayer.isInHouse() ) {
                        comm.printError( "You may not challenge while in a house." );
                        canAttack = false;
                    }
                    if( consideringDuel ) {
                        comm.printError( "You have already issued one challenge." );
                        canAttack = false;
                    }

                    if( !myMap.currentAreaHasPlayers() ) {
                        comm.printError( "There are no players in this room." );
                        canAttack = false;
                    }

                    if( canAttack ) {

                        // What this does is perform a lookup on all users of the given name
                        // in the same room as the player. If there are more than one, the user
                        // and her target must move to another room to fight each other.
                        String pName = ((StringCommand)command).getStringData();
                        Iterator players = myMap.getCurrentAreaPlayers();
                        int count = 0;
                        Vector ids = new Vector();
                        while( players.hasNext() ) {
                            Eoid pId = (Eoid)players.next();
                            if( pName.equals( ((PlayerCharacter)myState.get( GameState.PLAYER, pId )).getName() ) )
                                ids.add( pId );
                        }
                        if( ids.size() == 0 ) {
                            comm.printError( "There are no players of that name here." );
                        }
                        else if( ids.size() > 1 ) {
                            comm.printError( "There are too many players here of that name." +
                            "You and the player you wish to fight must move to a new location." );
                        }
                        else {
                            Eoid pId = (Eoid)ids.elementAt( 0 );
                            thePlayerTarget = (PlayerCharacter)myState.get( GameState.PLAYER, pId );

                            // If the other player is already fighting or is in ahouse
                            // the user may not challenge them.
                            if( thePlayerTarget.isInCombat() ) {
                                comm.printMessage( "That player is in combat already." );
                                thePlayerTarget = null;
                            }
                            else if( thePlayerTarget.isInHouse() ) {
                                comm.printMessage( "You may not challenge someone while " +
                                "(s)he is in a house." );
                            }
                            else {
                                Game theGame = thePlayerTarget.getHandle();
                                theGame.requestDuel( myPlayer.getId(), myPartNum );
                                comm.printMessage( "You challenge " + thePlayerTarget.getName() +
                                " to a duel!" );
                                setConsideringDuel( true );
                            }
                        }
                    }
                }
                break;
                case Command.DECLINE: {
                    // This declines another player's duel challenge.
                    if( !consideringDuel )
                        comm.printError( "You are not considering a duel." );
                    else if( consideringDuel && currentChallenger == null )
                        comm.printError( "You have issued a challenge, command ignored." );
                    else {
                        String pName = ((PlayerCharacter)myState.get( GameState.PLAYER, currentChallenger )).getName();
                        Game theHandle =((PlayerCharacter)myState.get( GameState.PLAYER, currentChallenger )).getHandle();
                        comm.printMessage( "You have declined " + pName + "\'s challenge." );
                        theHandle.declineDuel( " has declined your challenge.", myPlayer.getId(),
                        myPartNum );
                        setConsideringDuel( false );
                        currentChallenger = null;
                    }
                }
                break;
                case Command.ACCEPT: {
                    // This accepts the player's duel challenge and places the local player into
                    // combat.
                    if( !consideringDuel )
                        comm.printError( "You are not considering a duel." );
                    else if( consideringDuel && currentChallenger == null )
                        comm.printError( "You have issued a duel challenge.  Command ignored." );
                    else {
                        PlayerCharacter theChallenger = checkId( currentChallenger );
                        String pName = theChallenger.getName();
                        Game theHandle = theChallenger.getHandle();
                        theHandle.acceptDuel( myPlayer.getId(), myPartNum );
                        thePlayerTarget = theChallenger;
                        myPlayer.registerTarget( currentChallenger );
                        currentChallenger = null;
                        mySession.notifyFight( thePlayerTarget.getId(), myPlayer.getId(),
                        myMap.getCurrentPlayerLocation(), myPartNum );
                        setConsideringDuel( false );
                        comm.printMessage( "You have accepted " + pName + "\'s challenge. Begin fighting!" );
                        comm.setTarget( thePlayerTarget.getName() );
                    }
                }
                break;
                case Command.MAP: {
                    myMapWindow.setVisible( !myMapWindow.isVisible() );
                }
                break;
                case Command.LOAD: {
                    if( inSession )
                        comm.printError( "You are in a session and may not change any data." );
                    else {
                        StringIntCommand siComm = (StringIntCommand)command;
                        switch( siComm.getIntData() ) {
                            case StringIntCommand.PLAYER: {
                                String pName = siComm.getStringData();
                                PlayerCharacter loadPlay =
                                PlayerCharacter.loadCharacterDataFromFile
                                ( myHandle, pName );
                                if( loadPlay == null )
                                    comm.printError( "Player " + pName + " not found." );
                                else {
                                    PlayerCharacter temp =  PlayerCharacter.createNewCharacter( loadPlay, myHandle );
                                    charChanged( temp );
                                }
                            }
                            break;
                            case StringIntCommand.MAP: {
                                String fileName = new String
                                ( "maps/" + siComm.getStringData() + ".map" );
                                File theFile = new File( fileName );
                                if( myPlayer == null )
                                    comm.printError( "You may not execute this command now." );
                                else if( !theFile.exists() )
                                    comm.printError( fileName + ": map file not found." );
                                else {
                                    myState.clear();
                                    WorldConfiguration theConfig = new
                                    WorldConfiguration( theFile );
                                    myMap.createWorld( theConfig );
                                    comm.clear();
                                    stateName = new String( "(No state name.)");
                                    comm.setStateName( stateName );
                                    myMap.warp( 0, 0 );
                                    printCurrentRoom();
                                    myState.add( GameState.PLAYER, myPlayer );
                                    myPlayer = (PlayerCharacter)myState.get( GameState.PLAYER,
                                    myPlayer.getId() );
                                }

                            }
                            break;
                            case StringIntCommand.WORLD: {


                                if( myPlayer == null )
                                    comm.printError( "You may not execute this command now." );
                                else {
                                    stateName = siComm.getStringData();
                                    World temp = World.getWorld( stateName );
                                    if( temp == null )
                                        comm.printError( "State not found." );
                                    else {
                                        myMap = temp;
                                        myState = myMap.getState();
                                        myState.add( GameState.PLAYER, myPlayer );
                                        myState.setPCList( this );
                                        myState.setId( myPlayer.getId() );

                                        myMap.setViewer( myMapWindow );
                                        comm.clear();
                                        comm.setStateName( stateName );
                                        myMap.warp( 0, 0 );
                                        myMap.setViewer( myMapWindow );
                                        printCurrentRoom();

                                        myPlayer = (PlayerCharacter)myState.get( GameState.PLAYER,
                                        myPlayer.getId() );
                                    }
                                }
                            }
                            break;
                        }

                    }
                }
                break;
                case Command.SAVE: {
                    StringIntCommand siComm = (StringIntCommand)command;
                    switch( siComm.getIntData() ) {
                        case StringIntCommand.WORLD: {
                            if( inSession )
                                comm.printError( "You must leave the session before saving the state " +
                                "data." );
                            else {

                                String fileName = "states/" + siComm.getStringData() + ".dat";
                                File theFile = new File( fileName );
                                if( theFile.exists() )
                                    comm.printError( fileName + ": file already exists." );
                                else {
                                    stateName = siComm.getStringData();
                                    comm.setStateName( stateName );
                                    myMap.saveWorldData( stateName );
                                    comm.printMessage( "Session saved!");
                                }


                            }
                        }
                        break;
                        case StringIntCommand.MAP: {
                            String fileName = "maps/" + siComm.getStringData() + ".map";
                            File theFile = new File( fileName );
                            if( theFile.exists() )
                                comm.printError( fileName + ": file already exists." );
                            else {
                                if( myState.getConfig() != null ) {
                                    FileWriter fw = new FileWriter( theFile );
                                    BufferedWriter writer = new BufferedWriter( fw );
                                    String data =  myState.getConfig().toString();
                                    writer.write( data, 0, data.length() );
                                    writer.close();
                                    fw.close();
                                    comm.printMessage( "Map saved! ");
                                }
                            }
                        }
                    }
                }
                break;
                case Command.SAVE_QUICK: {
                    if( inSession )
                        comm.printError( "You must leave the session before saving." );
                    else {
                        if( stateName == null )
                            comm.printError( "You must first specify a state name using the " +
                            "\"save world <state-name>\" command." );
                        else
                            myMap.saveWorldData( stateName );
                    }
                    comm.printMessage( "Session saved!" );
                }
                break;
                case Command.STATE_REMOVE: {
                    if( !inSession )
                        myMap.remove( ((IntCommand)command).getIntData() );
                    else
                        comm.printError( "You are in a session and can not remove that object." );
                }
                break;
                case Command.USE: {
                    String id = ((StringCommand)command).getStringData();
                    if( myPlayer.getItemAmount( id ) == 0  )
                        comm.printError( "You do not have any of that item." );
                    else {
                        int healAmount = myItemData.getHealAmount( id );
                        if( healAmount == -1 )
                            comm.printError( "You may not use that item." );
                        else {
                            if( myItemData.getHealWhich( id ) == ItemData.HEALTH )
                                myPlayer.adjustHP( healAmount );
                            myPlayer.addItem( id, -1 );
                            comm.printMessage( "You use the " + myItemData.getDesc( id ) );
                            comm.setActivePlayer( myPlayer );
                        }
                    }
                }
                break;
                case Command.PARTITION: {
                    if( inSession ) {
                        int part = ((IntCommand)command).getIntData();
                        myPartNum = part;
                        myState.setPartNum( part );
                        myPlayerRefresher.setPartition( part );
                        comm.printMessage
                        ( "Partition set to " + myPartNum );
                    }
                    else
                        comm.printError( "You need to be in a session." );
                }
                break;
                case Command.ENTER:
                case Command.HOUSE_ENTER: {
                    int houseNum = ((IntCommand)command).getIntData();
                    if( myMap.enterHouse( houseNum ) ) {
                        printCurrentRoom();
                        if( inSession )
                            mySession.moveHouse( myPlayer.getId(), myMap.getHouseId(),
                            true, myPartNum );

                    }
                    else
                        comm.printError( "You can not enter that house." );
                }
                break;
                case Command.CAST_NO_TARG: {
                    String splId = ((StringCommand)command).getStringData();
                    if( checkSpell( splId ) ) {
                        if( hasBalance ) {


                            if( myPlayer.isInCombat() ) {
                                comm.printCombatMessage( "You cast a spell!", Color.black, true );
                                int damage = myItemData.getCombatBonus( splId );
                                if( myPlayer.hasMobTarget() )
                                    attackMob( damage );
                                else
                                    attackPlayer( damage );

                            }
                            else
                                comm.printMessage( "You cast a spell into the air around you!" );
                        }
                        else
                            comm.printError( "You are recovering from your last cast!" );

                        startBalanceTimer( splId );
                    }
                }
                break;
                case Command.CAST: {
                    String splId = ((CastCommand)command).getSpellId();
                    String mobId = ((CastCommand)command).getMobName();
                    if( canAttack( false ) && checkSpell( splId ) ) {
                        theMobTarget = myMap.getFreeMob( mobId );
                        if( theMobTarget != null )
                            startFight( splId );
                        else
                            comm.printError( "That mob does not exist, or all creatures " +
                            "of that type are in combat already in this area." );

                    }
                }
                break;
                case Command.LEAVE_HOUSE: {
                    if( !myPlayer.isInHouse() )
                        comm.printError( "You are not in a house." );
                    else {
                        if( inSession )
                            mySession.moveHouse( myPlayer.getId(), myMap.getHouseId(),
                            false, myPartNum );
                        myMap.leaveHouse();
                        printCurrentRoom();
                        myPlayer.leaveHouse();
                    }

                }
                break;
                case Command.DISPLAY_PART: {
                    comm.printMessage
                    ( "Current partition: "  + myPartNum );
                }
                break;
                case Command.CLEAR_SCREEN: {
                    comm.clear();
                    printCurrentRoom();
                }
                break;
                case Command.DO_REPORT_NOW: {
                    if( inSession ) {
                        comm.printMessage( "Doing report now." );
                        reportTimer.start( 5000 );
                    }
                }
                break;
                case Command.SURRENDER: {
                    if( !myPlayer.isInCombat() || myPlayer.hasMobTarget() )
                        comm.printError( "You must be fighting another player to execute " +
                        "this command." );
                    else {
                        comm.printMessage
                        ( "You surrender to " +
                        thePlayerTarget.getName() );
                        myPlayer.clearTargetData();
                        comm.clearCombatLog();
                        thePlayerTarget.clearTargetData();
                        thePlayerTarget = null;
                        mySession.surrender( myPartNum, myPlayer.getId() );
                    }
                }
                break;
                case Command.MOB_COMMAND: {
                    MobCommand mCommand = (MobCommand)command;
                    Mob theMob = (Mob)myState.get( GameState.MOB, mCommand.getKey() );
                    if( theMob != null ) {
                        if( mCommand.getMobCmdType() == MobCommand.KILL ) {
                            theMob.kill();
                            DeathData info = new DeathData( myPlayer.getId(), theMob.getKey() );
                            mySession.notifyMobDeath( info, myPartNum );
                        }
                        else if( mCommand.getMobCmdType() == MobCommand.FIND )
                            comm.printMessage( theMob.getName() + ": " +
                            theMob.getCurrentLocation() );

                        else
                            theMob.doNow( mCommand.getMobCmdType() );
                    }
                    else
                        comm.printError( mCommand.getKey() + ": Invalid MobKey" );
                }
                break;
                case Command.PRINT_MOBS: {
                    Iterator theMobs = myState.getCollection( GameState.MOB );
                    while( theMobs.hasNext() ) {
                        Mob theMob = (Mob)theMobs.next();
                        comm.printMessage( theMob.getName() +
                        "(" + theMob.getKey() + ")" +
                        " " + theMob.getCurrentLocation( ));
                    }
                }
                break;
                case Command.QUIT: {
                    if( inSession )
                        comm.printError( "You may not quit until you leave the session." );
                    else {
                        myPlayer.save();
                        System.exit( 0 );
                    }
                }
                break;
            }
        }
        unlock();
    }
@


1.30
log
@*** empty log message ***
@
text
@d1 1
a1 1
 /**  
d4 2
a5 2
 * Command object, determine what it is, and then execute that command.  
 * Thus, the largest function in this class is the execute function which 
d7 2
a8 2
 * The GameSystem also serves as the primary source of communcation between 
 * other units that are in the session, as well as the object which 
d11 1
a11 1
 * Of course, this creates a single point of failure for the most part, 
d13 1
a13 1
 * 
d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.29 2004/12/10 02:29:05 rjw2183 Exp rjw2183 $
d40 110
a149 116
implements Game, GCWindowListener, 
           TimeListener, MerchantListener,
	   MobListener, PlayerCacheListener
{
	// Session related data members
	private Game myHandle;  // this unit's unihandle 	
	private boolean inSession; // indicates if the unit is in a session
	private String mySessionName; // name of the session the unit isa member of	
	private Game mySession; // handle to the session this game is a part of	
	
	// State related state members
	private PlayerCharacter myPlayer; // the player for this unit
	private World myMap; // the world for this unit	
	private GameState myState; // the state of this game
	private GameState incomingState; // used when joining a session, this is the incoming state of the game
	private TimeManager myTimeManager; // the manager for the passage of time
	private ItemData myItemData;  // the item data of the game
	String stateName; // the file name of that state, this is sed for the shortcut save command
	
	// combat related data members
	private Mob theMobTarget; // The mob target the player is attacking
	private PlayerCharacter thePlayerTarget; // the player target the player is currently fighting.
	private boolean hasBalance; // indicated if this persdon curretly has balance
	private int round; // the round of attack this is
	private boolean consideringDuel; // indicates if this toon is currently considering a duel
	private Eoid currentChallenger; // the current duel challenger	
	private Timer attackTimer; // timer used to notify when the player has balance
	boolean ignoreBroadcasts; // a flag to indicate if a unit needs to ignore a broadcast
	
	
	// Misc data members
	private PlayerCommunicator comm; // used to talk to the player
	private String[] attacks; // an array used to print out the type of attack
	private MapWindow myMapWindow; // the map windoe
	private Random mobMover; //  A random used to generate the movement of the next mob	
	private Vector lookupVector; // the vector which stores the data from a lookup
	private FriendsList myFriendsList; // a friends' listing for this user
	private int myPartNum;
	boolean leftSession; //  A boolean to indicate if the user left a session
	private PlayerRefresher myPlayerRefresher; // used as a heartbeat
	
	SessionFinder sessionFinder; // the object used to find sessions.
	
	// Used for synchronization
	private boolean available;
	
	private class AttackTimerTask
	implements TimerTask
	{
		public AttackTimerTask()
		{
		}
		
		public void action( Timer theTimer )
		{
			setAttack( theTimer );
		}
	}
	
	private void setAttack( Timer theTimer )
	{
		setBalance( true );
	}
/********************************************************************************************************************************/	
	/**
	 * Constructor
	 */
	public GameSystem( PlayerCommunicator theComm )
	throws Exception
	{
		super();
		comm = theComm;
		checkDirectories();
		leftSession = false;
		
		// Set up the combat and report timers
		intervalPRNG = new Random();		
		attackTimer = TimerThread.getDefault().createTimer( new AttackTimerTask() );			
		
		// Set up the M2MI communications 
		M2MI.export( this, Game.class );
		M2MI.export( this, GameDiscovery.class );
		myHandle = (Game)M2MI.getUnihandle( this, Game.class );					
		stateName = null;
		myPartNum = 0;
		
		myTimeManager = new TimeManager( this );
		lookupVector = new Vector();		
		loadItemData();
		available = true;
		attacks = new String[4];
		attacks[0] = "punch";
		attacks[1] = "kick";
		attacks[2] = "slash";
		attacks[3] = "thrust";
		hasBalance = true;
		round = 0;
		consideringDuel = false;
		currentChallenger = null;
		incomingState = null;
		myMapWindow = new MapWindow();
		myPlayer = null;
		myMap = null;
		comm.printMessage( "Welcome to M2MIMud! Please create or load a new character." );
		comm.printMessage( "Upon obtaining a character, s/he will be placed into the default world, " +
				   "from where you can load up another world (or map) to begin play." );
		
			 		
		// Other data member initalization		
		inSession = false;			
		mySession = null;
		mobMover = new Random();	
	}
/********************************************************************************************************************************/	
	/*
	 * These two functions provide some synchronization for the game system.
d151 213
a363 676
	 * so that the task is completed in the state that it started in, and that the task is not lost
	 */
	 
	/**
	 * Attempts to lock the game system
	 */
	private void attemptLock()
	{				
		while( available == false )
		{
			try
			{
				wait();
			}
			catch( Exception e )
			{
			}
		}
		available = false;
	}
	
	/** 
	 * Unlocks the game system, and notifes all waiting threads that the 
	 * system in now available.
	 */
	private void unlock()
	{				
		available = true;
		notifyAll();
	}
/********************************************************************************************************************************/	
	// The functions of the Game interface, which are used to maintain state and such
	
	/**
	 * Prints out the user's message.  Unlike a say, this is broadcast to everyone on the map.
	 * @@param: message The message from the user                                                                               
.
	 * @@param: handle The handle of the game which controls the player
	 * @@param: playerName The name of the player
	 */
	public synchronized void yell( SayData theMessage, int partition )
	{
		if( partition == myPartNum )
		{
			attemptLock();
			if( !myPlayer.getId().equals( theMessage.playerId ) )
			{
				PlayerCharacter thePlayer = checkId( theMessage.playerId );
				String name = "Someone";
				if( thePlayer != null )
					name = thePlayer.getName();
				comm.printMessage( name + " yells, \"" + theMessage.myMessage + "\"" );		
			}
			unlock();
		}
	}
	
	/**
	 * Performs a say, which causes the message to be displayed if this unit's
	 * player is in the same room as the player who did the say
	 * @@param the Message The object that contains the information needed to do the message.
	 */	 
	public synchronized void say( SayData theMessage, int partition )
	{
		if( partition == myPartNum )
		{		
			attemptLock();
			if( !myPlayer.getId().equals( theMessage.playerId ) )
			{
				PlayerCharacter thePlayer = checkId( theMessage.playerId );
				String name = "Someone";
				if( thePlayer != null )
				{
					name = thePlayer.getName();			
					checkLocation( thePlayer, theMessage.playerLoc );																
				}
				if( myMap.checkLoc( theMessage.playerLoc ) )
					comm.printMessage( name + " says, \"" + theMessage.myMessage + "\"" );					
			}
			unlock();
		}
	}
		                                                                               

	 /**
	  * Tells the session someone is joining.
	  * @@param: handle The handle of the joining game unit
	  * @@param: player The player character data of the player
	  * @@param: newState the state of the world which is joining
	  */
	public synchronized void joinSession( PlayerCharacter player, int partition )
	{
	 	if( partition == myPartNum )
		{
			attemptLock();					
			
			// First things first - stop the report 
			// timer and add the player.
			reportTimer.stop();								
			// Reset the time
			myState.setTime( myTimeManager.getTime() );									
			
			// Print out the notification
			comm.printMessage( player.getName() + " has joined our world." );
						
			if( myFriendsList.hasPlayer( player.getId() ) )
				comm.printMessage( "Your friend, " + player.getName() + " has joined this session." );		
			
			// Restart the timer
			scheduleNormalReport();	
			
			// display the current world
			if( myPlayer.getId().equals( player.getId() ) )
				printCurrentRoom();	
				
			// Final step! If my player is in combat, remnd everyone.
			if( myPlayer.isInCombat() )
			{
				if( myPlayer.hasMobTarget() )
				{
					
					mySession.registerAttacker 
					( myPlayer.getLocation(), theMobTarget.getKey(), 
					  myPlayer.getId(),  theMobTarget.getCombatTimeStamp(),
					  myPartNum );
		  	        }

			}	     
			unlock();	
		}
	}
	 
	 /**
	  * Tells the session someone is leaving.
	  * @@param: handle The handle to the game unit which is leaving
	  */
	 public synchronized void leaveSession( Eoid playerId, int partition )
	 {	 	
		if( partition == myPartNum )
		{								
			attemptLock();
			reportTimer.stop();			
			PlayerCharacter leavingPlayer = checkId( playerId );
			if( leavingPlayer != null )
			{
		
				String name = leavingPlayer.getName();		
				
				// If the leaving player is in combat, the unit
				// needs to drop the targets from that fight.
				// Obviously since, at this point, something is wrong,
				// the system will then request an emergency transmission 
				// in an attempt to perform state synchronization.
				if( leavingPlayer.isInCombat() )
				{
					if( leavingPlayer.hasMobTarget() )
					{
						MobKey theKey = (MobKey)leavingPlayer.getTarget();
						Mob theMob = (Mob)myState.get( GameState.MOB, theKey );
						if( !theMob.getKey().equals( myPlayer.getTarget() ) )
							theMob.stopAttack();
						else
							mySession.errorDetected( myPlayer.getId(), myPartNum );
					}
					else
					{						
						PlayerCharacter thePlayer = checkId( 
							(Eoid)leavingPlayer.getTarget() );
						if( thePlayer != null )
							thePlayer.clearTargetData();
						if( myPlayer.getId().equals( thePlayer.getId() ) )
						{
							thePlayerTarget = null;
							comm.printError( "Your fight has been ended." );
							comm.clearCombatLog();
						}
					}									
				}
				
				if( consideringDuel &&
				    leavingPlayer.getId().equals( currentChallenger ) )
				{
					consideringDuel = false;
					comm.printMessage( "Duel challenge cancelled" );
				}
				
				if( consideringDuel && thePlayerTarget != null &&
				    leavingPlayer.getId().equals( thePlayerTarget.getId() ) )
				{
					consideringDuel = false;
					comm.printMessage( "Duel challenge cancelled." );
				}
				
				
				if( !myPlayer.getId().equals( playerId ) )
				{
					myState.remove( GameState.PLAYER, leavingPlayer.getId() );
					comm.printMessage( name + " has left our world." );
					if( myFriendsList.hasPlayer( playerId ) )
						comm.printMessage( "Your friend, " + name + 
						                   " has left this session." );
					myMap.removePlayer( playerId );
				}								
			}			
			scheduleNormalReport();
			unlock();		
		}
	 }	
	 
	 /**
	  * Moves a player or a mob
	  * @@param theMove An object which contains the data need to perform the move
	  */                                                                               

	 public synchronized void processMove( MoveData aMove, int partition )
	 {	
		if( partition == myPartNum )
		{		
			attemptLock();			
			switch( aMove.getType() )
			{
				case MoveData.PLAYER:
				{
					UserMove theMove = (UserMove)aMove;				 						
					if( !myPlayer.getId().equals( theMove.getUser() ) )
					{		
						PlayerCharacter thePlayer = checkId( theMove.getUser() );
						if( thePlayer != null )
						{
							String name = thePlayer.getName();
							// If the player is in combat....
							// Moving causes the monster they are fighting to
							// stop attacking them.
							if( thePlayer.isInCombat() )
							{
								if( thePlayer.hasMobTarget() )
								{
									Mob theMob = (Mob)myState.get(
									GameState.MOB, 
									(MobKey)thePlayer.getTarget() );
									theMob.stopAttack();
									thePlayer.clearTargetData();
									comm.printMessage( thePlayer.getName() + 
									                   " disengages combat with " +
									                 theMob.getName() );
								}
								else
								{
									PlayerCharacter player =
										 checkId( (Eoid)thePlayer.getTarget() );
									if( player != null )
										player.clearTargetData();
									thePlayer.clearTargetData();
									if( myPlayer.equals( thePlayer ) )
									{
										comm.printError( "Your fight has been ended." );
										comm.clearTarget();										
									}
								}						
							}
							
							// If my player is not in a house and is in either the
							// to or from tiles, display something.
							if( myMap.checkLoc( theMove.getLoc( MoveData.FROM ) )
							   && !myPlayer.isInHouse() )
							{
								String[] directions = { "north", "south", "east", "west" };
								comm.printMessage( name + " leaves to the " + 
								                   directions[theMove.getDirection()] );
							}
							else if( myMap.checkLoc( theMove.getLoc( MoveData.TO ) ) &&
							        !myPlayer.isInHouse() )
							{
								String[] directions = { "south", "north", "west", "east" };
								comm.printMessage( name + " enters from the " + 
								                  directions[theMove.getDirection()] );
							}							
							myMap.processMove( theMove );	
						}							
					}
				}	
				break;
				case MoveData.MOB:
				{						
					MobMove theMove = (MobMove)aMove;					
					Mob theMob = (Mob)myState.get( GameState.MOB, theMove.getKey() );					
					// Yep.   If the mob is dead or fighting.. there's an error.
					if( !theMob.isAlive() || theMob.isUnderAttack() )
						mySession.errorDetected( myPlayer.getId(), myPartNum );
					else
					{										
						myMap.refreshMobTimer( theMove.getKey() );					
						if( theMove.getDirection() != -1 )
						{												
							String name = theMob.getName();												
							boolean validMob = myMap.moveMob( theMove );							
							if( myMap.checkLoc( theMove.getLoc( MoveData.FROM ) ) && validMob )
							{
								String[] directions = { "north", "south", "east", "west" };
								comm.printMessage("A " + name + " leaves to the " +
								                   directions[theMove.getDirection()] );
							}
							else if( myMap.checkLoc( theMove.getLoc( MoveData.TO ) ) && validMob )
							{
								String[] directions = { "south", "north", "west", "east" };
								comm.printMessage(  "A " + name + " enters from the " +
								                    directions[theMove.getDirection()] );
							}										
						}				
					}
				}
				break;
		 	}
			unlock();
		}
	}
	/**
	 * Notifies this unit that a player has timed out and must thus be removed.
	 * @@param: handle The unihande of the game unit which has timed out.
	 */
	 public synchronized void notifyPlayerTimeout( Eoid playerId, int partition )
	 {
		if( partition == myPartNum )
		{
			attemptLock();
			if( myPlayer.getId().equals( playerId ) && inSession )
			{
				leave();
				comm.printMessage( "Disconnected from the session as there has " +
 					   "been no activity for 10 minutes." );
			}       
			else
			{
				mySession.leaveSession( playerId, myPartNum );
			}                                                           
			unlock();		
		}
	  }
	  
	  
	  /**
	   * Sets a pond at the given location
	   * @@param location The location to place the pond at
	   * @@param playerId The id of the player who dug the pond
	   */
	  public synchronized void setPond( XYloc location, Eoid playerId, int partition )
	  {
		if( partition == myPartNum )
		{
			attemptLock();
			if( !myPlayer.getId().equals( playerId ) )
			{
				PlayerCharacter thePlayer = checkId( playerId );
				String name = "Someone";
				if( thePlayer != null )
								
					name = thePlayer.getName();
					checkLocation( thePlayer, location );				
			  	myMap.setPondAt( location );
				if( myMap.checkLoc( location ) )
					comm.printMessage( name + " digs a small pond in the ground." );				
			}
			myState.add( GameState.POND, location );
			unlock();
		}
	  }	
	  
	  /**
	   * Warps the player from one location to another
	   * @@param playerId The id of the player who warped
	   * @@param: from The location the player warped from
	   * @@param: to The location the player warped to
	   */
	  public synchronized void warp( Eoid playerId, XYloc from, XYloc to, int partition )
	  {		
		if( partition == myPartNum )
		{		
			attemptLock();
			if( !myPlayer.getId().equals( playerId ) )
			{				
				PlayerCharacter thePlayer = checkId( playerId );
				if( thePlayer != null )
				{				
					String name = thePlayer.getName();	
					if( myMap.checkLoc( from ) )
						comm.printMessage( name + " suddenly vanishes from sight!" );
					myMap.performWarp( playerId, to );
					if( myMap.checkLoc( to ) )
						comm.printMessage( name + " suddenly phases into view!" );
				}
				
			}
			unlock();
		}		
	  }
	
	/**
	 * Sets up a house
	 * @@param theHouse The house object which contains the location and owner of the house
	 */
	public synchronized void addHouse( House theHouse, int partition )
	{		
		if( partition == myPartNum )
		{
			attemptLock();
			if( !theHouse.getOwner().equals( myPlayer.getId() ) )
			{
				myMap.placeHouse( theHouse );
				PlayerCharacter thePlayer = checkId( theHouse.getOwner() );
				String name = "Someone";
				if( thePlayer != null )
				{
					name = thePlayer.getName();
					checkLocation( thePlayer, theHouse.getLocation() );
				}
				if( myMap.checkLoc( theHouse.getLocation() ) )
					comm.printMessage( name + " builds their house here." );
								
			}
			unlock();
		}
	}
	  
	/** 
	 * Notifies the system that the time has changed
	 * @@param newTime The new time of the game
	 */ 
	public synchronized void notifyTimePassage( int newTime, int partition )
	{
		if( partition == myPartNum )
		{
			attemptLock();
			myTimeManager.synchronize( newTime );
			myState.setTime( newTime );
			myMapWindow.updateTime( newTime );
			comm.printMessage( myTimeManager.getTimePassageString( newTime ) );
			unlock();
		}
	}
	
	/**
	 * Inform the system that it is time to perdorm a merchant broadcast, which
	 * causes it to print out the merchant's advertisment message
	 * @@param merchantType The type of merchant which is broadcasting
	 * @@param location The location of the merchant
	 */
	public synchronized void merchantBroadcast( int merchantType, XYloc location, int partition )
	{		
		if( partition == myPartNum )
		{		
			attemptLock();
			if( myMap.checkLoc( location ) )
				comm.printMessage( myMap.getMerchantBroadcast( merchantType ) );			
			Merchant theMerch = (Merchant)myState.get( GameState.MERCHANT, location );
			theMerch.scheduleNextMessage();				
			unlock();
		}
	}
	
	/**
	 * Recieves a private message from a player
	 * @@param playerId The id of the player who sent the message
	 * @@param message The message they sent
	 */
	public synchronized void sendPM( Eoid playerId, String message, int partition )
	{
		if( partition == myPartNum )
		{
			attemptLock();
			String name = "Someone";
			PlayerCharacter thePlayer = checkId( playerId );
			if( thePlayer != null )
				name = thePlayer.getName();
			comm.printMessage( name + " sends, \"" + message + "\"" );
			unlock();
		}
	}	
	
	/**
	 * Tells the system that the given mob is under attack by the given player
	 * This causes the mob to silently register the player as its attack, 
	 * which means it stops its movement, but it doesn't inform the system when it attacks
	 * is targets.  Players, however, are told that the mob is fighting a player when 
	 * they enter the room and/or perform the /look command.  They are also notifed that the given player
	 * begins attack the monster
	 * @@param loc The location where the mob is
	 * @@param theKey The MobKey of the mob in question
	 * @@param playerId the id of the player.
	 */
	 public synchronized void registerAttacker( XYloc loc, MobKey theKey, Eoid playerId, Date ts, int partition )
	 {
	 	if( partition == myPartNum )
		{
			attemptLock();
			Mob theMob = (Mob)myState.get( GameState.MOB, theKey );					
			if( !myPlayer.getId().equals( playerId ) )
			{
				if( theKey.equals( myPlayer.getTarget() ) )
					mySession.errorDetected( myPlayer.getId(), myPartNum );				
				else
				{
					theMob.startAttackSilent( playerId, ts );
					if( !theMob.getCurrentLocation().equals( loc ) )
						myMap.moveMob( theMob.getKey(), loc );										
						
					PlayerCharacter thePlayer = checkId( playerId );
					if( thePlayer != null )
					{
						thePlayer.registerTarget( theKey );
						checkLocation( thePlayer, loc );
					}
					
					if( myMap.checkLoc( loc ) )
					{					
						String pName = "Someone";
						if( thePlayer != null )					
							pName = thePlayer.getName();
						comm.printMessage( pName + " begins attacking the " + theMob.getName() + "!",
						                   Color.red.darker() );			
					}
				}
			}			
			unlock();
		}
	 }
	 
	/**
	 * Tells this unit that the 2 players are in combat.
	 * @@param p1 The id of one of the players in combat
	 * @@param p2 The id of the other player in combat
	 * @@param loc The location where the teo are fighting
	 */
	public synchronized void notifyFight( Eoid p1, Eoid p2, XYloc loc, int partition )
	{
		if( partition == myPartNum )
		{		
			attemptLock();
			PlayerCharacter playerOne = checkId( p1 );
			PlayerCharacter playerTwo = checkId( p2 );
			String name1 = "Someone";
			String name2 = "someone else";
			
			
			if( p1.equals( myPlayer.getTarget() ) && !p2.equals( myPlayer.getId() ) ||
			    p2.equals( myPlayer.getTarget() ) && !p1.equals( myPlayer.getId() ) )
			    	endFightError();
						
			if( playerOne != null )
			{
				playerOne.clearTargetData();
				playerOne.registerTarget( p2 );
				name1 = playerOne.getName();
				checkLocation( playerOne, loc );
			}
			
			if( playerTwo != null )
			{
				playerTwo.clearTargetData();
				playerTwo.registerTarget( p1 );
				name2 = playerTwo.getName();
				checkLocation( playerTwo, loc );
			}
			
			boolean isMe = myPlayer.getId().equals( p1 ) ||
			               myPlayer.getId().equals( p2 );						
				
			if( myMap.checkLoc( loc ) && !isMe )
				comm.printMessage( name1 + " and " + name2 + " begin fighting!" );					
			unlock();			
		}
	}	
	
	/**
	 * Tells this unit to print damage
	 */
        public synchronized void printAttack( int damage, int partition, Eoid pId )
	{
		if( partition == myPartNum &&
                   ( myPlayer.isInCombat() &&
                     pId.equals( myPlayer.getTarget() ) )
                   )
		{		
			attemptLock();
			String pName = thePlayerTarget.getName();
			int bonus = myItemData.getCombatBonus( myPlayer.getGear( PlayerCharacter.BODY ) );
			if( bonus != -1 )
				damage -= bonus;
			if( damage < 0 )
				damage = 0;
			thePlayerTarget.getHandle().reportBackDamage( damage, myPartNum );
			comm.printCombatMessage( pName + " attacks you for " + damage + " damage!", Color.red.darker(), true );
			myPlayer.adjustHP( -1 * damage );
			comm.setActivePlayer( myPlayer );
			if( !myPlayer.isAlive() )
			{
				comm.printMessage( "You were just killed by " + pName );						
				myPlayer.clearTargetData();
				thePlayerTarget.clearTargetData();
				myMap.warp( 0, 0 );
				myPlayer.ressurect();
				comm.setActivePlayer( myPlayer );
				comm.clearCombatLog();
				printCurrentRoom();								
                                DeathData theInfo = 
                                new DeathData( myPlayer.getId(), thePlayerTarget.getId() );
                                thePlayerTarget = null;
				mySession.notifyPlayerDeath( theInfo, myPartNum );	
			}
			unlock();
		}
	}
	
	/**
	 * Tells this unit to respawn the mob of the given key.
	 * @@param theKey They key of the mob to respawn
	 */
	public synchronized void notifyMobRespawn( MobKey theKey, int partition )
	{
		if( partition == myPartNum )
		{
			attemptLock();
			Mob theMob = (Mob)myState.get( GameState.MOB, theKey );
			
			// This is part of the state checking mechanism. 
			// If the a respawn is rec'd, but the monster is not 
			// dead, something's gone wrong. In this situation, 
			// the game requests it's session to perform an emergency report.
			if( !theMob.isAlive()  )			
			{		
				theMob.respawn();
				if( myMap.checkLoc ( theMob.getCurrentLocation() ) )
					comm.printMessage( theMob.getName() + " is restored back to life." );
			}
			else
				mySession.errorDetected( myPlayer.getId(), myPartNum );
			unlock();
		}
	}
	
	/**
	 * Informs this unit that the player was just killed
	 * @@param id The id of the player
	 * @@param loc The location where the player was killed
	 */
	public synchronized void notifyPlayerDeath( DeathData theInfo, int partition )
	{
		if( myPartNum == partition )
		{
			attemptLock();
			if( !myPlayer.getId().equals( theInfo.getKilled() ) ) 
			{						
				PlayerCharacter thePlayer = checkId( theInfo.getKilled() );				
				String name = "Someone";
				String name2 = "someone";				
				if( thePlayer != null )
				{				
					name = thePlayer.getName();
					thePlayer.clearTargetData();					
					myMap.performWarp( thePlayer.getId(), new XYloc( 0, 0 ) );
				}
                                
				if( theInfo.getCombatType() == DeathData.MOB )
                                {
                                	// Error detection - if the player was killed
                                        // by the mob this unit's player is fighting, something
                                        // is wrong.
					if( theInfo.getMob().equals( myPlayer.getTarget() ) ||
					    theInfo.getKilled().equals( myPlayer.getTarget() ) )
                                        {
                                            endFightError();
                                        }                                        
                                        Mob theMob = (Mob)myState.get( GameState.MOB,
                                        theInfo.getMob() );
                                        theMob.stopAttack();
                                        name2 = theMob.getName();
					
d365 1
a365 153
                                else
                                {       
                                        PlayerCharacter theOtherPlayer = 
                                            checkId( theInfo.getKiller() );
                                       // If the person who killed the player was the person'
                                       // ths unit is fighting, something is wrong.
                                       // also if the person killed was this unit's target
                                       // AND the killer was not this unit, something
                                       // is wrong                                           
				      if( theInfo.getKiller().equals( myPlayer.getTarget() ) ||
                                          ( theInfo.getKilled().equals( myPlayer.getTarget() ) &&
                                           !theInfo.getKiller().equals( myPlayer.getId() ) ) )
                                     {
                                                endFightError();
                                     }
                                      
				     if( theOtherPlayer != null )
				     {
					      theOtherPlayer.clearTargetData();
        	                              name2 = theOtherPlayer.getName();					       
					      if( myPlayer.getId().equals( theOtherPlayer.getId() ) )
					      {
					      		thePlayerTarget = null;
							comm.clearCombatLog();
					      }
				     }
                                  }
                                  comm.printMessage( name + " was killed by " + name2 );
                	}	
			unlock();			
		}				
	}
	
	public synchronized void updateState( GameState theState, int partition )
	{
		if( myPartNum == partition )
		{
			attemptLock();		
			// Straightforward - this simply calls merge on the state
			myState.merge( theState, myMap );
			unlock();
		}
	}
	
	/**
	 * Refreshes the player's timers
	 * @@param: Eoid The id of the player
	 * @@param: partNum The partion number
	 */
	public synchronized void refreshPlayer( Eoid playerId, int partNum )
	{	
		if( myPartNum == partNum )
		{
			attemptLock();			
			PlayerCharacter thePlayer = checkId( playerId );
			if( thePlayer != null )							                                                  
                            myState.refreshPlayer( playerId );			                        
			unlock();
		}
	}
	
	/**
	 * Moves the given player into the listed house
	 * @@param pId the id of the player
	 * @@param houseId the id of the house
	 */
	 public synchronized void moveHouse( Eoid pId, Eoid houseId, boolean enter, int partNum )
	 {
	 	if( myPartNum == partNum && !myPlayer.getId().equals( pId ) )
		{
			attemptLock();
			boolean inRoom = false;
			String which = null;
			PlayerCharacter thePlayer = checkId( pId );
			House theHouse = (House)myState.get( GameState.HOUSE, houseId );
			if( theHouse == null )
				mySession.errorDetected( myPlayer.getId(), myPartNum );
			
			if( thePlayer != null && theHouse != null )
			{								
				checkLocation( thePlayer, theHouse.getLocation() );
				if( enter == false )
				{
					myMap.removePlayerFromHouse( pId, houseId );
					which = "leaves";
				}
				else
				{
					myMap.movePlayerIntoHouse( pId, houseId );
					which = "enters";
				}
				
				XYloc houseLoc = theHouse.getLocation();
				if( myMap.checkLoc( houseLoc ) )
				{
					String pName = thePlayer.getName();
					String hName = theHouse.getOwnerName();
					comm.printMessage( pName + " " + which + " " + hName + "\'s house." );
				}
			}
			unlock();
		}
     }	 
	 
	 /** 
	  * This function notifes this unit that caller has a state issue, 
	  * and that this unit needs to schedule an emergency report in hopes
	  * that the state can be fixed
	  * @@param pId The id of the unit that called this
	  */
	 public synchronized void errorDetected( Eoid pId, int partNum )
	 {
	 	if( myPartNum == partNum )
		{
			attemptLock();
			// One of the aspects of M2MIMud is that there is no "one" state
			// that units can rely on when the realize their state is no longer
			// in sync with the global state. When an error is detected, the only
			// thing that can be done is to begin te process of state healing, which
			// takes into account a state.  Therefore, when this function is called, 
			// the notion is that this unit has detected an error.  The error could come from
			// a unit which has been partitioned, or perhaps the unit itself was partitioned.
			// In any event, the only thing the unit can rely on is itself.  As a result,
			// this function causes all other session members to restart their report timers, 
			// and causes this unit to schedule an emergency broadcast in an attempt
			// to fix the global state.			
			if( myPlayer.getId().equals( pId ) )
				scheduleEmergencyReport();
			else
				scheduleNormalReport();
			unlock();
		}
	}
	 	
/********************************************************************************************************************************/	
	// These are the duel functions used when one player challenges another player.
	
	 /**
	  * Informs this system that a challeneg to a duel has been issued
	  * @@param: pId The player if of the person who issued the duel
	  */
	 public synchronized void requestDuel( Eoid pId, int partition )
	 {
	 	if( myPartNum == partition )
		{
			attemptLock();			
			PlayerCharacter challenger = checkId( pId );
			if( challenger != null )
			{	
				if( consideringDuel )
					challenger.getHandle().declineDuel( " is already considering another duel.", 
					myPlayer.getId(), myPartNum );
				else
d367 10
a376 80
					comm.printMessage( challenger.getName() + " has challenged you to a duel!" );
					consideringDuel = true;
					currentChallenger = pId;
				}
			}	
			else
				mySession.errorDetected( myPlayer.getId(), myPartNum );		
			unlock();
		}
	 }
	 
	 /**
	  * Tells the player that the person has decline the duel
	  * @@param reason The reason the player declined the duel
	  * @@param pId The id of the person who declined the duel
	  */
	 public synchronized void declineDuel( String reason, Eoid pId, int partition )
	 {
	 	if( partition == myPartNum )
		{
		 	attemptLock();
			String pName = ((PlayerCharacter)myState.get( GameState.PLAYER, pId )).getName();
			comm.printMessage( pName + reason );
			consideringDuel = false;
			unlock();
		}
	 }
	 
	 /** 
	  * Informs the unit that duel challenge has been accepted.
	  * @@param pId The id of the player who accepted the duel.
	  */
	 public synchronized void acceptDuel( Eoid pId, int partition )
	 {
	 	if( partition == myPartNum )
		{
			attemptLock();
			PlayerCharacter thePlayer = (PlayerCharacter)myState.get( GameState.PLAYER, pId );
			comm.printMessage( thePlayer.getName() + " has accepted your challenge! Begin fighting!" );
			consideringDuel = false;
			thePlayerTarget = thePlayer;
			myPlayer.registerTarget( pId );
			comm.setTarget( thePlayer.getName() );
			unlock();
		}
	 }	
	
/********************************************************************************************************************************/
	// These functions are the ones used to do the reporting of this game and any session it is a part of to to the world
	
	/**
	 * Receives a session report.  If this report constans the data for
	 * the session this unit is a part of, then the state it contains is checked with 
	 * the game's current state to makes sure that it is consistent.  
	 * Also, the timer is restarted to reduce network traffic.
	 * @@param theAd An ad for a game session.
	 */
	public synchronized void report( SessionAd theAd )
	{										
		
		if( 
		     ( mySession != null && mySession.equals( theAd.sessionHandle ) ) &&
		     theAd.sessionState.getPartNum() == myPartNum  
		  )
		{						
			
			attemptLock();			
			
                        if( myState.equals( theAd.sessionState ) ||
			    myPlayer.getId().equals( theAd.sessionState.getPlayerId() ) )							                                                                                                                             
                            scheduleNormalReport();                        
			else
			{				
				comm.disable();										
				boolean wasInCombat = myPlayer.isInCombat();				
				myState.synchronize( theAd.sessionState, myMap );				
				if( wasInCombat && !myPlayer.isInCombat() )
				{
					comm.printMessage( "The gods have ended your fight." );
					theMobTarget = null;
d378 139
a516 24
					comm.clearCombatLog();
				}			
				currentChallenger = null;
				comm.enable();			
				
				// Since things were changed, schedule an 
				// emergency report to get out the changes asap.			
                                scheduleEmergencyReport();
			}			
                        unlock();			
		}
	}	
	
	/** 
	 * This is the method called when the reportTimer go off.
	 * @@param theTimer The timer that went off
	 */
        protected synchronized void invokeReport( Timer theTimer )
        {
            if( theTimer.isTriggered() )
            {
                allGameUnits.report
                ( new SessionAd( mySessionName, mySession,
                                 myState ) );                
d518 50
d569 1
a569 222
/********************************************************************************************************************************/
	// Helper functions used to join and leave sessions
	
	/**
	 * The listener function for this game System, this is called when the user has 
	 * selected a session (or hit the cancel button) on the game selection window.
	 * @@param: theAd The session ad which contains the information about the session the user selected.
	 */
	 
	public void sessionSelected( SessionAd theAd )
	{		
		comm.enable();						
		// A value of null for the session ad indicates they hit the 'cancel' button
		if( theAd != null )
		{							
						
			inSession = true;
			mySession = theAd.sessionHandle;
			mySessionName = theAd.sessionName;												
			incomingState = theAd.sessionState;												
			myMap.warp( 0, 0 );
			
			if( incomingState.getConfig() != null &&
			    !incomingState.getConfig().equals( myState.getConfig() ) )
				// recreate the world using this configuration
				myMap.createWorld( incomingState.getConfig() );								
							
			else
			{
								
				// This is rather special case.  This deals with situation when the
				// the user has a non default state, but is joininga session which is using
				// the default state.  What happens is the the syste, defaults to this case, 
				// because the incoming state does not have a configuration.  This is case is
				// partially appropiate, because what the system will do it to load the default
				// state.
				if( incomingState.getConfig() == null && myState.getConfig() != null )
				{
					myMap = myMap.getWorld( "default" );
					myState = myMap.getState();
					myState.add( GameState.PLAYER, myPlayer );																			
					myState.setPCList( this );
					myState.setId( myPlayer.getId() );					
				}								
			}	
					
			mySession.updateState( myState, myPartNum );	
                        
			myState.merge( incomingState, myMap );			
			myState.updateListeners( this, this, myMap );			
			
			myTimeManager.synchronize( theAd.sessionState.getTime() );
			myTimeManager.start();
			
		
			((Multihandle)mySession).attach( this );
			mySession.joinSession( myPlayer, myPartNum );
			myPlayerRefresher = new PlayerRefresher( myPlayer.getId(), mySession );				
			myPlayerRefresher.start();			
			
			myMap.setViewer( myMapWindow );	
			comm.clear();
			comm.setStateName( stateName );					
			myMap.setViewer( myMapWindow );
			comm.printMessage( "Joining session: " + theAd.sessionName );
			printCurrentRoom();
			
			sessionFinder.unexport();
			sessionFinder = null;
		}	
	}			
	
	/*
	 * Leaves a session
	 */
	private void leave()
	{		
		// Leave the session, save all the data, and then quit out
		if( consideringDuel )
			cancelDuel( " has left the game. Challenge cancelled." );				
		if( mySession != null )
			mySession.leaveSession( myPlayer.getId(), myPartNum );	
		((Multihandle)mySession).detach( this );	
		myPlayerRefresher.stop();			
		myState.clear( GameState.PLAYER );
		myMap.clearSessionInfo();			
		M2MI.unexport( this );
		myPlayer.save();				
		myFriendsList.save();																							
		leftSession = true;
		inSession = false;			
		myState.add( GameState.PLAYER, myPlayer );						
	}	
/********************************************************************************************************************************/
	// These are the non Game interface functions
	
	/** 
	 * The function for the time listener interface.  Used to tell the session that time has changed.
	 * @@param newTime The new time
	 */
	public void timeChanged( int newTime )
	{		
		if( mySession != null )
			mySession.notifyTimePassage( newTime, myPartNum );			
		else
		{			
			myMapWindow.updateTime( newTime );			
			comm.printMessage( myTimeManager.getTimePassageString( newTime ) );			
		}	
	}                                                                               

	/**
	 * The function	for the merchant listener, if the user is in the current
	 * location it prints out the merchant's message
	 * @@param: merchantType  The type of merchant
	 * @@param: location The location the merchant is
	 */
	public synchronized void sendMessage( int merchantType, XYloc location )
	{		
			attemptLock();
			// The check for null here is if a merchant times out 
			// when the game is in the process of leaving the session
			if( mySession != null )
				mySession.merchantBroadcast( merchantType, location, myPartNum );			
			unlock();
	}	
	
	/**
	 * This informs the game unit that the mob is attacking the target
	 * @@param Eoid target The target the mob is attacking, since only the game unit which has 
	 *        player cares about this, nothing happens if this is not the target
	 * @@param damage The base damage the mob has done
	 * @@param key The id of the mob which is fighting
	 */
	 public synchronized void attackTarget(  int damage, String name )
	 {			
			doAttack( damage, name );			
	 }
	 
	 /**
	  * Tells the game system that the mob has respawned at the given location
	  * @@param  key The key of the mob that respawned
	  * @@param loc The location the mob spawned at
	  */
	  public synchronized void respawnMob( MobKey key )
	  {
	  	attemptLock();
		if( mySession != null )
			mySession.notifyMobRespawn( key, myPartNum );
		unlock();
	  }
	
	/**
	 * Informs ths unit to tell everyone that a mob is moving and need to update
	 * @@param theMove The object which contains the movement data
	 */
	public synchronized void moveMob( MobMove theMove )
	{		
		attemptLock();
		if( mySession != null && theMove != null )					
			mySession.processMove( theMove, myPartNum );
		unlock();										
	}
	
	
	/**
	 * This is called t indicate that a player has time out
	 * @@param playerId The id of the player who has timed out
	 */
	public synchronized void playerTimeout( Eoid playerId )
	{
		attemptLock();
		if( mySession != null )
		{
			PlayerCharacter thePlayer = checkId( playerId );			
                            mySession.notifyPlayerTimeout( playerId, myPartNum );                        
		}
		unlock();
	}
	
	/**
	 * Called when a mob attack the player
	 * @@param damage The base damage of the mob
	 * @@param name The name of the mob that attacked
	 */
	private synchronized void doAttack( int damage, String name )
	{
		attemptLock();
		int bonus = myItemData.getCombatBonus( myPlayer.getGear( PlayerCharacter.BODY ) );
		if( bonus != -1 )
			damage -= bonus;
		
		if( 0 > damage )
			damage = 0;
		
		Color[] theColors = { Color.red, Color.black, Color.blue };		
		comm.printCombatMessage( "The " + name + " attacks you and hits for " + damage + " hit points!",
		                          theColors[round].darker(), true );		
		myPlayer.adjustHP( -1*damage );
		comm.setActivePlayer( myPlayer );		
		round++;
		if( round > 2 )
			round = 0;
		
		if( !myPlayer.isAlive() )
		{
			theMobTarget.stopAttack();
			int exp = theMobTarget.getExp();
			myPlayer.incrementExp( -1 * exp );			
			comm.printMessage( "You were just killed by the " + name );
			comm.printMessage( "You have lost " + exp + " exp points." );
			myMap.warp( 0, 0 );
			myPlayer.ressurect();
			comm.setActivePlayer( myPlayer );
			comm.clearCombatLog();
			printCurrentRoom();
			DeathData theInfo = new DeathData( myPlayer.getId(), 
                                                    theMobTarget.getKey() );
                        mySession.notifyPlayerDeath( theInfo, myPartNum );                        
                        theMobTarget = null;
		}					  
		unlock();			
d571 30
a600 45
	}		
	
	/**
	 * Informs the session that a monster has been killed.
	 * @@param loc The location where the mob was killed.
	 * @@param pId The id of the player who kill te mob
	 */
	public synchronized void notifyMobDeath( DeathData theInfo, int partition )
	{
            try
            {
            if( partition == myPartNum )
		{		
			attemptLock();
                        // For a mob's death, this method returns                
			if( !myPlayer.getId().equals( theInfo.getKilled() ) )
			{				
                            String name = "Someone";
                            Mob theMob = (Mob)myState.get( GameState.MOB, theInfo.getMob() );
  			    PlayerCharacter thePlayer = checkId( theInfo.getKilled() );
                            // Lookup the character
                            if( thePlayer != null )
                            {
                                name = thePlayer.getName();
                                thePlayer.clearTargetData();				
				checkLocation( thePlayer, theMob.getCurrentLocation() );
                            }
                            
                            // If either the player of the mob was registered as 
                            // the target of the home character, some is wrong.
                            // stop the fight, and request a state transmission
                            if( ( thePlayer != null && 
			          thePlayer.getId().equals( myPlayer.getTarget() ) ) ||
                                theInfo.getMob().equals( myPlayer.getTarget() ))
                            {
			    	endFightError();
			    }
                            
                            // Finally, kill the mob and report it
                        
			
                            theMob.kill();                            
                            if( myMap.checkLoc( theMob.getCurrentLocation()))
                                comm.printMessage( name + " kills the " + theMob.getName() );
						
d602 18
a619 2
			unlock();		
		}
d621 28
a648 3
            catch( Exception e )
            {
                e.printStackTrace();
a649 421
	}
	
	/**
	 * Informs the player of how much damage he or she did to his or her target
	 * @@param damage The amount of damage done
	 */
	public synchronized void reportBackDamage( int damage, int partNum )
	{
		if( partNum == myPartNum )
		{
			attemptLock();
			comm.printCombatMessage( "You hit " + thePlayerTarget.getName() + " for " + damage + " damage!",
			Color.red.darker(), false );
			unlock();		
		}
	}	
	
	public synchronized void surrender( int partNum, Eoid pId )
	{
		if( partNum == myPartNum )
		{
			attemptLock();
			if( !myPlayer.getId().equals( pId ) )
			{
				if( pId.equals( myPlayer.getTarget() ) )
				{
					comm.printMessage( 
					thePlayerTarget.getName() + " surrenders." );
					thePlayerTarget.clearTargetData();
					thePlayerTarget = null;
					myPlayer.clearTargetData();
					comm.clearCombatLog();
				}
				else
				{
					PlayerCharacter p1 = checkId( pId );
					if( p1 != null )
					{
						if( !p1.hasMobTarget() )
						{
							Eoid p2Id = (Eoid)p1.getTarget();
							PlayerCharacter p2 = checkId( p2Id );							
							p1.clearTargetData();
							if( p2 != null )
								p2.clearTargetData();
						}
					}
				}
			}
			unlock();
		}
	}
		
/********************************************************************************************************************************/	
	// These are private functions designed to help the game system perform its tasks
	
	/**
	 * Prints the current room
	 */
	private synchronized void printCurrentRoom()
	{
		TextMessage desc = myMap.currentAreaDescription();
		if( myPlayer.isInHouse() )
			printHouse( desc );
		else
			printRoom( desc );			
	}
	
	/** 
	 * Prints out a room
	 * @@param roomDesc The TextMessage object that contains the description of the room
	 */
	private void printRoom( TextMessage roomDesc )
	{
		// Print an empty line than the get the description
		comm.printMessage( "" );
		
		// Print out the message from the room
		for( int i = 0; i < roomDesc.getSize(); i++ )
			comm.printMessage( roomDesc.getMessage( i ), roomDesc.getColor( i ) );
		
		// Print out the mobs which are nder attack by another player
		for( int i = 0; i < roomDesc.getNumAttackedMobs(); i++ )
		{
			Eoid pId = roomDesc.getPlayer( i );
			String pName = ((PlayerCharacter)myState.get( GameState.PLAYER, pId )).getName();
			String mName = roomDesc.getMobName( i );
			comm.printMessage( "You see " + pName + " attacking a " + 
			mName + ".", Color.red.brighter() );			
		}
		
		// Print out the players
		printPlayers();
		
	}
	
	/**
	 * Prints a house.
	 * @@param houseDesc The TextMessage object which contains the house's description
	 */
	private void printHouse( TextMessage houseDesc )
	{
		comm.printMessage( houseDesc.getMessage( 0 ) );
		comm.printMessage( houseDesc.getMessage( 1 ) );
		printPlayers();
	}
	
	/**
	 * Prints out the players in the current area
	 */
	private void printPlayers()
	{
		if( myMap.currentAreaHasPlayers() )
		{                                                                               

			Iterator playerIter = myMap.getCurrentAreaPlayers();
			StringBuffer playerName = new StringBuffer( "You see the following players: " );
			StringBuffer combatPlayers = new StringBuffer();
			int nonCombat = 0;
			while( playerIter.hasNext() )
			{
				Eoid temp = (Eoid)playerIter.next();
				PlayerCharacter thePlayer = checkId( temp );
				if( thePlayer != null && !myPlayer.getId().equals( temp ) )
				{
					// Simply print out the name if the player is not in comabt
					if( !thePlayer.isInCombat() )
					{
						playerName.append( thePlayer.getName() + " " );
						nonCombat++;
					}
					else
					{
						// If the player is fighting another player, inform them.
						// However, if the player is fighting as mob, there is no need,
						// since that has all ready been reported
						if( !thePlayer.hasMobTarget() )
						{
							Eoid pId = (Eoid)thePlayer.getTarget();
							if( !myPlayer.getId().equals( pId ) )
							{
								
								String pName = "someone";
								PlayerCharacter theTarget = checkId( pId );
								if( theTarget != null )
									pName = theTarget.getName();
								combatPlayers.append( thePlayer.getName() + " is fighting " +
								pName + "\n" );
							}
						}
						else
						{
							MobKey key = (MobKey)thePlayer.getTarget();
							String name = ((Mob)myState.get( GameState.MOB, key )).getName();
							combatPlayers.append( thePlayer.getName() + " is fighting a " + name + "!" );
						}
					}
				}
			}
			if( nonCombat > 0 )										
				comm.printMessage( playerName, Color.gray );
			comm.printMessage( combatPlayers, Color.blue.darker() );
		}
	}

	/**
	 * Prints the lookup vector
	 */
	private synchronized void printLookup()
	{
		
		if( lookupVector.size() == 0 )
			comm.printMessage( "There is no lookup data." );
		else
		{
			StringBuffer desc = new StringBuffer( "Lookup listing:\n" );
			Iterator lookupIter = lookupVector.iterator();
			while( lookupIter.hasNext() )
			{
				Eoid tempId = (Eoid)lookupIter.next();
				int i = lookupVector.indexOf( tempId );
				desc.append( "(" + i + ") " + (PlayerCharacter)myState.get( GameState.PLAYER, tempId ) + "\n" );
				if( lookupIter.hasNext() )
					desc.append( "\n" );
			
			}
			comm.printMessage( desc );
		}
	}
	
	/**
	 * loads the item data froma file
	 */
	 private synchronized void loadItemData()
	 throws Exception
	 {
	 	File itemFile = new File( "data/items.dat" );
		if( itemFile.exists() )
		{
			FileInputStream itemStream = new FileInputStream( itemFile );
			ObjectInputStream objStream = new ObjectInputStream( itemStream );
			myItemData = (ItemData)objStream.readObject();
			objStream.close();
			itemStream.close();
		}
		else
			throw new Exception( "Item data not found." );
	}
	
	private synchronized void printGear( int slot )
	{
		String id = myPlayer.getGear( slot );
		if( id != null )
		{
			String desc = myItemData.getDesc( id );
			String[] parts = { "body", "two hand", "right hand", "left hand" };
			comm.printMessage( parts[slot] + ": " + desc );
		}
	}
	
	/**
	 * Determines if there is only one player of that name in the session.  If  so, this
	 * returns true, if not, it prints out an error message and returns false.
	 * @@param name The name of the player to check
	 */
	private boolean checkPlayerName( String name )
	{
		boolean retVal = false;
		int numPlayers = myState.getCount( name );
		if( numPlayers == 0 )
			comm.printError( name + " is not in this world." );		
		else if( numPlayers > 1 )
		{
			comm.printError( "There are too many characters of that name.  If you want " +
			"to send a private message or add this player to your friends' listing, you " +
			"must perform a lookup on that name and use the index of the lookup listing " +
			"along with an l command (lsend, ladd) to perform that action."  );
		}
		else
			retVal = true;
		return retVal;
	}
	
	/**
	 * Sets the balance.
	 * @@param balance The setting 
	 */
	private synchronized void setBalance( boolean balance )
	{
		attemptLock();
		hasBalance = balance;
		comm.setStatus( true, hasBalance );
		unlock();
	}	
	
	/**
	 * Sets the consideringDuel variable, which indicated
	 * if this user is consdiering a duel
	 * @@param status The value to set the variable to
	 */
	private synchronized void setConsideringDuel( boolean status )
	{		
		consideringDuel = status;		
	}
	
	/**
	 * Determines if the given command type is a valid in combat 
	 * command.
	 * @@param type The type of the command
	 */
	private synchronized boolean checkValidCombatCommand( int type )
	{
		boolean retVal = false;
		switch( type )
		{
			case Command.ATTACK:
			case Command.SAY:
			case Command.YELL:
			case Command.SEND:			
			case Command.LOOK:
			case Command.CHECK_FRIENDS:
			case Command.ATTACK_NO_TARG:
			case Command.MOVE:
			case Command.LIST:
			case Command.CAST:
			case Command.CAST_NO_TARG:
			case Command.PARTITION:
			case Command.DISPLAY_PART:
			case Command.WHO:
			case Command.DO_REPORT_NOW:
			case Command.CLEAR_SCREEN:
			case Command.SURRENDER:
				retVal = true;
			break;
		}
		return retVal;
		    
	}
	
	/**
	 *  Kills the  mob target and prints out the spoils
	 */
	private synchronized void killMob()
	{
		String mobName = theMobTarget.getName();
		int gold = theMobTarget.getGold();
		int exp = theMobTarget.getExp();
		String dropId = theMobTarget.getDrop();
		String desc = myItemData.getDesc( dropId );		
		comm.printMessage( "You kill the " + mobName + "." );
		comm.printMessage( "You get " + gold + " gold pieces." );
		comm.printMessage( "You earn " + exp + " experience points." );
		if( desc != null )
		{
			comm.printMessage( "You get a " + desc );
			myPlayer.addItem( dropId, 1 );
		}
		
		myPlayer.incrementExp( exp );
		myPlayer.incrementGold( gold );						
		myPlayer.clearTargetData();
		DeathData theInfo = new DeathData( myPlayer.getId(), 
                theMobTarget.getKey() );
                comm.clearCombatLog();
		comm.setActivePlayer( myPlayer );
		if( mySession != null )
			mySession.notifyMobDeath( theInfo, myPartNum );
                theMobTarget = null;
								
	}
	
	/**
	 * Cancels an impendind duel challenge
	 */
	private synchronized void cancelDuel( String reason )
	{		
		if( currentChallenger == null )
		{			
			thePlayerTarget.getHandle().declineDuel( reason, myPlayer.getId(), myPartNum );
			comm.printMessage( "You leave the area and cancel your challenge." );
			setConsideringDuel( false );
		 	thePlayerTarget = null;
		}
		else
		{
			PlayerCharacter thePlayer = (PlayerCharacter)myState.get( GameState.PLAYER, currentChallenger );
			thePlayer.getHandle().declineDuel( reason, thePlayer.getId(), myPartNum );
			comm.printMessage( "Duel challenge cancelled." );
			setConsideringDuel( false );
			currentChallenger = null;
		}
	}	
	
	/** 
	 * This function checks to make sure that the directories needed by the game exist and are valid
	 */
	 private synchronized void checkDirectories()
	 {
	 	File playerDir = new File( "players" );
		File worldDir = new File( "states" );
		File mapDir = new File( "maps" );
		File dataDir = new File( "data" );
		
		if( !playerDir.exists() )
			playerDir.mkdir();
		else
			if( !playerDir.isDirectory() )
			{
				System.err.println( "There is a file names \"players\" but it is not " +
				"a directory. Please move this file to anoter location." );
				System.exit( 1 );
			}
		
		if( !worldDir.exists() 	)
			worldDir.mkdir();
		else
			if( !worldDir.isDirectory() )
			{
				System.err.println( "There is a file names \"states\" but it is not " +
				"a directory. Please move this file to anoter location." );
				System.exit( 1 );
			}
		
		if( !mapDir.exists() )
			 mapDir.mkdir();
		else
			if( !mapDir.isDirectory() )
			{
				System.err.println( "There is a file names \"maps\" but it is not " +
				"a directory. Please move this file to anoter location." );
				System.exit( 1 );
			}
		
		if( !dataDir.exists() )
			 dataDir.mkdir();
		else
			if( !dataDir.isDirectory() )
			{
				System.err.println( "There is a file names \"maps\" but it is not " +
				"a directory. Please move this file to anoter location." );
				System.exit( 1 );
			}			
				
	}
	
	/**
	 * Called whenever the player is changed.  This function first
	 * determines if there is already a world.  If so, it removes the player
	 * from the  player cache, adds the new player character and then sets the myPlayer
	 * variable.  If not, this loads up the default world.
	 * @@param theChar the new player character to use
	 */
	private synchronized void charChanged( PlayerCharacter theChar )
	throws Exception
	{
		// If the world is null, load up the default world.
		// This is primarily for the situation in which the user
		// has just started the game and is creating a new character
		// or loading one.
		if( myMap == null )
		{
d651 6
a656 279
			myMap = World.getWorld( "default" );
			if( myMap == null )
			{
				myMap = new World( new GameState( myHandle, myTimeManager.getTime(), 
				theChar.getId(), this ) );
				myMap.saveWorldData( "default" );				
			}
			myState = myMap.getState();			
			myState.setPCList( this );
			stateName = "default";		
			comm.setStateName( stateName );	
		}
		
		// Save the previous player data, if need be,
		if( myPlayer != null )
		{
			myPlayer.save();
			myState.remove( GameState.PLAYER, myPlayer.getId() );
			myPlayer = null;
		}
		
		// Clear out the player cache, then add the player.
		// Also, set up the state to use this player's id.
		// Also set up the map viewer.
                myState.clear( GameState.PLAYER );
		myState.add( GameState.PLAYER, theChar );		
		myPlayer = (PlayerCharacter)myState.get( GameState.PLAYER, theChar.getId() );
		myState.setId( myPlayer.getId() );
		myMap.setViewer( myMapWindow );
		
		// Attempt to load the friends' listing
		myFriendsList = FriendsList.loadFromFile();
		if( myFriendsList == null || !myFriendsList.getPlayerId().equals( myPlayer.getId() ) )
			myFriendsList = new FriendsList();
		
		myTimeManager.start();		
		
		// All set!  print out the room and start things going
		comm.setActivePlayer( myPlayer );
		comm.clear();
		myMap.warp( 0, 0 );
		printCurrentRoom();		
	}
	
	/*
	 * Checks to make sure the user can perform the attack
	 * @@param atkType The type of attack to perform
	 */
	private String checkAttack( int atkType )
	{
		String retVal = null;
		// A player can kick or punch without a weapon, 
		// but to perform a slash or a thrust attack, they
		// must have something armed.
		if( atkType == StringIntCommand.KICK )
			retVal = new String( "kick" );
		else if( atkType == StringIntCommand.PUNCH )
			retVal = new String( "punch" );
		else
		{
			retVal = myPlayer.getEquippedWeapon();
			if( retVal == null )
				comm.printError( "You cannot perform that attack without a weapon." );
		}		
		return retVal;
	}
	
	/**
	 * This returns whether or not te player can use the spell indicated.
	 * To use a spell, the player must have the scroll in their inventory
	 * and must be of the right level
	 * @@param splId The id of the spell
	 */
	 private boolean checkSpell( String id )
	 {
		boolean retVal = false;
		int amount = myPlayer.getItemAmount( id );
		int level = myItemData.getSpellLevel( id );
		
		// A player can not cast a spell if they are a fighter,
		// not of the correct level, or have none in their
		// inventory
		if( !myItemData.canEquip( id, myPlayer.getPlayerClass() ) )
			comm.printError( "You cannot cast spells." );		 
		else if( level > 0 &&
		    ( amount > 0 && myPlayer.getLevel() >= level ) )
		    	retVal = true;
		else
		{
			comm.printError( id + ": You can not cast that spell. " +
			"You either do not meet the level requirement or you do not have " + 
			"a scroll of that spell in your inventory." );
		}
			
		return retVal;
	 }
	 
	 /**
	  * Attack the player's mob target
	  * @@param damage the amount of damage to do
	  */
	 private void attackMob( int damage )
	 {
	 	theMobTarget.damageMob( damage );
		String mobName = theMobTarget.getName();
		comm.printCombatMessage(
			"You attack the " + mobName + " for " + damage + " damage!",
			Color.yellow.darker(), false );
		if( !theMobTarget.isAlive() )
			killMob();
	 }
	 
	 /**
	  * Attack a player
	  * @@param damage the damage to do
	  */
	 private void attackPlayer( int damage )
	 {
	 	thePlayerTarget.getHandle().printAttack( damage, myPartNum, 
                                                         myPlayer.getId() );
		comm.printCombatMessage( "You attack " + thePlayerTarget.getName() + "!",
		                     Color.blue.darker(), false );	
	 }
	 
	 /**
	  * Starts the balance timer
	  * @@param id The id of the weapon to look at
	  */
	 private void startBalanceTimer( String id )
	 {
	 	hasBalance = false;
		comm.setStatus( true, hasBalance );
		long timer = myItemData.getWeaponDelay( id );
		attackTimer.start( timer );
	}
	
	/**
	 * Determins whether or not the player can fight
	 * also, this will clear out duel data if the player
	 * has been challenged to a fight
	 * @@param nonTarget true iff this came from a non target command
	 *
	 */
	private boolean canAttack( boolean nonTarget )
	{
		boolean retVal = true;
		
		// If the player is already fighting something, they must use 
		// the non combat version of the command ('sl' as opposed to 'sl <target>'
		// Also, a player may not fight something if they have issued a duel
		// challenge.
		if( myPlayer.isInCombat() && !nonTarget )
		{
			retVal = false;
			comm.printError( "You are already in combat. " +
				"Please use the non-target version of these commands." ); 
		}
		else if( consideringDuel && thePlayerTarget != null )
		{
			retVal = false;
			comm.printError( "You have issued a duel challenge and may not attack." );
		}	
			
		//If the player has been issued a duel challenge, clear it
		if( consideringDuel && currentChallenger != null )
		{
			PlayerCharacter temp = 
				(PlayerCharacter)myState.get( GameState.PLAYER, currentChallenger );
			if( temp != null )
				temp.getHandle().declineDuel
					( "engages in combat.", myPlayer.getId(), myPartNum );
			consideringDuel = false;
			currentChallenger = null;
		}		
		return retVal;
	}
	
	 /**
	  * Begins fight ont he player's mob target
	  * @@param dmgId The id of the weapon to use
	  */
	  private void startFight( String dmgId )
	  {		
		if( theMobTarget != null )
		{
			// Get the timestamp, then register the two combatants
			Date ts = theMobTarget.startAttack( myPlayer.getId(), myPlayer.getLocation() );
			myPlayer.registerTarget( theMobTarget.getKey() );
			mySession.registerAttacker
				( myPlayer.getLocation(), theMobTarget.getKey(),
		        	  myPlayer.getId(), ts, myPartNum );						
			
			// Deduct from the monster the amount of damage the player did. 
			int damage = myItemData.getCombatBonus( dmgId );
			attackMob( damage );
			startBalanceTimer( dmgId );
			comm.setTarget( theMobTarget.getName() );
		}
	  }
	  
	  /**
	   * This helper function is used whenever a command comes in to perform 
	   * something that another player does.  Basically, 
	   * it checks to see if the other player is in the state.  If so,
	   * is returns it, if not, it informs the session that an error has been detected
	   * and reports back null
	   * @@param pId The id of the player to check
	   */
	  private PlayerCharacter checkId( Eoid pId )
	  {
		PlayerCharacter retVal = null;
		if( myState.has( GameState.PLAYER, pId ) )
			retVal = (PlayerCharacter)myState.get( GameState.PLAYER, pId );
		else
			mySession.errorDetected( myPlayer.getId(), myPartNum );
		
		return retVal;
	  }
	  
	  /** 
	   * This function is primarily used in the notifyXDeath functions.
	   * It clears the user's local combat information, and then reports
	   * an error to it's session
	   */
	  private void endFightError()
	  {	  	
		myPlayer.clearTargetData();
		thePlayerTarget = null;
		theMobTarget = null;
		comm.clearCombatLog();
		comm.printError( "Your fight has been ended due to a " + 
		                 "synchronization error." );
		mySession.errorDetected(  myPlayer.getId(), myPartNum );
	  }				
	  
	  /**
	   * This function checks to see if the player is at the given location
	   * if not, it moves them there
	   * @@param thePlayer The player to check
	   * @@param theLoc The location they should be at
	   */
	  private void checkLocation( PlayerCharacter thePlayer, XYloc theLoc )
	  {
	  	if( !thePlayer.getLocation().equals( theLoc ) && theLoc != null )
			myMap.performWarp( thePlayer.getId(), theLoc );
	  }
/********************************************************************************************************************************/		
	/**.
	 * This is the primary function of the GameSystem, the execute function.  
	 * The purpose of this function is to execute the user's command to the system,
	 * which has been packaged by the Parser.
	 * @@param command The command to execute
	 */
	 public synchronized void execute( Command command )
	 throws Exception
	 {	 						
		attemptLock();		
		// If there is no player, a user may only execute a create or load player command
		if( myPlayer == null && 
		    ( command.getType() != Command.CREATE &&
		      command.getType() != Command.LOAD  &&
		      command.getType() != Command.INVALID_COMMAND )
		  )		     
		{
			comm.printError( "Cannot execute other commands without having a character." );
			comm.printError( "Please load a character or create a new one." );
		}
		// users can only perform certain commands while in combat
		else if( ( myPlayer != null && myPlayer.isInCombat() )
		         && !checkValidCombatCommand( command.getType() ) )
		{
			comm.printError( "You are in combat and may not perform that command!" );
		}
		else
		{		
		switch( command.getType() )
		{
			case Command.CREATE:
			{
d658 1969
a2626 127
				if( inSession )
					comm.printError( "You are already in a session." );
				else
				{					
					// Character creation
                                       PlayerCharacter temp = PlayerCharacter.loadCharacterDataFromFile
                                       ( mySession, ((PlayerCreationCommand)command).name );
                                       if( temp != null )
                                       {
                                           // If a character already exists with the given name, 
					   // the user may not reuse that name
					   comm.printError( "That character already exists.");
                                           comm.printError( "Please delete the character or create one " +
                                           "with a different name");
                                       }
                                       else
                                       {    
                                          
					    // Create the new character, and then place them into the
					    // default world
					    temp = PlayerCharacter.createNewCharacter(					
					          (PlayerCreationCommand)command, myHandle );
                                            if( temp != null )					    	
                                                charChanged( temp );
                                            else
                                            {
                                                    String className = ((PlayerCreationCommand)command).clas;
                                                    comm.printError( className + ": invalid player class." );
                                            }
                                       }
				}
				
			}
			break;			
			case Command.LOOK:
			{
				printCurrentRoom();					
			}					
			break;
			case Command.LIST:
				comm.printMessage( myPlayer );				
			break;
			case Command.MOVE:	
			{				
				// You can't move if you are in combat with another player, in a house,
				// or have just taken an action
				if( !hasBalance )
					comm.printError( "You are regaining your balance and may not move yet." );
				else if( myPlayer.isInHouse() )
					comm.printError( "You are in a house and cannot move in any direction.  You must "+ 
						         "leave the house first." );
				else if( myPlayer.isInCombat() && theMobTarget == null )
					comm.printError( "You are engaged in combat with another player and can not leave " +
						         "the area until combat is done." );				
				else
				{
					// Otherwise, if the player is in combat with a mob and the move, 
					// they are running from the mob
					if( myPlayer.isInCombat() && thePlayerTarget == null )
					{
						Mob theMob = (Mob)myState.get( GameState.MOB, 
						(MobKey)myPlayer.getTarget() );
						theMob.stopAttack( );
						myPlayer.clearTargetData();
						comm.clearCombatLog();
						comm.printMessage( "You disengage combat with " + theMob.getName() + "!" );
					}										
					
					// Have the map create the move data
					UserMove movement = myMap.doPlayerMove( ((IntCommand)command).getIntData() );				
					if( movement != null )
					{
						myPlayer.updateLocation( movement.getLoc( MoveData.TO ) ); 
						
						// Prints out the room, finish filling in the data
						printCurrentRoom();
						movement.setUser( myPlayer.getId() );
						
						// If the user is considering a duel, cancel it
						if( consideringDuel )
							cancelDuel( " has left the area. Challenge Cancelled." );
							
						// Finally inform everyone of the move
						if( mySession != null )
						{							
							mySession.processMove( movement, myPartNum );
						}
					}					
					else
						comm.printError( "You can not move in that direction." );
				}
			}			                                                                               

			break;
			case Command.YELL:
			{	
				comm.printMessage( "You yell, \"" + ((StringCommand)command).getStringData() + "\"" );
				SayData sd = new SayData( myPlayer.getId(), myMap.getCurrentPlayerLocation(),
						          ((StringCommand)command).getStringData()  );
				if( mySession != null )
					mySession.yell( sd, myPartNum );	
			}
			break;
			case Command.CREATE_GAME:
			{
				if( inSession )
					comm.printError( "You are already in a session." );
				else if( leftSession )
					comm.printError( "You have left your session or have been removed.  Please " +
					                 "exit out of the game before trying to create a new one." );
				else
				{										
					// Set up the Session handle, create the merchants and
					// the mobs, start the player refreshers
					inSession = true;										
					mySessionName = ((StringCommand)command).getStringData();
					mySession = (Game)M2MI.getMultihandle( Game.class );					
					((Multihandle)mySession).attach( this );																									
					myMap.spawnMerchants( this );
					myMap.spawnMobs( this );																																															
					scheduleNormalReport();		
					myPlayerRefresher = new PlayerRefresher( myPlayer.getId(), mySession );
					myPlayerRefresher.start();				
					comm.printMessage( "\nGame " + mySessionName + " created!" );						
				}
			}
			break;                                                                               
a2627 870
			case Command.FIND_GAMES:
			{
				// Can't look for a new game if the user is one already.
				// Also, after leaving a game, they must quit out of the program first.
				if( inSession )
					comm.printError( "You must first leave your current session before joining a new one." );
				else if( leftSession )
					comm.printError( "You have left your session, or have been removed.  Please" + 
						         "quit the game before trying to find a new one." );
				else
				{					
					comm.printMessage( "Looking for games" );
					comm.disable();
					GameChooser gameChooser = new GameChooser();
					sessionFinder = new SessionFinder( gameChooser );
					sessionFinder.export();
					GameChooserWindow gameChooserWindow = new GameChooserWindow( gameChooser, this );	
					gameChooserWindow.setVisible( true );											
				}
			}
			break;						
			case Command.LEAVE_SESSION:
			{
				if( !inSession )
					comm.printError( "You are not currently in a session." );
				else
				{
					comm.printMessage( "You leave your session." );
					leave();
				}
			}
			break;
			case Command.WHO:
			{
				                                                                             
				comm.printMessage( "\nPlayer currently in the session: " );
				comm.printMessage( myState.getPlayerCacheString() );

			}			
			break;
			case Command.SAY:
			{
				comm.printMessage( "You say, \"" + ((StringCommand)command).getStringData() + "\"" );
				if( mySession != null )
				{
					SayData myMessage = new SayData( myPlayer.getId(),myMap.getCurrentPlayerLocation(),
					                                ((StringCommand)command).getStringData() );
					mySession.say( myMessage, myPartNum );
				}				
			}
			break;
			case Command.DIG_POND:
			{
				
                                if( myMap.getCurrentRoomType() == Room.WATER )
                                    comm.printError( "You can not dig a pond where there is water!" );
                                else if( myMap.digPond() == false )
					comm.printError( "There is already a pond here." );
                                
				else					
				{                                                                               

					comm.printMessage( "You dig a small pond in the earth." );
					if( mySession != null )					
						mySession.setPond( myMap.getCurrentPlayerLocation(), myPlayer.getId(), myPartNum );					
				}
			}
			break;
			case Command.HOUSE_CREATE:
			{
				if( !myState.has( GameState.HOUSE, myPlayer.getId() ) )
				{				
					if( myMap.getCurrentRoomType() != Room.WATER )
                                        {
                                            House newHouse = new House( myPlayer,
					 	          (HouseCreationCommand)command );
                                            myMap.placeHouse( newHouse );				
                                            comm.printMessage( "You place your house at " + newHouse.getLocation() );
                                            if( mySession != null )
						mySession.addHouse( newHouse, myPartNum );
                                        }
                                        else
                                            comm.printError( "You may not build a house on water!" );
				}
				else
				{
					House temp = (House)myState.get( GameState.HOUSE, myPlayer.getId() );
					comm.printError( "You already have a house at " + temp.getLocation() );
				}
			}
			break;
			case Command.SESSION_COMMAND:
			{
				
			}
			break;
			case Command.TIME:
			{
				String times[] = { "early morning", "morning", "early afternoon", 
						 "late afternoon", "early evening", "evening" };
				String timeMessage = new String( "It is " + times[myTimeManager.getTime()] + "." );
				comm.printMessage( timeMessage );
			}
			break;	
			case Command.GOTO:
			{
				// The coordinates the player gives must be withing the bounds of the map.
				int x = ((GotoCommand)command).getLoc().x;
				int y = ((GotoCommand)command).getLoc().y;
				if( ( 0 <= x && x < myMap.getMaxX() ) &&
				    ( 0 <= y && y < myMap.getMaxY() ) )
				{
					// Don't warp if the player is staying in the same location
					if( !myMap.getCurrentPlayerLocation().equals( new XYloc( x, y ) ) )
					{
						XYloc temp = new XYloc( myMap.getCurrentPlayerLocation() );
						comm.printMessage( "Warping you to location (" + x + ", " + y + ")" );
						myMap.warp( x, y );									
						printCurrentRoom();
						if( mySession != null )
							mySession.warp( myPlayer.getId(), temp, 
							myMap.getCurrentPlayerLocation(), myPartNum );
					}
					
				}
				else
					comm.printError( "You cannot warp to that location." );
			}
			break;
			case Command.LIST_WARES:
			{
				// This is simple: get the merchant type, then use the ItemData
				// object to get the list of all the items that merchant sells.
				int type = myMap.getMerchantType();
				if( type != -1 )
				{
					comm.printMessage( "\nThe merchant has the following items for sale: " );
					Iterator itemId = myItemData.getIdVector( type ).iterator();
					while( itemId.hasNext() )
					{
						String id = (String)itemId.next();
						String desc = myItemData.getDesc( id );
						int cost = myItemData.lookupCost( id );
						if( cost > 0 )
							comm.printMessage( id + ": " + desc + ", cost " + cost + "gold pieces" );
					}
				}
				else
					comm.printError( "There is no merchant here." );		
			}
			break;			
			case Command.BUY:
			{									
				int type = myMap.getMerchantType();
				if( type != -1 )
				{				
					String id = ((StringIntCommand)command).getStringData();
					int amount = ((StringIntCommand)command).getIntData();
					Vector merchItems = myItemData.getIdVector( type );
					// Obviously, in order to buy something, them merchant must
					// have the item in stock, and the user must be able to afford
					// the quantity they have specifed.
					if( merchItems.indexOf( id ) != -1 )
					{
						int totalCost = amount * myItemData.lookupCost( id );
						if( myPlayer.canAfford( totalCost ) )
						{
							// Adjust the user's inventory and gold
							myPlayer.addItem( id, amount );
								myPlayer.decrementGold( totalCost );
							String desc = myItemData.getDesc( id );
							comm.printMessage
							( "You buy the " + desc + " for " + totalCost +
							  " gold pieces." ); 
							comm.setActivePlayer( myPlayer );
						}
						else
							comm.printMessage( "You can't afford that!" );
					}
					else
						comm.printMessage( "That item is not for sale." );
				}
				else
					comm.printError( "There is no merchant here." );
			}
			break;
			case Command.SELL:
			{
				int type = myMap.getMerchantType();
				if( type != -1 )
				{
					String id = ((StringIntCommand)command).getStringData();
					int amount = ((StringIntCommand)command).getIntData();
					int sellAmount = myPlayer.getItemAmount( id );
					// To be able to sell something, the user must 
					// have at least one in their inventory. 
					if( sellAmount > 0 )
					{
						int finalAmount = 0;
						if( amount > sellAmount )
							finalAmount = sellAmount;
						else
							finalAmount = amount;
						// Again, adjust the user's inventory and gold space
						myPlayer.addItem( id, -1 * finalAmount );								
						int amountEarned = finalAmount * myItemData.lookupSellValue( id );
						myPlayer.incrementGold( amountEarned );
						comm.printMessage( "You sell " + finalAmount + " of " + 
					        	            myItemData.getDesc( id ) + " for " + amountEarned + 
								    " goldPieces." );
						comm.setActivePlayer( myPlayer );								    
					}
					else
						comm.printMessage( "You do not have any of that item." );		
				}
				else
					comm.printMessage( "There is no merchant here." );
			}
			break;			
			case Command.LOOKUP:
			{
				// The lookup gets all the players that have the given name and places
				// them into a list with their player ID
				String pName = ((StringCommand)command).getStringData();
				comm.printMessage( "Performing lookup for " + pName );
				lookupVector.clear();
				myState.doLookup( pName, lookupVector );
				printLookup();
			}
			break;
			case Command.ADD:
			{
				// Adds a player to the friends' list
				String pName = ((StringCommand)command).getStringData();
				if( checkPlayerName( pName ) )
				{
					myFriendsList.addPlayer( myState.getPlayerByName( pName ) );
					comm.printMessage( pName + " has been added to your friends\' "
					+ " listing." );
				}
			
			}
			break;
			case Command.SEND:
			{
				String pName = ((SendCommand)command).getUserName();
				if( checkPlayerName( pName ) )				
				{
					Game theHandle = myState.getPlayerByName( pName ).getHandle();
					theHandle.sendPM( myPlayer.getId(), ((SendCommand)command).getStringData(), myPartNum );
					comm.printMessage( "You send, \"" + ((SendCommand)command).getStringData() + 
					"\" to " + pName + "." 	);	
				}
			}
			break;			
			case Command.INVENTORY:
			{
				// Print out the user's inventory and gold
				comm.printMessage( "\nYou have the following items in your inventory: " );
				comm.printMessage( myPlayer.getCurrentGold() + " gold pieces." );
				Iterator items = myPlayer.getInventoryKeys();
				while( items.hasNext() )
				{
					String id = (String)items.next();
					int amount = myPlayer.getItemAmount( id );
					String desc = myItemData.getDesc( id );
					if( amount > 0 )
						comm.printMessage( id + ": " + desc +  ", number: " + amount );
				}
				
				// Print out the user's equipment
				comm.printMessage( "\nYou are equiped in the follow gear: " );
				printGear( PlayerCharacter.BODY );
				printGear( PlayerCharacter.RIGHT_HAND );
				printGear( PlayerCharacter.LEFT_HAND );
				printGear( PlayerCharacter.TWO_HAND );
			}
			break;
			case Command.CHECK_FRIENDS:
			{
				// This simply prints out whether or not a player on the user's
				// friends' listing is in the same sessin as she is.
				if( myFriendsList.size() == 0 )
					comm.printMessage( "There are no players on your friends listing." );
				else
				{
					Iterator friends = myFriendsList.getPlayers();
					int i = 0;
					while( friends.hasNext() )
					{
						Eoid tempKey = (Eoid)friends.next();
						String name = myFriendsList.getName( tempKey );
						if( myState.has( GameState.PLAYER, tempKey )  )
							comm.printMessage( 
							"(" + i + ") " + name + " (" + tempKey + ") " +
							 " is in this session." );					
						else
							comm.printMessage( 
							"(" + i + ") " + name + " (" + tempKey + ") "
							 + " is not in this session." );
						i++;
					}
				}
			}
			break;
			case Command.LCHECK:
			{
				// This allows a player to see if a player on the lookup listing
				// is in their friends' listing.
				IntCommand iComm = (IntCommand)command;
				Eoid playerId = null;
				if( lookupVector.size() > iComm.getIntData() )
					playerId = (Eoid)lookupVector.elementAt( iComm.getIntData() );
				
				if( myFriendsList.hasPlayer( playerId ) )
				{
					comm.printMessage( myFriendsList.getName( playerId ) + " (" + 
					playerId + ") is in your friends' listing." );
				}
				else
				{
					comm.printMessage( myFriendsList.getName( playerId ) + " (" + 
					playerId + ") is not in your friends' listing." );					
				}
			}
			break;
			case Command.LSEND:
			{
				// A send command, but this sends the message to the user
				// with associated with the given index in the lookup listing, rather than 
				// the give name.
				if( lookupVector.size() <= 0 )
					comm.printError( "There is no lookup data.  Please perform a lookup." );
				else
				{
					SendCommand sComm = (SendCommand)command;
					Eoid playerId = null;
					if( lookupVector.size() > sComm.getLookupIndex() )
					{
						playerId = (Eoid)lookupVector.elementAt( sComm.getLookupIndex() );
						PlayerCharacter sendPlayer =
						(PlayerCharacter)myState.get( GameState.PLAYER, playerId );
						if( sendPlayer != null )
						{
							Game sendHandle = sendPlayer.getHandle();
							sendHandle.sendPM( myPlayer.getId(),
							sComm.getStringData(), myPartNum );
							comm.printMessage
							( "You send, \"" + sComm.getStringData() + "\" to " + 
							  sendPlayer.getName() );
						}	
					}
					else
						comm.printError( "That index is invalid." );					
				}
			}
			break;
			case Command.LADD:
			{
				// Adds the user at the specified position in the lookup listing 
				// to the user's friends' listing.
				if( lookupVector.size() <= 0 )
					comm.printError( "There is no lookup data.  Please perform a lookup." );
				else
				{
					IntCommand iComm = (IntCommand)command;
					Eoid playerId = null;
					if( lookupVector.size() > iComm.getIntData() )
					{
						playerId = (Eoid)lookupVector.elementAt( iComm.getIntData() );
						PlayerCharacter temp = (PlayerCharacter)myState.get( GameState.PLAYER, playerId );
						if( temp != null )
						{
							myFriendsList.addPlayer( temp );
							comm.printMessage
							( temp.getName() + " has been added from your friends' listing." );
						}
					}
					else
						comm.printError( "That index is invalid." );
				}
				
			}
			break;
			case Command.LLIST:
			{				
					printLookup();
			}
			break;	
			case Command.REMOVE:
			{
				// Removes the player from the friends' listing.
				String name = myFriendsList.removePlayer( ((IntCommand)command).getIntData() );
				if( name != null )
					comm.printMessage( name + "  has been removed from your friends' listing." );
				else
					comm.printError( "That index is not valid." );
			}
			break;
			
			case Command.EQUIP:
			{
				StringCommand eComm = (StringCommand)command;
				String id = eComm.getStringData();
				int slot = -1;			
				
				// First check to make sure the player has the given item
				if( myPlayer.getItemAmount( id ) <= 0 )
					comm.printError( "You do not have that item." );
				else if( !myItemData.canEquip( id, myPlayer.getPlayerClass() ) )
					//Then check to make sure they can equip it
					comm.printError( "Your class may not equip this item." );
				else
				{	
					// Determine which slot (if any) the given item
					// gets equipped to
					switch( myItemData.getItemType( id ) ) 
					{
						case ItemData.ARMOR:
					 		slot = PlayerCharacter.BODY;
						break;
						case ItemData.WEAPON_2_HAND:
							slot = PlayerCharacter.TWO_HAND;
						break;
						case ItemData.WEAPON_1_HAND:
							slot = PlayerCharacter.RIGHT_HAND;
						break;		
					}
					if( slot == -1 )
						comm.printError( "You can't equip that item!" );									
					else
					{
						// Equip the item and tell the user
						myPlayer.equipItem( id, slot );
						String desc = myItemData.getDesc( id );
						if( slot == PlayerCharacter.BODY )
							comm.printMessage( "You put on " + desc );
						else
							comm.printMessage( "You begin wearing " + desc );	
					}
				}			
			}
			break;
			case Command.ATTACK:
			{
				int type = ((StringIntCommand)command).getIntData();
				String weapon = checkAttack( type );
				
				// So far, everything is good.  Begin combat on the monster
				if( canAttack( false ) && weapon != null )
				{
					// Ensure the mob is valid (exists and is not fighting already
					String mobName = ((StringIntCommand)command).getStringData();
					theMobTarget = myMap.getFreeMob( mobName );
					if( theMobTarget == null )
						comm.printError( "Either that mob does not exists, or all members of that species " +
						                 "are already in combat in this area." );
					else
						startFight( weapon );
				}
				else 				
					comm.printError( "You may not perform that attack without a weapon." );
				
			}
			break;
			case Command.ATTACK_NO_TARG:
			{				
				int type = ((IntCommand)command).getIntData();
				String weapon = checkAttack( type );
				if( weapon != null )
				{
					int damage = myItemData.getCombatBonus( weapon );
					if( hasBalance )
					{
						if( thePlayerTarget == null && theMobTarget == null )
							comm.printMessage( "You visciously attack the air around you!" );
						else if( myPlayer.hasMobTarget() )						
							attackMob( damage );							
						else
							attackPlayer( damage );
						startBalanceTimer( weapon );						
					}
					else
						comm.printCombatMessage( "You are regaining your balance after the last" + 
								           " attack!", Color.yellow.darker(),false );
				}												
			}
			break;
			case Command.CHALLENGE:
			{
				boolean canAttack = true;
				// If the player is in a house they may not challenge someone, also
				// a player may only have challenge issed at on time.
				if( myPlayer.isInHouse() )
				{
					comm.printError( "You may not challenge while in a house." );
					canAttack = false;
				}
				if( consideringDuel )
				{
					comm.printError( "You have already issued one challenge." );
					canAttack = false;
				}
				
				if( !myMap.currentAreaHasPlayers() )
				{
					comm.printError( "There are no players in this room." );
					canAttack = false;
				}
				
				if( canAttack )
				{
					
					// What this does is perform a lookup on all users of the given name
					// in the same room as the player. If there are more than one, the user
					// and her target must move to another room to fight each other. 
					String pName = ((StringCommand)command).getStringData();
					Iterator players = myMap.getCurrentAreaPlayers();
					int count = 0;
					Vector ids = new Vector();
					while( players.hasNext() )
					{
						Eoid pId = (Eoid)players.next();
						if( pName.equals( ((PlayerCharacter)myState.get( GameState.PLAYER, pId )).getName() ) )
							ids.add( pId );
					}
					if( ids.size() == 0 )
					{
						comm.printError( "There are no players of that name here." );
					}
					else if( ids.size() > 1 )
					{
						comm.printError( "There are too many players here of that name." +
								 "You and the player you wish to fight must move to a new location." );
					}
					else
					{
						Eoid pId = (Eoid)ids.elementAt( 0 );
						thePlayerTarget = (PlayerCharacter)myState.get( GameState.PLAYER, pId );
						
						// If the other player is already fighting or is in ahouse
						// the user may not challenge them.
						if( thePlayerTarget.isInCombat() )
						{
							comm.printMessage( "That player is in combat already." );
							thePlayerTarget = null;
						}
						else if( thePlayerTarget.isInHouse() )
						{
							comm.printMessage( "You may not challenge someone while " + 
							                   "(s)he is in a house." );
						}
						else
						{
							Game theGame = thePlayerTarget.getHandle();
							theGame.requestDuel( myPlayer.getId(), myPartNum );
							comm.printMessage( "You challenge " + thePlayerTarget.getName() + 
							" to a duel!" );
							setConsideringDuel( true );							
						}						
					}	
				}
			}
			break;	
			case Command.DECLINE:
			{
				// This declines another player's duel challenge.
				if( !consideringDuel )
					comm.printError( "You are not considering a duel." );
				else if( consideringDuel && currentChallenger == null )
					comm.printError( "You have issued a challenge, command ignored." );
				else
				{				
					String pName = ((PlayerCharacter)myState.get( GameState.PLAYER, currentChallenger )).getName();
					Game theHandle =((PlayerCharacter)myState.get( GameState.PLAYER, currentChallenger )).getHandle();
					comm.printMessage( "You have declined " + pName + "\'s challenge." );
					theHandle.declineDuel( " has declined your challenge.", myPlayer.getId(),
					myPartNum );
					setConsideringDuel( false );
					currentChallenger = null;
				}
			}
			break;		
			case Command.ACCEPT:
			{
				// This accepts the player's duel challenge and places the local player into
				// combat.
				if( !consideringDuel )
					comm.printError( "You are not considering a duel." );
				else if( consideringDuel && currentChallenger == null )
					comm.printError( "You have issued a duel challenge.  Command ignored." );
				else
				{
					PlayerCharacter theChallenger = checkId( currentChallenger );
					String pName = theChallenger.getName();
					Game theHandle = theChallenger.getHandle();
					theHandle.acceptDuel( myPlayer.getId(), myPartNum );
					thePlayerTarget = theChallenger;
					myPlayer.registerTarget( currentChallenger );
					currentChallenger = null;
					mySession.notifyFight( thePlayerTarget.getId(), myPlayer.getId(), 
					myMap.getCurrentPlayerLocation(), myPartNum );
					setConsideringDuel( false );
					comm.printMessage( "You have accepted " + pName + "\'s challenge. Begin fighting!" );	
					comm.setTarget( thePlayerTarget.getName() );				
				}
			}
			break;
			case Command.MAP:
			{
				myMapWindow.setVisible( !myMapWindow.isVisible() );
			}
			break;
			case Command.LOAD:
			{
				if( inSession )
					comm.printError( "You are in a session and may not change any data." );
				else
				{					
					StringIntCommand siComm = (StringIntCommand)command;
					switch( siComm.getIntData() )
					{
						case StringIntCommand.PLAYER:
						{	
							String pName = siComm.getStringData();
							PlayerCharacter loadPlay = 
								PlayerCharacter.loadCharacterDataFromFile
								( myHandle, pName );
							if( loadPlay == null )
								comm.printError( "Player " + pName + " not found." );
							else
                                                        {
                                                           PlayerCharacter temp =  PlayerCharacter.createNewCharacter( loadPlay, myHandle );
                                                            charChanged( temp );
                                                        }
						}
						break;
						case StringIntCommand.MAP:
						{
							String fileName = new String
							( "maps/" + siComm.getStringData() + ".map" );
							File theFile = new File( fileName );
							if( myPlayer == null )
								comm.printError( "You may not execute this command now." );
							else if( !theFile.exists() )
								comm.printError( fileName + ": map file not found." );
							else
							{								
								myState.clear();
								WorldConfiguration theConfig = new 
									WorldConfiguration( theFile );								
								myMap.createWorld( theConfig );
								comm.clear();
								stateName = new String( "(No state name.)");
								comm.setStateName( stateName );	
								myMap.warp( 0, 0 );
								printCurrentRoom();	
								myState.add( GameState.PLAYER, myPlayer );
								myPlayer = (PlayerCharacter)myState.get( GameState.PLAYER, 
										         myPlayer.getId() );						
							}	
					
						}
						break;
						case StringIntCommand.WORLD:
						{	
													
							
							if( myPlayer == null )	
								comm.printError( "You may not execute this command now." );
							else
							{
								stateName = siComm.getStringData();
								World temp = World.getWorld( stateName );
								if( temp == null )
									comm.printError( "State not found." );							
								else
								{								
									myMap = temp;																		
									myState = myMap.getState();
									myState.add( GameState.PLAYER, myPlayer );		
									myState.setPCList( this );
									myState.setId( myPlayer.getId() );
									
									myMap.setViewer( myMapWindow );		
									comm.clear();
									comm.setStateName( stateName );
									myMap.warp( 0, 0 );
									myMap.setViewer( myMapWindow );
									printCurrentRoom();
									
									myPlayer = (PlayerCharacter)myState.get( GameState.PLAYER, 
										     myPlayer.getId() );									
								}
							}
						}
						break;
					}
					
				}	
			}
			break;
			case Command.SAVE:
			{
				StringIntCommand siComm = (StringIntCommand)command;
				switch( siComm.getIntData() )
				{
					case StringIntCommand.WORLD:
					{
						if( inSession )
							comm.printError( "You must leave the session before saving the state " +
									 "data." );
						else
						{									
							
							String fileName = "states/" + siComm.getStringData() + ".dat";
							File theFile = new File( fileName );
							if( theFile.exists() )
								comm.printError( fileName + ": file already exists." );
							else
							{
								stateName = siComm.getStringData();
								comm.setStateName( stateName );
								myMap.saveWorldData( stateName );
                                                                comm.printMessage( "Session saved!");
							}
								

						}
					}
					break;
					case StringIntCommand.MAP:
					{
						String fileName = "maps/" + siComm.getStringData() + ".map";
						File theFile = new File( fileName );
						if( theFile.exists() )
							comm.printError( fileName + ": file already exists." );
						else
						{
							if( myState.getConfig() != null )
							{
								FileWriter fw = new FileWriter( theFile );
								BufferedWriter writer = new BufferedWriter( fw );
								String data =  myState.getConfig().toString();							
								writer.write( data, 0, data.length() );
								writer.close();
								fw.close();
                                                                comm.printMessage( "Map saved! ");
							}
						}
					}
				}				
			}
			break;
			case Command.SAVE_QUICK:
			{
				if( inSession )
					comm.printError( "You must leave the session before saving." );
				else
				{
					if( stateName == null )
						comm.printError( "You must first specify a state name using the " + 
						"\"save world <state-name>\" command." );
					else						
						myMap.saveWorldData( stateName );				
				}
				comm.printMessage( "Session saved!" );
			}
			break;
			case Command.STATE_REMOVE:
			{
				if( !inSession )
					myMap.remove( ((IntCommand)command).getIntData() );
				else
					comm.printError( "You are in a session and can not remove that object." );
			}
			break;
			case Command.USE: 
			{
				String id = ((StringCommand)command).getStringData();
				if( myPlayer.getItemAmount( id ) == 0  )
					comm.printError( "You do not have any of that item." );
				else
				{
					int healAmount = myItemData.getHealAmount( id );
					if( healAmount == -1 )
						comm.printError( "You may not use that item." );
					else
					{
						if( myItemData.getHealWhich( id ) == ItemData.HEALTH ) 
							myPlayer.adjustHP( healAmount );
						myPlayer.addItem( id, -1 );	
						comm.printMessage( "You use the " + myItemData.getDesc( id ) );
						comm.setActivePlayer( myPlayer );					
					}	
				}
			}
			break;
			case Command.PARTITION:
			{
				if( inSession )
				{
					int part = ((IntCommand)command).getIntData();					
					myPartNum = part;				
					myState.setPartNum( part );
					myPlayerRefresher.setPartition( part );
					comm.printMessage
					( "Partition set to " + myPartNum );
				}
				else
					comm.printError( "You need to be in a session." );
			}
			break;
			case Command.ENTER:
			case Command.HOUSE_ENTER:
			{
				int houseNum = ((IntCommand)command).getIntData();
				if( myMap.enterHouse( houseNum ) )
				{
					printCurrentRoom();
					if( inSession )
						mySession.moveHouse( myPlayer.getId(), myMap.getHouseId(), 
							             true, myPartNum );
					
				}
				else
					comm.printError( "You can not enter that house." );
			}
			break;
			case Command.CAST_NO_TARG:
			{
				String splId = ((StringCommand)command).getStringData();
				if( checkSpell( splId ) )
				{	
					if( hasBalance )
					{						
						
						
						if( myPlayer.isInCombat() )
						{						
							comm.printCombatMessage( "You cast a spell!", Color.black, true );	
							int damage = myItemData.getCombatBonus( splId );
							if( myPlayer.hasMobTarget() )
								attackMob( damage );
							else 
								attackPlayer( damage );						
											
						}
						else
							comm.printMessage( "You cast a spell into the air around you!" );
					}
					else
						comm.printError( "You are recovering from your last cast!" );
						
					startBalanceTimer( splId );
				}
			}
			break;
			case Command.CAST:
			{
				String splId = ((CastCommand)command).getSpellId();
				String mobId = ((CastCommand)command).getMobName();				
				if( canAttack( false ) && checkSpell( splId ) )
				{
					theMobTarget = myMap.getFreeMob( mobId );
					if( theMobTarget != null )
						startFight( splId );
					else
						comm.printError( "That mob does not exist, or all creatures " +
						"of that type are in combat already in this area." );
a2628 90
				}							
			}
			break;
			case Command.LEAVE_HOUSE:
			{
				if( !myPlayer.isInHouse() )
					comm.printError( "You are not in a house." );
				else
				{					
					if( inSession )
						mySession.moveHouse( myPlayer.getId(), myMap.getHouseId(), 
							             false, myPartNum );
					myMap.leaveHouse();
					printCurrentRoom();	
                                        myPlayer.leaveHouse();
				}
					
			}
			break;
			case Command.DISPLAY_PART:
			{
				comm.printMessage
				( "Current partition: "  + myPartNum );
			}			
			break;
			case Command.CLEAR_SCREEN:
			{
				comm.clear();
				printCurrentRoom();
			}
			break;
			case Command.DO_REPORT_NOW:
			{
				if( inSession )
				{
					comm.printMessage( "Doing report now." );
					reportTimer.start( 5000 );
				}
			}
			break;
			case Command.SURRENDER:
			{
				if( !myPlayer.isInCombat() || myPlayer.hasMobTarget() )
					comm.printError( "You must be fighting another player to execute " + 
					"this command." );
				else
				{
					comm.printMessage
					( "You surrender to " +
					  thePlayerTarget.getName() );
					myPlayer.clearTargetData();
					comm.clearCombatLog();					
					thePlayerTarget.clearTargetData();				
					thePlayerTarget = null;
					mySession.surrender( myPartNum, myPlayer.getId() );	
				}
			}
			break;
			case Command.MOB_COMMAND:
			{
				MobCommand mCommand = (MobCommand)command;
				Mob theMob = (Mob)myState.get( GameState.MOB, mCommand.getKey() );
				if( theMob != null )
				{
					if( mCommand.getMobCmdType() == MobCommand.KILL )
					{
						theMob.kill();
						DeathData info = new DeathData( myPlayer.getId(), theMob.getKey() );
						mySession.notifyMobDeath( info, myPartNum );
					}
					else if( mCommand.getMobCmdType() == MobCommand.FIND )
						comm.printMessage( theMob.getName() + ": " + 
						                   theMob.getCurrentLocation() );
					
					else
						theMob.doNow( mCommand.getMobCmdType() );
				}
				else	
					comm.printError( mCommand.getKey() + ": Invalid MobKey" );
			}
			break;
                    case Command.PRINT_MOBS:
                        {                    
                            Iterator theMobs = myState.getCollection( GameState.MOB );
                            while( theMobs.hasNext() ) 
                            {
                                Mob theMob = (Mob)theMobs.next();
                                comm.printMessage( theMob.getName() + 
                                "(" + theMob.getKey() + ")" +
                                " " + theMob.getCurrentLocation( ));
d2632 214
a2845 15
			case Command.QUIT:
			{									
				if( inSession )
					comm.printError( "You may not quit until you leave the session." );
				else
				{
					myPlayer.save();
					System.exit( 0 );					
				}
			}			
			break;
		}
		}	
		unlock();						
	}	  
@


1.29
log
@*** empty log message ***
@
text
@d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.28 2004/11/11 04:28:30 rjw2183 Exp rjw2183 $
d144 2
a145 2
		comm.printMessage( "Upon obtaining a character, they will be placed into the default world, " +
				   "from where you can load up another world to begin play." );
a331 1
							comm.setTarget( "" );
d410 5
a763 1
				comm.setTarget( "" );			
a856 1
							comm.setTarget( "" );
d960 3
a962 1
			if( !myPlayer.getId().equals( pId ) )
a963 2
			else
				scheduleEmergencyReport();
d1056 3
a1058 2
                        if( myState.equals( theAd.sessionState ) )							                                                                            
			    scheduleNormalReport();
d1075 2
a1076 2
				// emergency report to get out the changes asap.
				scheduleEmergencyReport();
d1298 1
a1298 2

		try{
a1310 1
			comm.setTarget( "" );
d1315 1
a1315 7
                        comm.setTarget( "" );						
		}
		}
		catch( Exception e )
		{
			e.printStackTrace();
		}			  
d1402 1
a1402 1
					comm.setTarget( "" );
a1695 1
		comm.setTarget( "" );
d1953 1
a1953 1
			comm.printError( "You have issues a duel challenge and may not attack." );
d1989 1
a1989 1
			//comm.setTarget( theMobTarget.getName() );
d2018 2
a2019 2
	  {
	  	myPlayer.clearTargetData();
a2022 1
		comm.setTarget( "" );
d2125 2
a2126 2
					comm.printError( "You are engaged in combat with another player and can not leave" +
						         " the area until combat is done." );				
a2138 1
						comm.setTarget( "" );
d2209 1
a2209 1
						         "quit of the game before trying to find a new one." );
d3085 2
a3086 1
					printCurrentRoom();					
d3120 1
a3120 1
					( "You surrender and end your fight with " +
a3126 1
					comm.setTarget( "" );
d3168 1
a3168 1
					comm.printError( "You may not quit until you leave a session." );
@


1.28
log
@*** empty log message ***
@
text
@d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.27 2004/10/21 02:47:38 rjw2183 Exp rjw2183 $
d67 1
d81 2
d151 1
a151 1
		mobMover = new Random();				
d257 1
a257 10
			myState.setTime( myTimeManager.getTime() );			
			
			// Update the session handle.
			if( myHandle.equals( player.getHandle() ) )		
				mySessionAd = new SessionAd( mySessionName, mySession, myState );		
			else
			{		
				mySessionAd.sessionCount = myState.numPlayers();
				mySessionAd.sessionState = myState;
			}	
d284 1
a284 1
			}	
d296 1
a296 1
		{						
d316 4
a319 1
						theMob.stopAttack();
d327 22
a348 2
					}				
					mySession.errorDetected( myPlayer.getId(), myPartNum );
d360 1
a360 2
				}				
				mySessionAd.sessionCount = myState.numPlayers();
d363 2
a364 2
			unlock();
		}							
d513 1
a513 1
					comm.printMessage( name + " digs a small pond in the groud." );				
d538 1
a538 1
						comm.printMessage( name + "  suddenly vanishes from sight!" );
a749 1
				System.out.println( thePlayerTarget );
d869 3
a871 6
			attemptLock();
			// Yes.. all this function does is call synchronize.
			// I thought about adding a special function to the
			// the GameState class, but then I realized that would be
			// redundant.  So, perhaps its bit excessive, but it does do the job
			myState.synchronize( theState, myMap );
d882 1
a882 1
	{
d887 2
a888 5
			if( thePlayer != null )
			{
				System.err.println( "Refreshing " + thePlayer.getName() );
				myState.refreshPlayer( playerId );
			}
d957 1
a957 4
			// to fix the global state.
			comm.printError( "Warning: An error has been detected in the global state. " +
			                 "The session will be performing the state healing process in " +
					 "a few seconds." );
d1044 6
a1049 2
	{								
		if( mySession.equals( theAd.sessionHandle ) && theAd.sessionState.getPartNum() == myPartNum )
d1051 5
a1055 2
			if( myState.equals( theAd.sessionState ) )
				scheduleNormalReport();			
d1057 1
a1057 5
			{
				// Since the states are not equal, run the synchronization
				// process.  If the user is no longer in combat, stop the fight.
				comm.printError(  "Warning!  States are not equal!" +
				  		  "  Running synchronization routines." );
d1074 2
a1075 1
			}
d1079 13
d1135 7
a1141 10
				}
				
				// Same layouts - no need to recreate tghe world, rather, 
				// 
				mySession.updateState( myState, myPartNum );																											
				
			}			
									
			myState.synchronize( incomingState, myMap );			
			myState.updateListeners( this, this, myMap );
a1144 1
			comm.printMessage( "Joining session: " + theAd.sessionName );
d1146 1
d1156 1
d1158 3
d1193 1
a1193 1
	{
d1200 1
a1200 1
		}
d1211 1
d1216 1
d1227 2
a1228 2
	 {
			doAttack( damage, name );		
d1238 2
a1239 1
	  	if( mySession != null )
d1241 1
d1250 1
d1252 2
a1253 1
			mySession.processMove( theMove, myPartNum );										
d1263 1
d1266 2
a1267 3
			PlayerCharacter thePlayer = checkId( playerId );
			System.err.println( thePlayer.getName() + " has timed out." ); 
			mySession.notifyPlayerTimeout( playerId, myPartNum );
d1269 1
d1792 4
d1812 1
d1819 5
a1823 1
						
d1850 3
d1861 1
a1861 1
				comm.printError( "You cannot perform that attck without a weapon." );
d1877 4
d1945 5
d1960 2
a1961 1
		}		
d1978 1
d1981 1
a1981 2
	  {
	  	// start fighting the monster
d1984 1
d1990 2
d1995 1
a1995 1
			comm.setTarget( theMobTarget.getName() );
d2057 1
d2067 1
d2084 26
a2109 9
					PlayerCharacter temp = PlayerCharacter.createNewCharacter(					
					(PlayerCreationCommand)command, myHandle );
					if( temp != null )
						charChanged( temp );
					else
					{
						String className = ((PlayerCreationCommand)command).clas;
						comm.printError( className + ": invalid player class." );
					}
d2124 2
a2125 1
				// You can't move if you are in combat with another player
d2193 2
d2200 1
a2200 2
					myMap.spawnMobs( this );																															
					mySessionAd = new SessionAd( mySessionName, mySession, myState );												
d2211 2
d2223 1
a2223 1
					SessionFinder sessionFinder = new SessionFinder( gameChooser );
d2226 1
a2226 1
					gameChooserWindow.setVisible( true );							
d2229 1
a2229 6
			break;
			case Command.CANCEL_SESSION:
			{
				// Nothing here this command should probably be removed.
			}
			break;
d2262 4
a2265 1
				if( myMap.digPond() == false )
d2267 1
d2281 3
a2283 1
					House newHouse = new House( myPlayer,
d2285 3
a2287 3
					myMap.placeHouse( newHouse );				
					comm.printMessage( "You place your house at " + newHouse.getLocation() );
					if( mySession != null )
d2289 3
d2315 1
d2321 1
d2340 2
d2368 3
d2376 1
d2382 1
a2382 1
							  "gold pieces." ); 
d2403 2
d2412 1
d2430 2
d2441 1
d2466 1
d2479 1
d2489 2
d2516 2
d2537 3
d2568 2
d2600 1
d2660 1
d2675 1
a2675 3
			{
				try{
				boolean canAttack;
d2694 1
a2694 7
				}
				}
				catch( Exception e )
				{
					e.printStackTrace();
				}				
				
d2700 2
a2701 1
				
d2721 4
d2748 3
d2756 5
d2775 1
d2794 2
d2834 1
a2834 1
							PlayerCharacter temp = 
d2837 1
a2837 1
							if( temp == null )
d2840 4
a2843 1
								charChanged( temp );
d2933 1
d2955 2
a2956 1
								fw.close();						
d2960 1
a2960 2
				}
				comm.printMessage( "Session saved!" );
d3018 2
d3115 1
a3115 1
					allGameUnits.report( mySessionAd );
d3161 12
@


1.27
log
@*** empty log message ***
@
text
@d6 1
a6 1
 * does all that.  Almost every other function		 is a helper to that function.
d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.26 2004/09/24 03:43:04 rjw2183 Exp rjw2183 $
d194 1
a194 1
	public synchronized void yell( String message, Eoid playerId, int partition )
d199 8
a206 3
			String playerName = ((PlayerCharacter)myState.get( GameState.PLAYER, playerId )).getName();
			if( !myPlayer.getId().equals( playerId ) )
				comm.printMessage( playerName + " yells, \"" + message + "\"" );			
d211 5
d221 12
a232 2
			if( myMap.checkLoc( theMessage.playerLoc ) && !myPlayer.getId().equals( theMessage.playerId ) )
				comm.printMessage( theMessage.playerName + " says, \"" + theMessage.myMessage + "\"" );			
d249 3
d253 1
a253 5
			if( !myPlayer.getId().equals( player.getId() ) )
			{
				myState.add( GameState.PLAYER, player );	
				myMap.placePlayer( player );									
			}
d255 2
d258 1
a258 2
			{									
				mySessionAd = new SessionAd( mySessionName, mySession, myState );		}					
d264 2
d267 1
d270 2
d273 2
d276 15
a290 1
				printCurrentRoom();		
d305 1
a305 1
			PlayerCharacter leavingPlayer = (PlayerCharacter)myState.get( GameState.PLAYER, playerId );
d308 24
a331 8
			String name = leavingPlayer.getName();		
			if( leavingPlayer.isInCombat() )
			{
				if( leavingPlayer.hasMobTarget() )
				{
					MobKey theKey = (MobKey)leavingPlayer.getTarget();
					Mob theMob = (Mob)myState.get( GameState.MOB, theKey );
					theMob.stopAttack();
d333 3
a335 1
				else
d337 6
a342 5
					Eoid thePlayerId = (Eoid)leavingPlayer.getTarget();
					PlayerCharacter thePlayer = (PlayerCharacter)myState.get( GameState.PLAYER,
					thePlayerId );
					if( thePlayer != null )
						thePlayer.clearTargetData();
d344 2
a345 12
			}
			
			if( !myPlayer.getId().equals( playerId ) )
			{
				myState.remove( GameState.PLAYER, leavingPlayer.getId() );
				comm.printMessage( name + " has left our world." );
				if( myFriendsList.hasPlayer( playerId ) )
					comm.printMessage( "Your friend, " + name + " has left this session." );
				myMap.removePlayer( playerId );
			}
			
			mySessionAd.sessionCount = myState.numPlayers();			
a346 1
			}
d365 1
a365 2
					UserMove theMove = (UserMove)aMove;				 	
					String name = ((PlayerCharacter)myState.get( GameState.PLAYER, theMove.getUser() )).getName();
d368 1
a368 1
						PlayerCharacter thePlayer = (PlayerCharacter)myState.get( GameState.PLAYER, theMove.getUser() );
d371 44
a414 23
						if( thePlayer.isInCombat() && thePlayer.hasMobTarget() )
						{
							Mob theMob = (Mob)myState.get(
							GameState.MOB, (MobKey)thePlayer.getTarget() );
							theMob.stopAttack();
							thePlayer.clearTargetData();
							comm.printMessage( name + " disengages combat with " + theMob.getName() );
						}
					
						if( myMap.checkLoc( theMove.getLoc( MoveData.FROM ) )
						   && !myPlayer.isInHouse() )
						{
							String[] directions = { "north", "south", "east", "west" };
							comm.printMessage( name + " leaves to the " + directions[theMove.getDirection()] );
						}
						else if( myMap.checkLoc( theMove.getLoc( MoveData.TO ) ) &&
						        !myPlayer.isInHouse() )
						{
							String[] directions = { "south", "north", "west", "east" };
							comm.printMessage( name + " enters from the " + directions[theMove.getDirection()] );
						}
						thePlayer.updateLocation( theMove.getLoc( MoveData.TO )  );
						myMap.processMove( theMove );	
d421 26
a446 18
					MobMove theMove = (MobMove)aMove;				
					myMap.refreshMobTimer( theMove.getKey() );					
					if( theMove.getDirection() != -1 )
					{					
						String name = theMove.getName();					
						boolean validMob = myMap.moveMob( theMove );
						
						if( myMap.checkLoc( theMove.getLoc( MoveData.FROM ) ) && validMob )
						{
							String[] directions = { "north", "south", "east", "west" };
							comm.printMessage("A " + name + " leaves to the " + directions[theMove.getDirection()] );
						}
						else if( myMap.checkLoc( theMove.getLoc( MoveData.TO ) ) && validMob )
						{
							String[] directions = { "south", "north", "west", "east" };
							comm.printMessage(  "A " + name + " enters from the " + directions[theMove.getDirection()] );
						}										
					}				
d489 6
a494 1
				String name = ((PlayerCharacter)myState.get( GameState.PLAYER,playerId )).getName();
d502 1
a502 2
		
	  }
d511 1
a511 1
	  {
d517 1
a517 1
				PlayerCharacter thePlayer = (PlayerCharacter)myState.get( GameState.PLAYER, playerId );
d520 6
a525 8
				String name = thePlayer.getName();	
				if( myMap.checkLoc( from ) )
					comm.printMessage( name + "  suddenly vanishes from sight!" );
				
				myMap.performWarp( playerId, to );
				
				if( myMap.checkLoc( to ) )
					comm.printMessage( name + " suddenly phases into view!" );
d530 1
a530 1
		}
d545 7
a552 2
				{
					String name = ((PlayerCharacter)myState.get( GameState.PLAYER, theHouse.getOwner() )).getName();
d554 1
a554 1
				}				
a587 2
			try
			{
d589 3
a591 6
				comm.printMessage( myMap.getMerchantBroadcast( merchantType ) );
			}
			catch( Exception e )
			{
				e.printStackTrace();
			}
d606 4
a609 1
			String name = ((PlayerCharacter)myState.get( GameState.PLAYER, playerId )).getName();
d634 23
a656 10
				theMob.startAttackSilent( playerId, ts );
				PlayerCharacter thePlayer = (PlayerCharacter)myState.get( GameState.PLAYER,playerId );
				thePlayer.registerTarget( theKey );
				
				System.err.println( loc );
				if( myMap.checkLoc( loc ) )
				{					
					String pName = thePlayer.getName();
					comm.printMessage( pName + " begins attacking the " + theMob.getName() + "!",
				                   Color.red.darker() );
d674 32
a705 9
			PlayerCharacter playerOne = (PlayerCharacter)myState.get( GameState.PLAYER, p1 );
			PlayerCharacter playerTwo = (PlayerCharacter)myState.get( GameState.PLAYER, p2 );
			playerOne.registerTarget( p2 );
			playerTwo.registerTarget( p1 );
			unlock();
			if( myMap.checkLoc( loc ) && 
			    ( !myPlayer.getId().equals( p1 ) && !myPlayer.getId().equals( p2 ) ) 
			  )
				comm.printMessage( playerOne.getName() + " and " + playerTwo.getName() + " begin fighting!" );		
d740 5
a744 4
				printCurrentRoom();					
				thePlayerTarget = null;
				mySession.notifyPlayerDeath( myPlayer.getId(),
				myMap.getCurrentPlayerLocation(), myPartNum );	
d761 7
a767 1
			if( !theMob.isAlive() && !theMob.isUnderAttack() )
d769 5
a773 2
			if( myMap.checkLoc ( theMob.getCurrentLocation() ) )
				comm.printMessage( theMob.getName() + " is restored back to life." );
d783 1
a783 1
	public synchronized void notifyPlayerDeath( Eoid id, XYloc loc, int partition )
d787 61
a847 50
			try
			{
			if( !myPlayer.getId().equals( id ) )
			{
				attemptLock();
				PlayerCharacter thePlayer = (PlayerCharacter)myState.get( GameState.PLAYER, id );				
				String name = null;
				if( thePlayer.hasMobTarget() )
				{
					Mob theMob = (Mob)myState.get( GameState.MOB, 
					(MobKey)thePlayer.getTarget() );
					name = theMob.getName();
					theMob.stopAttack();
				}
				else
				{
					Eoid theTarget = (Eoid)thePlayer.getTarget();
					if( myPlayer.getId().equals( theTarget ) )
					{
						
						name = myPlayer.getName();
						myPlayer.clearTargetData();						
						thePlayerTarget = null;
						comm.clearCombatLog();
						comm.setTarget( "" );
					}
					else
					{
						PlayerCharacter theplayer = (PlayerCharacter)myState.get( 
						GameState.PLAYER, theTarget );
						if( theplayer != null )
						{
							name = theplayer.getName();
							theplayer.clearTargetData();							
						}
						else 
							System.out.println( "Target was null." );
					}										
				}
				comm.printMessage( thePlayer.getName() + " was just killed by " + name + "!" );				
				thePlayer.clearTargetData();				
				myMap.performWarp( id, new XYloc( 0, 0 ) );
				unlock();
			}
			}
			catch( Exception e )
			{	
				e.printStackTrace();
			}
		}
d855 5
a859 19
			theState.setId( myPlayer.getId() );
			myMap.updateState( theState, this, this );
			myState = myMap.getState();
			myState.setPCList( this );
			myState.setId( myPlayer.getId() );
			
			// This may seem odd, but essentially this is done to make sure 
			// that the myPlayer item still refers to the object in the GameState 
			// object.  Of course, when states are merged, the incoming state makes 
			// no changes to the player.
			myPlayer = (PlayerCharacter)myState.get( GameState.PLAYER, myPlayer.getId() );
			if( myPlayer.isInCombat() )
			{
				Object target = myPlayer.getTarget();
				if( myPlayer.hasMobTarget() )
					theMobTarget = (Mob)myState.get( GameState.MOB, target );
				else
					thePlayerTarget = (PlayerCharacter)myState.get( GameState.PLAYER, target );
			}
d874 6
a879 1
			myState.refreshPlayer( playerId );
d896 26
a921 4
			if( enter == false )
			{
				myMap.removePlayerFromHouse( pId, houseId );
				which = "leaves";
d923 31
d955 1
a955 12
			{
				myMap.movePlayerIntoHouse( pId, houseId );
				which = "enters";
			}
			
			XYloc houseLoc = ((House)myState.get( GameState.HOUSE, houseId )).getLocation();
			if( myMap.checkLoc( houseLoc ) )
			{
				String pName = ((PlayerCharacter)myState.get( GameState.PLAYER, pId )).getName();
				String hName = ((House)myState.get( GameState.HOUSE, houseId )).getOwnerName();
				comm.printMessage( pName + " " + which + " " + hName + "\'s house." );
			}
d958 2
a959 1
	 }	  
d971 14
a984 5
			attemptLock();
			PlayerCharacter challenger = (PlayerCharacter)myState.get( GameState.PLAYER, pId );
			if( consideringDuel )
				challenger.getHandle().declineDuel( " is already considering another duel.", 
				myPlayer.getId(), myPartNum );
d986 1
a986 5
			{
				comm.printMessage( challenger.getName() + " has challenged you to a duel!" );
				consideringDuel = true;
				currentChallenger = pId;
			}
d1045 2
d1048 1
a1048 1
				  		  "Running synchronization routines." );
d1051 1
a1051 5
				myState.synchronize( theAd.sessionState, myMap );
				if( myState.needsEmergencyReport() )
					scheduleEmergencyReport();
				else
					scheduleFastReport();								
d1061 4
d1088 2
a1089 2
			incomingState = theAd.sessionState;									
			GameState theState = null;
d1093 3
a1095 13
			{
				// Different configurations, overwrite the one in current use
				myState.setConfig( incomingState.getConfig() );
				myMap.createWorld();
				theState = incomingState;
				comm.clear();
				comm.printMessage( "Please note: This session uses a different" +
					" configuration than currently in use.  If you wish to keep this session's map," +
					" you will need to execute a \"save map\" command.  Also note," +
					" this session's data will not be saved. To do this, you will need to" +
					" execute a \"save state\" command." );	
				
			}
d1098 1
a1098 12
				// This right is interesting.  Some people may ask why I don't just
				// send the data over and have the units process.  Well, the reasons are as follows:
				// I don't have to worry about whether or not the units will have different results
				// since they all use the same state to update.  Also,  in ters of work, it doesn't seem
				// like there would be much difference. Each unit would have to take the new state data
				// append it to their world and then append it to their states.  So overall, the amount
				// of work would still be the same.  So what it boils down to is when the unit actuaally
				// joins the session.  If for some reason, the unit disconnects after it has called 
				// update state, everyone gets the state changes.   Is this good or bad?  It depends, really,
				// however considering this thing has a built in state check and synchronizer, it
				// seems fair enough
				
d1111 1
a1111 11
					myState.setId( myPlayer.getId() );
					
					myMap.setViewer( myMapWindow );	
					comm.clear();
					comm.setStateName( stateName );
					myMap.warp( 0, 0 );
					myMap.setViewer( myMapWindow );
					printCurrentRoom();
					
					myPlayer = (PlayerCharacter)myState.get( GameState.PLAYER, 
										  myPlayer.getId() );
d1113 9
a1121 9
				theState = GameState.mergeStates( myState, incomingState );														
				mySession.updateState( theState, myPartNum );	
				comm.clear();
			}
			
			theState.setId( myPlayer.getId() );
			myMap.updateState( theState, this, this );
			myState = myMap.getState();
			myState.setPCList( this );
d1124 1
d1130 7
a1136 1
			myPlayerRefresher.start();
d1222 2
a1223 2
		if( mySession != null && theMove != null )
			mySession.processMove( theMove, myPartNum );				
d1234 3
d1238 1
d1265 1
d1279 10
a1288 5
			if( mySession != null )
				mySession.notifyPlayerDeath( myPlayer.getId(), 
				  myMap.getCurrentPlayerLocation(), myPartNum );
									

d1299 1
a1299 1
	public synchronized void notifyMobDeath( XYloc loc, Eoid pId, int partition )
d1301 3
a1303 1
		if( partition == myPartNum )
d1306 31
a1336 8
			if( !myPlayer.getId().equals( pId ) )
			{
				PlayerCharacter thePlayer = (PlayerCharacter)myState.get( GameState.PLAYER, pId );
				Mob theMob = (Mob)myState.get( GameState.MOB, (MobKey)thePlayer.getTarget() );
				thePlayer.clearTargetData();
				theMob.kill();
				if( myMap.checkLoc( loc )  )
					comm.printMessage( thePlayer.getName() + " kills the " + theMob.getName() );
d1340 5
d1376 1
d1380 2
a1381 3
					PlayerCharacter p1 = (PlayerCharacter)myState.get( 
					GameState.PLAYER, pId );
					if( p1 != null && p1.isInCombat() )
d1386 1
a1386 3
							PlayerCharacter p2 = (PlayerCharacter)myState.get(
							GameState.PLAYER, p2Id );
							
d1467 1
a1467 1
				PlayerCharacter thePlayer = (PlayerCharacter)myState.get( GameState.PLAYER, temp );
d1486 5
a1490 1
								String pName = ((PlayerCharacter)myState.get( GameState.PLAYER,  pId )).getName();
d1515 14
a1528 9
		StringBuffer desc = new StringBuffer( "Lookup listing:\n" );
		Iterator lookupIter = lookupVector.iterator();
		while( lookupIter.hasNext() )
		{
			Eoid tempId = (Eoid)lookupIter.next();
			int i = lookupVector.indexOf( tempId );
			desc.append( "(" + i + ") " + (PlayerCharacter)myState.get( GameState.PLAYER, tempId ) + "\n" );
			if( lookupIter.hasNext() )
				desc.append( "\n" );
d1530 2
a1532 1
		comm.printMessage( desc );
d1653 1
a1653 3
		String desc = myItemData.getDesc( dropId );
		theMobTarget= null;		
		
d1666 3
a1668 1
		comm.clearCombatLog();
d1672 2
a1673 1
			mySession.notifyMobDeath( myMap.getCurrentPlayerLocation(), myPlayer.getId(), myPartNum );
a1936 1
			System.out.println( dmgId + " " + damage );
d1942 48
d2021 1
d2025 3
a2027 3
				{
					PlayerCharacter temp = PlayerCharacter.createNewCharacter(
					 (PlayerCreationCommand)command, myHandle );
d2032 2
a2033 2
						String name = ((PlayerCreationCommand)command).clas;
						comm.printError( name + ": invalid player class." );
d2102 2
d2105 1
a2105 1
					mySession.yell( ((StringCommand)command).getStringData(), myPlayer.getId(), myPartNum );	
d2180 2
a2181 2
					SayData myMessage = new SayData( myPlayer.getId(), myPlayer.getName(), 
						myMap.getCurrentPlayerLocation(), ((StringCommand)command).getStringData() );
d2234 2
a2235 2
				if( ( 0 <= x && x <= myMap.getMaxX() ) &&
				    ( 0 <= y && y <= myMap.getMaxY() ) )
d2390 20
a2409 13
				Iterator friends = myFriendsList.getPlayers();
				int i = 0;
				while( friends.hasNext() )
				{
					Eoid tempKey = (Eoid)friends.next();
					String name = myFriendsList.getName( tempKey );
					if( myState.has( GameState.PLAYER, tempKey )  )
						comm.printMessage( 
						"(" + i + ") " + name + " (" + tempKey + ") " + " is in this session." );					
					else
						comm.printMessage( 
						"(" + i + ") " + name + " (" + tempKey + ") " + " is not in this session." );
					i++;
d2450 3
d2566 1
d2586 5
d2684 3
a2686 2
					String pName = ((PlayerCharacter)myState.get( GameState.PLAYER, currentChallenger )).getName();
					Game theHandle = ((PlayerCharacter)myState.get( GameState.PLAYER, currentChallenger )).getHandle();
d2688 1
a2688 1
					thePlayerTarget = (PlayerCharacter)myState.get( GameState.PLAYER, currentChallenger );
d2691 1
a2691 1
					mySession.notifyFight( thePlayerTarget.getId(), myPlayer.getId(),
d2739 1
a2739 2
								myState.setConfig( theConfig );
								myMap.createWorld();
a2904 1
					myPlayer = (PlayerCharacter)myState.get( GameState.PLAYER, myPlayer.getId() );
d3014 23
@


1.26
log
@Added the code to incorporate the synchronize function.
@
text
@d1 1
a1 1
	/**  
d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.25 2004/09/23 03:58:46 rjw2183 Exp rjw2183 $
d228 1
a228 1
			attemptLock();		
d332 2
a333 1
						if( myMap.checkLoc( theMove.getLoc( MoveData.FROM ) ) )
d338 2
a339 1
						else if( myMap.checkLoc( theMove.getLoc( MoveData.TO ) ) )
a435 1
				System.out.println( "to: " + to + ", from: " + from );
d594 1
a594 1
	public synchronized void printAttack( int damage, int partition )
d596 4
a599 1
		if( partition == myPartNum )
d625 2
a626 1
				myMap.getCurrentPlayerLocation(), myPartNum );				
d678 1
a678 1
						System.out.println( "here" );
d683 1
d721 14
a762 1
			System.out.println( "move house called" );
d768 1
a768 1
				inRoom = myMap.removePlayerFromHouse( pId, houseId );
d773 1
a773 1
				inRoom = myMap.movePlayerIntoHouse( pId, houseId );
d776 3
a778 1
			if( inRoom == true )
d844 1
d860 1
a860 1
	{						
d867 4
d875 2
a876 3
					scheduleFastReport();
				myPlayer = (PlayerCharacter)myState.get( GameState.PLAYER, myState.getPlayerId() );
				if( !myPlayer.isInCombat() )
d878 1
d881 2
a882 1
				}
d884 1
d939 25
d1117 1
d1165 39
d1427 6
d1466 1
d1665 2
a1666 1
	 	thePlayerTarget.getHandle().printAttack( damage, myPartNum );
d1735 1
d1751 2
a1752 1
		      command.getType() != Command.LOAD )
d1817 1
d2422 2
a2423 1
					comm.printMessage( "You have accepted " + pName + "\'s challenge. Begin fighting!" );					
d2473 4
a2476 1
								printCurrentRoom();							
d2495 1
a2495 2
									myMap = temp;
									myMap.setViewer( myMapWindow );
d2497 1
d2500 2
d2505 5
a2509 1
									printCurrentRoom();									
d2622 2
d2628 1
a2634 1
					System.out.println( "Before session call: " + myPlayer.isInHouse() );
d2638 1
a2638 1
					System.out.println(" After session call: " + myPlayer.isInHouse() );							
d2704 40
@


1.25
log
@Fixed some issues dealing with entering andleving houses while in a session.
@
text
@d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.24 2004/09/22 03:27:25 rjw2183 Exp rjw2183 $
d442 1
a442 1
				myMap.performWarp( playerId, from, to );
d551 1
a551 1
				theMob.startAttackSilent( playerId, loc, ts );
d694 1
a694 1
				myMap.performWarp( id, loc, new XYloc( 0, 0 ) );
d841 17
a857 1
			scheduleNormalReport();			
d943 1
a943 1
		myState.purgePlayers();
@


1.24
log
@Added the code to take care of casting.
@
text
@d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.23 2004/09/17 04:04:43 rjw2183 Exp rjw2183 $
d247 3
a249 1
			scheduleNormalReport();			
d733 33
d841 1
a841 11
			if( myState.equals( theAd.sessionState ) )
				scheduleNormalReport();			
			else
			{
				myState.synchronize( theAd.sessionState, myMap );
				if( myState.needsEmergencyReport() )
					scheduleEmergencyReport();
				else	
					scheduleFastReport();
			}
			
d1103 14
a1116 1
		// Print an empty line than the get the descriptin
a1117 1
		TextMessage roomDesc = myMap.getCurrentRoomDescription();	
d1134 21
a1154 1
		if( myMap.currentRoomHasPlayers() )
d1157 1
a1157 1
			Iterator playerIter = myMap.getCurrentRoomPlayers();
d1165 1
a1165 1
				if( thePlayer != null )
d1200 1
a1200 1
		}			
d1202 1
a1202 1
	
d1513 3
a1515 1
		if( level > 0 &&
d1645 1
a1645 1
		{
d1680 3
d2114 1
a2114 4
			case Command.HOUSE_ENTER:
			{				
			}
			break;
d2208 5
d2219 1
a2219 1
				if( !myMap.currentRoomHasPlayers() )
d2228 1
a2228 1
					Iterator players = myMap.getCurrentRoomPlayers();
d2498 12
a2509 2
				myMap.enterHouse( houseNum );
				printCurrentRoom();
d2557 15
@


1.23
log
@started working on casting
@
text
@d1 1
a1 1
/**  
d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.22 2004/09/10 02:32:49 rjw2183 Exp rjw2183 $
d161 1
a161 2
	{		
		System.err.println( "Lock called." );
d180 1
a180 2
	{		
		System.err.println( "Unlock called." );
d1259 2
d1506 55
d1619 3
a1621 1
				if( myPlayer.isInCombat() && theMobTarget == null )
a2100 21
				// This variable is used to determine is the user can attack the selected target
				boolean canAttack = true;
				
				// If the player is already in combat, then inform him or her.
				if( myPlayer.isInCombat() )
				{
					comm.printError( "You are already in combat.  Please use the non target " +
					                 "versions of the attack commands." );
					canAttack = false;
				}
				
				// Second check, see if they have issued a duel challenge.
				if( consideringDuel && thePlayerTarget != null && canAttack )
				{
					comm.printError( "You have issued a duel challenge and may not enter into combat." );
					canAttack = false; 
				}
				
				// Next, check the weapon of the user, make sure that the command issued was valid for the weapon
				// A user may not execute a slash or thrust attack if they don't have a weapon equipped.
				
a2102 2
				if( weapon == null ) 
					canAttack = false;
d2105 1
a2105 1
				if( canAttack )
a2109 1
					{
a2111 1
					}
d2113 1
a2113 23
					{
						//If the player has been issued a duel challenge, clear it
						if( consideringDuel && currentChallenger != null )
						{
							PlayerCharacter temp = 
								(PlayerCharacter)myState.get( GameState.PLAYER, currentChallenger );
							if( temp != null )
								temp.getHandle().declineDuel
									( "engages in combat.", myPlayer.getId(), myPartNum );
							consideringDuel = false;
							currentChallenger = null;
						}
						// start fighting the monster
						Date ts = theMobTarget.startAttack( myPlayer.getId(), myPlayer.getLocation() );
						myPlayer.registerTarget( theMobTarget.getKey() );
						mySession.registerAttacker
							( myPlayer.getLocation(), theMobTarget.getKey(),
						          myPlayer.getId(), ts, myPartNum );
						
						int damage = myItemData.getCombatBonus( weapon );
						attackMob( damage );
						startBalanceTimer( weapon );							
					}
d2115 2
d2444 13
a2456 5
					{
						comm.printCombatMessage( "You cast a spell!", Color.black, true );	
						int damage = myItemData.getCombatBonus( splId );
						if( myPlayer.hasMobTarget() )
							attackMob( damage );
d2458 1
a2458 2
							attackPlayer( damage );
						startBalanceTimer( splId );				
d2462 2
d2469 12
@


1.22
log
@*** empty log message ***
@
text
@d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.21 2004/08/17 17:53:26 rjw2183 Exp rjw2183 $
d274 1
a274 1
					theMob.stopAttack( leavingPlayer.getId() );
d327 1
a327 1
							theMob.stopAttack( thePlayer.getId() );
d604 1
d666 1
a666 1
					theMob.stopAttack( thePlayer.getId() );
d1015 1
a1015 1
			theMobTarget.stopAttack( myPlayer.getId() );
d1056 15
d1444 62
d1575 1
a1575 1
						theMob.stopAttack( myPlayer.getId() );
d1582 1
a1582 1
					UserMove movement = myMap.doPlayerMove( ((IntCommand)command).getIntValue() );				
d1784 2
a1785 2
					String id = ((StringIntCommand)command).getStringValue();
					int amount = ((StringIntCommand)command).getIntValue();
d1815 2
a1816 2
					String id = ((StringIntCommand)command).getStringValue();
					int amount = ((StringIntCommand)command).getIntValue();
d1916 2
a1917 2
				if( lookupVector.size() > iComm.getIntValue() )
					playerId = (Eoid)lookupVector.elementAt( iComm.getIntValue() );
d1964 1
a1964 1
					if( lookupVector.size() > iComm.getIntValue() )
d1966 1
a1966 1
						playerId = (Eoid)lookupVector.elementAt( iComm.getIntValue() );
d1988 1
a1988 1
				String name = myFriendsList.removePlayer( ((IntCommand)command).getIntValue() );
d2065 1
a2065 1
				int type = ((StringIntCommand)command).getIntValue();
d2073 1
a2073 1
					String mobName = ((StringIntCommand)command).getStringValue();
d2101 2
a2102 10
						comm.printCombatMessage( "You " + attacks[type] + " the " + mobName + 
							" for " + damage + " damage!", Color.yellow.darker(), false );							
						theMobTarget.damageMob( damage );
						if( !theMobTarget.isAlive() )
							killMob();
						hasBalance = false;
						comm.setStatus( true, hasBalance );
						long timer = myItemData.getWeaponDelay( weapon );
						attackTimer.start( timer );
							
d2111 1
a2111 1
				int type = ((IntCommand)command).getIntValue();
d2120 2
a2121 10
						else if( myPlayer.hasMobTarget() )
						{
							theMobTarget.damageMob( damage );
							String mobName = theMobTarget.getName();
							comm.printCombatMessage(
							"You attack the " + mobName + " for " + damage + " damage!",
							Color.yellow.darker(), false );
							if( !theMobTarget.isAlive() )
								killMob();						
						}
d2123 2
a2124 9
						{
							thePlayerTarget.getHandle().printAttack( damage, myPartNum );
							comm.printCombatMessage( "You attack " + thePlayerTarget.getName() + "!",
							                         Color.blue.darker(), false );	
						}
						hasBalance = false;
						comm.setStatus( true, hasBalance );
						long timer = myItemData.getWeaponDelay( weapon );
						attackTimer.start( timer );
d2242 1
a2242 1
					switch( siComm.getIntValue() )
d2246 1
a2246 1
							String pName = siComm.getStringValue();
d2259 1
a2259 1
							( "maps/" + siComm.getStringValue() + ".map" );
d2289 1
a2289 1
								stateName = siComm.getStringValue();
d2316 1
a2316 1
				switch( siComm.getIntValue() )
d2326 1
a2326 1
							String fileName = "states/" + siComm.getStringValue() + ".dat";
d2332 1
a2332 1
								stateName = siComm.getStringValue();
d2343 1
a2343 1
						String fileName = "maps/" + siComm.getStringValue() + ".map";
d2382 1
a2382 1
					myMap.remove( ((IntCommand)command).getIntValue() );
d2412 1
a2412 1
					int part = ((IntCommand)command).getIntValue();					
d2419 31
@


1.21
log
@*** empty log message ***
@
text
@d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.20 2004/08/16 18:30:30 rjw2183 Exp rjw2183 $
d36 1
d543 1
a543 1
	 public synchronized void registerAttacker( XYloc loc, MobKey theKey, Eoid playerId, int partition )
d551 1
a551 1
				theMob.startAttackSilent( playerId, loc );
d1408 20
d1441 2
a1442 2
		      command.getType() != Command.LOAD && 
		      command.getType() != Command.INVALID_COMMAND ) )
d1474 1
a1474 7
			break;
			case Command.INVALID_COMMAND:
			{
				comm.printError( ((StringCommand)command).getStringData() + ": Invalid Command" );
			}
			break;
			
d1966 1
a1966 4
				String[] attacks = { "punch", "kick", "slash", "thrust" };
				int type = ((StringIntCommand)command).getIntValue();
				String mobName = ((StringIntCommand)command).getStringValue();
				
d1969 1
a1969 23
				// first step, check to make sure that there is a valid mob of the given name.
				// a valid mob is in the room and not under attack
				int status = myMap.checkMob( mobName );
				
				// A player may not attack a mob if they have issued a duel challenge
				if( consideringDuel && thePlayerTarget != null )
				{
					comm.printError( "You have issued a challenge and cannot attack a monster." );
					canAttack = false; 
				}
				
				if( consideringDuel && currentChallenger != null )
				{
					PlayerCharacter thePlayer = (PlayerCharacter)myState.get( GameState.PLAYER,
					                            currentChallenger );
					if( thePlayer != null )
						thePlayer.getHandle().declineDuel( " engages in combat.", myPlayer.getId(),
										   myPartNum );
					consideringDuel = false;
					currentChallenger = null;				 		
				}
				
				
d1972 2
a1973 1
					comm.printError( "You all aready engaged in combat!" );
d1977 2
a1978 1
				if( status == World.NO_SUCH_MOB )
d1980 2
a1981 8
					comm.printError( "That monster does not exist." );
					canAttack = false;
				}
				else if( status == World.NO_FREE_MOB )
				{
					comm.printError( "All monsters of that type in this area are under attack " +
					  		 "by other players." );
					canAttack = false;						
d1984 6
a1989 6
				// If the user does not have a weapon equippped he or she will not 
				/// be able to execute the thrust or slash commands
				String weapon = myPlayer.getEquippedWeapon();
				if( ( type == StringIntCommand.SLASH || type == StringIntCommand.THRUST ) &&
				     weapon == null )
				{
a1990 4
					comm.printError( "You can't perform that kind of attack with no weapon equipped." );
				}
				if( type == StringIntCommand.KICK )
					weapon = "kick";
d1992 1
a1992 3
				if( type == StringIntCommand.PUNCH )
					weapon = "punch";
				// there is a valid, and the user's attack is valid for his or her given weapon type
d1995 3
a1997 4
					
					// If there is no target, get the first free mob.  
					// If this mob exists, register the player as the attacker
					if( !myPlayer.isInCombat() )
d1999 2
a2000 14
						theMobTarget = myMap.getFreeMob( mobName );
						if( theMobTarget == null )
						{
							comm.printError( "Either another player has attacked that mob, " +
						    		   "or it have moved out of the area." );
							canAttack = false;																					   
						}
						else
						{
							theMobTarget.startAttack( myPlayer.getId(), myPlayer.getLocation() );
							myPlayer.registerTarget( theMobTarget.getKey() );
							mySession.registerAttacker( myPlayer.getLocation(), theMobTarget.getKey(),
							myPlayer.getId(), myPartNum );  
						}
d2002 1
a2002 10
					else if( !theMobTarget.getName().equals( mobName ) )
					{					
						// The user already has a target, make sure the name of the target matches that
						// of the target
						comm.printError( "You can not attack another monster until you have " +
						                 "finished combat with your current target." );	
						canAttack = false;											
					}
					
					if( canAttack )
d2004 20
a2023 5
						// Everything is still kosher, make sure the user has balance
						if( hasBalance )
						{							
							int damage = myItemData.getCombatBonus( weapon );
							comm.printCombatMessage( "You " + attacks[type] + " the " + mobName + 
d2025 8
a2032 14
							theMobTarget.damageMob( damage );
							if( !theMobTarget.isAlive() )
								killMob();
							hasBalance = false;
							comm.setStatus( true, hasBalance );
							long timer = myItemData.getWeaponDelay( weapon );
							attackTimer.start( 5000 );	
							System.err.println( "here." );
						}
						else
						{
							comm.printCombatMessage( "You are regaining your balance after the last" + 
								           " attack!", Color.yellow.darker(), false );
						}										
d2035 1
d2040 1
a2040 1
				boolean canAttack = true;
d2042 2
a2043 13
				
				// A player may not perfoem a slash ot thrust attacj without a weapon equipped.
				String weapon = myPlayer.getEquippedWeapon();				
				if( ( type == StringIntCommand.SLASH || type == StringIntCommand.THRUST ) &&
				     weapon == null )
				{
					if( canAttack )					
						comm.printError( "You can't perform that kind of attack with no weapon equipped." );
					canAttack = false;
				}	
				
				// A player may not attack a mob if they have issued a duel challenge
				if( canAttack && consideringDuel && thePlayerTarget != null )
a2044 21
					comm.printError( "You are considering a duel and cannot attack." );
					canAttack = false;
				}
				// Yes, you can attack the air..
				if( ( theMobTarget == null && thePlayerTarget == null ) && canAttack )
				{
					comm.printMessage( "You " + attacks[type] + " the air." );
					canAttack = false;
				}
				
				// Assuming that the user entered in the "kick" or "punch" command
				// set the weapon to the appropriate ID, since kick  and punch
				// are always there
				if( type == StringIntCommand.KICK )
					weapon = "kick";
				if( type == StringIntCommand.PUNCH )
					weapon = "punch";
						
				if( canAttack )
				{
					
a2045 1
					// If the player has balance, they can attack
d2048 3
a2050 1
						if( myPlayer.hasMobTarget() )
a2051 3
							// Perform the attack on the mob
							String mobName = theMobTarget.getName();					
							
d2053 4
a2056 3
							comm.printCombatMessage( "You " + attacks[type] + " the " + mobName +
							" for " + damage + "!", Color.yellow.darker(), false);							
							
d2058 1
a2058 2
								killMob();
									
d2061 1
a2061 1
						{							
d2064 1
a2064 2
							                         Color.blue.darker(), false );

d2068 2
a2069 2
						long time = myItemData.getWeaponDelay( weapon );
						attackTimer.start( time );					
a2071 1
					{
a2073 1
					}
d2075 1
d2294 9
a2302 6
							FileWriter fw = new FileWriter( theFile );
							BufferedWriter writer = new BufferedWriter( fw );
							String data =  myState.getConfig().toString();
							writer.write( data, 0, data.length() );
							writer.close();
							fw.close();						
@


1.20
log
@*** empty log message ***
@
text
@d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.19 2004/08/12 01:21:11 rjw2183 Exp rjw2183 $
d1440 11
a1450 2
					charChanged( PlayerCharacter.createNewCharacter(
					 (PlayerCreationCommand)command, myHandle ) );
@


1.19
log
@*** empty log message ***
@
text
@d6 1
a6 1
 * does all that.  Almost every other function is a helper to that function.
d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.18 2004/08/11 20:06:44 rjw2183 Exp $
d160 2
a161 1
	{
d180 2
a181 1
	{
d231 6
a236 2
			myState.add( GameState.PLAYER, player );										
			myState.setTime( myTimeManager.getTime() );
d310 1
a310 1
			attemptLock();
d551 4
d556 1
a556 2
				{
					PlayerCharacter thePlayer = (PlayerCharacter)myState.get( GameState.PLAYER,playerId );
a557 1
					thePlayer.registerTarget( theKey );
d601 2
d608 1
a608 2
				comm.printMessage( "You were just killed by " + pName );		
				thePlayerTarget = null;
d610 2
d616 2
a617 1
				printCurrentRoom();	
d619 1
a619 1
				myMap.getCurrentPlayerLocation(), myPartNum );
d652 2
d657 10
a666 2
				PlayerCharacter thePlayer = (PlayerCharacter)myState.get( GameState.PLAYER, id );
				if( myMap.checkLoc( loc ) )
d668 2
a669 2
					String name = null;
					if( thePlayer.hasMobTarget() )
d671 5
a675 4
						Mob theMob = (Mob)myState.get( GameState.MOB, 
						(MobKey)thePlayer.getTarget() );
						name = theMob.getName();
						theMob.stopAttack( thePlayer.getId() );
d679 3
a681 2
						Eoid theTarget = (Eoid)thePlayer.getTarget();
						if( myPlayer.getId().equals( theTarget ) )
d683 2
a684 4
							name = myPlayer.getName();
							myPlayer.clearTargetData();
							thePlayerTarget = null;
							comm.clearCombatLog();
d686 3
a688 5
						else
							name = ((PlayerCharacter)myState.get(GameState.PLAYER, theTarget )).getName();
					}
					comm.printMessage( thePlayer.getName() + " was just killed by " + name + "!" );
				
d690 2
a691 1
				thePlayer.clearTargetData();
d695 5
d835 1
a835 1
			
d838 2
a839 3
			mySessionName = theAd.sessionName;									
			incomingState = theAd.sessionState;			
			incomingState.add( GameState.PLAYER, myPlayer );			
d865 1
a865 1
				// of work would still be the same.  So what it boils down to is when the unit actually
d870 1
a870 1
				theState = GameState.mergeStates( myState, incomingState );										
d950 1
a950 1
	 public void attackTarget(  int damage, String name )
d960 1
a960 1
	  public void respawnMob( MobKey key )
d970 1
a970 1
	public void moveMob( MobMove theMove )
d973 1
a973 1
			mySession.processMove( theMove, myPartNum );		
d981 1
a981 1
	public void playerTimeout( Eoid playerId )
d998 4
a1017 3
			if( mySession != null )
				mySession.notifyPlayerDeath( myPlayer.getId(), 
				  myMap.getCurrentPlayerLocation(), myPartNum );
d1022 5
a1026 1
			printCurrentRoom();						
d1061 1
a1061 1
	private void printCurrentRoom()
d1105 1
a1105 1
						// since that has allready been reported
d1134 1
a1134 1
	private void printLookup()
d1153 1
a1153 1
	 private void loadItemData()
d1169 1
a1169 1
	private void printGear( int slot )
d1221 2
a1222 4
	{
		attemptLock();
		consideringDuel = status;
		unlock();
d1230 1
a1230 1
	private boolean checkValidCombatCommand( int type )
d1254 1
a1254 1
	private void killMob()
d1285 1
a1285 1
	private void cancelDuel( String reason )
d1307 1
a1307 1
	 private void checkDirectories()
d1363 1
a1363 1
	private void charChanged( PlayerCharacter theChar )
d1404 1
d1416 2
a1417 1
	 {	 		
d1495 3
a1497 1
							mySession.processMove( movement, myPartNum );					
d1640 2
a1641 2
				    {
					try
d1643 7
a1649 11
					XYloc temp = myMap.getCurrentPlayerLocation();
					comm.printMessage( "Warping you to location (" + x + ", " + y + ")" );
					myMap.warp( x, y );									
					printCurrentRoom();
					if( mySession != null )
						mySession.warp( myPlayer.getId(), temp, myMap.getCurrentPlayerLocation(),
						myPartNum );
					}
					catch( Exception e )
					{
						e.printStackTrace();
d1651 1
d1955 1
a1955 1
					comm.printError( "You are considering a duel and cannot attack." );
d1958 13
a2002 1
				
d2022 2
a2023 6
							if( mySession != null )
							{
								mySession.registerAttacker( 
								myMap.getCurrentPlayerLocation(), 
								theMobTarget.getKey(), myPlayer.getId(), myPartNum );
							}
d2046 2
a2047 1
							setBalance( false );
d2049 2
a2050 1
							attackTimer.start( 5000 );							
d2054 2
a2055 2
							comm.printMessage( "You are regaining your balance after the last" + 
								           " attack!", Color.yellow.darker() );
d2124 2
a2125 1
						setBalance( false );
d2131 2
a2132 2
						comm.printMessage( "You are regaining your balance after the last" + 
								           " attack!", Color.yellow.darker() );
d2146 1
d2152 1
d2199 2
d2217 2
d2277 4
a2280 3
								stateName = null;
								comm.setStateName( stateName );
								printCurrentRoom();
d2306 2
a2307 1
									printCurrentRoom();
d2313 1
d2432 3
a2434 2
		}		
	 }	  
@


1.18
log
@*** empty log message ***
@
text
@d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.17 2004/07/22 19:33:44 rjw2183 Exp rjw2183 $
d278 10
a287 5
			myState.remove( GameState.PLAYER, leavingPlayer.getId() );
			comm.printMessage( name + " has left our world." );
			if( myFriendsList.hasPlayer( playerId ) )
				comm.printMessage( "Your friend, " + name + " has left this session." );
			myMap.removePlayer( playerId );
d376 1
a376 1
			if( myPlayer.getId().equals( playerId ) )
d426 2
a427 2
			{
				System.out.println( "Here." );
d434 1
d436 1
d869 1
a869 1
	{
d872 1
a872 1
			cancelDuel( " has left the game. Challenge cancelled." );		
d874 2
a875 2
			mySession.leaveSession( myPlayer.getId(), myPartNum );
		((Multihandle)mySession).detach( this );
d878 1
a878 1
		myMap.clearSessionInfo();
d880 1
a880 1
		myPlayer.save();
d883 2
a884 1
		inSession = false;		
@


1.17
log
@*** empty log message ***
@
text
@d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.16 2004/07/16 18:35:57 rjw2183 Exp rjw2183 $
d38 4
a41 1
implements Game, GCWindowListener, TimeListener, MerchantListener, MobListener
d44 1
a44 5
	private Game myHandle;  // this unit's unihandle 
	private SessionAd mySessionAd;  // the ad for this unit's session
	private SessionFinder sessionFinder; // an object used to find game sessions
	private GameChooser gameChooser; // Used to select games
	private GameChooserWindow gameChooserWindow; // a window for the game chooser object
d47 1
a47 4
	private Game mySession; // handle to the session this game is a part of
	private GameDiscovery allGames; //  An omnihandle to all the games in the system
	private Random intervalPRNG; // prng used to do reports
	private Timer reportTimer; // timer used to do reports
d51 1
a51 2
	private World myMap; // the world for this unit
	private PlayerCache playerCache; // the players in the session
d76 2
a81 14
	//  A private class used to perform reporting
	private class ReportTimerTask
	implements TimerTask
	{
		public ReportTimerTask()
		{
		}
		
		public void action( Timer theTimer )
		{
			invokeReport( theTimer );
		}
	}
	
d106 1
d109 2
d112 1
a112 2
		intervalPRNG = new Random();
		reportTimer = TimerThread.getDefault().createTimer( new ReportTimerTask() );
d117 2
a118 2
		myHandle = (Game)M2MI.getUnihandle( this, Game.class );			
		allGames = (GameDiscovery)M2MI.getOmnihandle( GameDiscovery.class );
d144 1
a144 3
		// Other data member initalization
		gameChooser = new GameChooser();
		sessionFinder = new SessionFinder( gameChooser );
d147 1
a147 1
		mobMover = new Random();			
d198 1
a198 1
			String playerName = playerCache.getPlayer( playerId ).getName();
d200 1
a200 2
				comm.printMessage( playerName + " yells, \"" + message + "\"" );
			playerCache.refreshTimer( playerId ); // an action has been takes by this user, so refresh the timer					
d211 1
a211 2
				comm.printMessage( theMessage.playerName + " says, \"" + theMessage.myMessage + "\"" );
			playerCache.refreshTimer( theMessage.playerId ); // an action has been takes by this user, so refresh the timer
d229 1
a229 1
			playerCache.addPlayer( player );										
d233 1
a233 2
				mySessionAd = new SessionAd( mySessionName, playerCache.numPlayers(),
							     mySession, myState );		}					
d236 1
a236 1
				mySessionAd.sessionCount = playerCache.numPlayers();
d254 1
a254 1
		{
d257 3
a259 1
			PlayerCharacter leavingPlayer = playerCache.getPlayer( playerId );
d261 18
a278 1
			playerCache.removePlayer( leavingPlayer.getId() );
d283 1
a283 1
			mySessionAd.sessionCount = playerCache.numPlayers();
d285 1
d287 1
a287 1
		}
d304 2
a305 3
					UserMove theMove = (UserMove)aMove;
				 	playerCache.refreshTimer( theMove.getUser() ); // an action has been takes by this user, so refresh the timer
					String name = playerCache.getPlayer( theMove.getUser() ).getName();
d308 1
a308 1
						PlayerCharacter thePlayer = playerCache.getPlayer( theMove.getUser() );
d330 1
d332 1
a332 1
						}		
d368 1
a368 1
	  	if( partition == myPartNum )
d376 1
a376 1
			}
d379 2
a380 25
				PlayerCharacter thePlayer = playerCache.getPlayer( playerId );
				String name = thePlayer.getName();
				if( thePlayer.isInCombat() )
				{
					if( thePlayer.hasMobTarget() )
					{
						Mob theMob = (Mob)myState.get( GameState.MOB, 
					                               (MobKey)thePlayer.getTarget() );
						theMob.stopAttack( thePlayer.getId() );
					}
					else
					{
						Eoid target = (Eoid)thePlayer.getTarget();
						PlayerCharacter fighter = playerCache.getPlayer( target );
						fighter.clearTargetData();
						if( fighter.getId().equals( myPlayer.getId() ) )
						{
							myPlayer.clearTargetData();
							thePlayerTarget = null;						
						}
					}
				}
				playerCache.removePlayer( playerId );
				comm.printMessage( name + " has timed out and has been removed from our world." );
			}                                                                               
d398 1
a398 1
				String name = playerCache.getPlayer( playerId ).getName();
d401 1
a401 2
					comm.printMessage( name + " digs a small pond in the groud." );
				playerCache.refreshTimer( playerId );
d422 5
a426 1
				String name = playerCache.getPlayer( playerId ).getName();	
d432 2
d444 1
a444 1
	{
d453 2
a454 2
					String name = playerCache.getPlayer( theHouse.getOwner() ).getName();
					comm.printMessage( name + " builds his house here." );
d489 2
d493 5
a497 1
			myMap.refreshMerchantTime( merchantType, location );
d512 1
a512 1
			String name = playerCache.getPlayer( playerId ).getName();
d540 1
a540 1
					PlayerCharacter thePlayer = playerCache.getPlayer( playerId );
d560 1
a560 1
		{
d562 2
a563 2
			PlayerCharacter playerOne = playerCache.getPlayer( p1 );
			PlayerCharacter playerTwo = playerCache.getPlayer( p2 );
d583 3
d636 1
a636 1
				PlayerCharacter thePlayer = playerCache.getPlayer( id );
d658 1
a658 1
							name = playerCache.getPlayer( theTarget ).getName();
d678 1
d683 15
d710 1
a710 1
			PlayerCharacter challenger = playerCache.getPlayer( pId );
d734 1
a734 1
			String pName = playerCache.getPlayer( pId ).getName();
d750 1
a750 1
			PlayerCharacter thePlayer = playerCache.getPlayer( pId );
d753 1
a753 1
			thePlayerTarget = playerCache.getPlayer( pId );
d770 3
a772 4
	{				
		//attemptLock();		
		if( mySession.equals( theAd.sessionHandle ) )
		{			
d785 1
a785 49
		//unlock();
	}
	
	/**
	 * Causes this to report its existence faster than normal
	 */
	public synchronized void request()
	{
		scheduleFastReport();
	}
	
	/**
	 * Reports this game's existence to the world
	 */
	private synchronized void invokeReport( Timer theTimer )
	{
		if( theTimer.isTriggered() && mySessionAd != null )
		{
			allGames.report( mySessionAd );
		}
	}
	
	 /**
	  * Schedule a normal timed report
	  */
	private void scheduleNormalReport()
	{		
		reportTimer.start( intervalPRNG.nextInt( 3000 ) + 3000 );
	}
	    
	/**
	 * Schedule a fast report
	 */
	private void scheduleFastReport()
	{
	     reportTimer.start( intervalPRNG.nextInt( 300 ) + 300 );
	}
	
	/**
	 * This schedules and emergency report, which means that the report needs to 
	 * get out as soon as is possible.  This is done when some aspect of the game's
	 * state differs from the normal state, and needs to be changed asap.  The best example
	 * of when this is called is when there is a disparity between the game's character and the character
	 * the in the state reported.
	 */
	private void scheduleEmergencyReport()
	{
		reportTimer.start( intervalPRNG.nextInt( 100  ) + 50 );
	}
d798 1
a798 1
		comm.enable();				
d801 2
a802 2
		{				
			sessionFinder.unexport();
d806 2
a807 4
			incomingState = theAd.sessionState;
			playerCache = incomingState.getCache();
			playerCache.addPlayer( myPlayer );
			playerCache.setSession( mySession );
d838 1
a838 1
				theState = GameState.mergeStates( myState, incomingState );						
d846 1
d852 4
a855 2
			mySession.joinSession( myPlayer, myPartNum );						
		}		
d863 3
a865 2
		reportTimer.stop();		
		inSession = false;
a866 2
		{
			((Multihandle)mySession).detach( this );
d868 3
a870 4
			mySession = null;
		}
		playerCache.purge();
		playerCache.addPlayer( myPlayer );
d872 6
a877 1
	}
d939 11
d951 1
a951 1
			mySession.processMove( theMove, myPartNum );		
d962 3
d967 1
a967 2
		                          theColors[round].darker(), true );
		System.err.println( damage );
d1007 1
a1007 1
				PlayerCharacter thePlayer = playerCache.getPlayer( pId );
d1037 1
a1037 1
			String pName = playerCache.getPlayer( pId ).getName();
d1054 1
a1054 1
				PlayerCharacter thePlayer = playerCache.getPlayer( temp );
d1073 1
a1073 1
								String pName = playerCache.getPlayer( pId ).getName();
d1104 1
a1104 1
			desc.append( "(" + i + ") " + (PlayerCharacter)playerCache.getPlayer( tempId ) + "\n" );
d1150 1
a1150 1
		int numPlayers = playerCache.getNameCount( name );
d1260 1
a1260 1
			PlayerCharacter thePlayer = playerCache.getPlayer( currentChallenger );
d1283 1
a1283 1
				comm.printError( "There is a file names \"players\" but it is not " +
d1293 1
a1293 1
				comm.printError( "There is a file names \"states\" but it is not " +
d1303 1
a1303 1
				comm.printError( "There is a file names \"maps\" but it is not " +
d1313 1
a1313 1
				comm.printError( "There is a file names \"maps\" but it is not " +
d1336 2
a1337 1
				myMap = new World( new GameState( myHandle, myTimeManager.getTime(), theChar.getId() ) );
d1340 2
a1341 2
			myState = myMap.getState();
			playerCache = myState.getCache();
d1348 2
a1349 2
			myPlayer.saveCharacterData();
			playerCache.removePlayer( myPlayer.getId() );
d1352 3
a1354 4
		
		myMap.setViewer( myMapWindow );		
		playerCache.addPlayer( theChar );
		myPlayer = playerCache.getPlayer( theChar.getId() );
d1356 1
d1476 3
d1484 1
a1484 2
					((Multihandle)mySession).attach( this );															
					playerCache.setSession( mySession );					
d1487 4
a1490 3
					mySessionAd = new SessionAd( mySessionName, playerCache.numPlayers(),
							             mySession, myState );												
					scheduleNormalReport();						
d1500 3
d1504 1
a1504 2
				{
					sessionFinder.export();
d1507 4
a1510 1
					gameChooserWindow = new GameChooserWindow( gameChooser, this );	
d1525 2
d1528 1
d1534 2
a1535 2
				comm.printMessage( "Player currently in the session: " );
				comm.printMessage( playerCache );
d1547 1
a1547 1
				}
d1567 1
a1567 1
					House newHouse = new House( myMap.getCurrentPlayerLocation(), myPlayer,
d1601 3
a1603 1
				    	XYloc temp = new XYloc( myMap.getCurrentPlayerLocation() );
d1605 1
a1605 2
					myMap.warp( x, y );
					myPlayer.updateLocation( temp );					
d1610 5
d1706 1
a1706 1
				playerCache.performLookup( pName, lookupVector );
d1715 1
a1715 1
					myFriendsList.addPlayer( playerCache.lookupByName( pName ) );
d1727 1
a1727 1
					Game theHandle = playerCache.lookupByName( pName ).getHandle();
d1763 1
a1763 1
					if( playerCache.validKey( tempKey )  )
d1804 1
a1804 1
						(PlayerCharacter)playerCache.getPlayer( playerId );
d1828 1
a1828 1
						PlayerCharacter temp = playerCache.getPlayer( playerId );
d2112 1
a2112 1
						if( pName.equals( playerCache.getPlayer( pId ).getName() ) )
d2127 1
a2127 1
						thePlayerTarget = playerCache.getPlayer( pId );
d2151 2
a2152 2
					String pName = playerCache.getPlayer( currentChallenger ).getName();
					Game theHandle = playerCache.getPlayer( currentChallenger ).getHandle();
d2167 2
a2168 2
					String pName = playerCache.getPlayer( currentChallenger ).getName();
					Game theHandle = playerCache.getPlayer( currentChallenger ).getHandle();
d2170 1
a2170 1
					thePlayerTarget = playerCache.getPlayer( currentChallenger );
d2247 1
d2305 1
d2320 1
d2325 4
a2328 1
				myMap.remove( ((IntCommand)command).getIntValue() );
d2354 7
a2360 1
				myPartNum = ((IntCommand)command).getIntValue();
d2365 7
a2371 8
				// Leave the session, save all the data, and then quit out
				if( consideringDuel )
					cancelDuel( " has left the game. Challenge cancelled." );
				leave();
				M2MI.unexport( this );
				myPlayer.saveCharacterData();
				myFriendsList.save();							
				System.exit( 0 );														
@


1.16
log
@*** empty log message ***
@
text
@d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.15 2004/07/06 19:57:41 rjw2183 Exp rjw2183 $
d80 1
d135 1
d210 1
a210 1
	public synchronized void yell( String message, Eoid playerId )
d212 9
a220 6
		attemptLock();
		String playerName = playerCache.getPlayer( playerId ).getName();
		if( !myPlayer.getId().equals( playerId ) )
			comm.printMessage( playerName + " yells, \"" + message + "\"" );
		playerCache.refreshTimer( playerId ); // an action has been takes by this user, so refresh the timer					
		unlock();
d223 1
a223 1
	public synchronized void say( SayData theMessage )
d225 8
a232 5
		attemptLock();
		if( myMap.checkLoc( theMessage.playerLoc ) && !myPlayer.getId().equals( theMessage.playerId ) )
			comm.printMessage( theMessage.playerName + " says, \"" + theMessage.myMessage + "\"" );
		playerCache.refreshTimer( theMessage.playerId ); // an action has been takes by this user, so refresh the timer
		unlock();
d242 1
a242 1
	public synchronized void joinSession( PlayerCharacter player )
d244 21
a264 19
	 	attemptLock();		
		reportTimer.stop();								
		playerCache.addPlayer( player );										
		myState.setTime( myTimeManager.getTime() );
		if( myHandle.equals( player.getHandle() ) )		
		{									
			mySessionAd = new SessionAd( mySessionName, playerCache.numPlayers(),
						     mySession, myState );		}					
		else
		{		
			mySessionAd.sessionCount = playerCache.numPlayers();
			mySessionAd.sessionState = myState;
		}	
					
		comm.printMessage( player.getName() + " has joined our world." );
		if( myFriendsList.hasPlayer( player.getId() ) )
			comm.printMessage( "Your friend, " + player.getName() + " has joined this session." );		
		scheduleNormalReport();			
		unlock();	
d271 1
a271 1
	 public synchronized void leaveSession( Eoid playerId )
d273 1
a273 15
		attemptLock();
		try
		{		
		reportTimer.stop();			
		PlayerCharacter leavingPlayer = playerCache.getPlayer( playerId );
		String name = leavingPlayer.getName();		
		playerCache.removePlayer( leavingPlayer.getId() );
		comm.printMessage( name + " has left our world." );
		if( myFriendsList.hasPlayer( playerId ) )
			comm.printMessage( "Your friend, " + name + " has left this session." );
		myMap.removePlayer( playerId );
		mySessionAd.sessionCount = playerCache.numPlayers();
		scheduleNormalReport();
		}
		catch( Exception e )
d275 12
a286 2
			e.printStackTrace();
			System.exit( 1 );
a287 1
		unlock();
d295 1
a295 1
	 public synchronized void processMove( MoveData aMove )
d297 4
a300 4
		attemptLock();
		switch( aMove.getType() )
		{
			case MoveData.PLAYER:
d302 18
a319 14
				UserMove theMove = (UserMove)aMove;
			 	playerCache.refreshTimer( theMove.getUser() ); // an action has been takes by this user, so refresh the timer
				String name = playerCache.getPlayer( theMove.getUser() ).getName();
				if( !myPlayer.getId().equals( theMove.getUser() ) )
				{		
					PlayerCharacter thePlayer = playerCache.getPlayer( theMove.getUser() );
					if( thePlayer.isInCombat() )
					{
						Mob theMob = (Mob)myState.get(
						GameState.MOB, (MobKey)thePlayer.getTarget() );
						theMob.stopAttack();
						thePlayer.clearTargetData();
						comm.printMessage( name + " disengages combat with " + theMob.getName() );
					}
d321 12
a332 4
					if( myMap.checkLoc( theMove.getLoc( MoveData.FROM ) ) )
					{
						String[] directions = { "north", "south", "east", "west" };
						comm.printMessage( name + " leaves to the " + directions[theMove.getDirection()] );
d334 22
a355 6
					else if( myMap.checkLoc( theMove.getLoc( MoveData.TO ) ) )
					{
						String[] directions = { "south", "north", "west", "east" };
						comm.printMessage( name + " enters from the " + directions[theMove.getDirection()] );
					}
					myMap.processMove( theMove );			
d357 4
a360 26
			}
			break;
			case MoveData.MOB:
			{						
				MobMove theMove = (MobMove)aMove;				
				myMap.refreshMobTimer( theMove.getKey() );					
				if( theMove.getDirection() != -1 )
				{					
					String name = theMove.getName();					
					boolean validMob = myMap.moveMob( theMove );
					
					if( myMap.checkLoc( theMove.getLoc( MoveData.FROM ) ) && validMob )
					{
						String[] directions = { "north", "south", "east", "west" };
						comm.printMessage("A " + name + " leaves to the " + directions[theMove.getDirection()] );
					}
					else if( myMap.checkLoc( theMove.getLoc( MoveData.TO ) ) && validMob )
					{
						String[] directions = { "south", "north", "west", "east" };
						comm.printMessage(  "A " + name + " enters from the " + directions[theMove.getDirection()] );
					}										
				}				
			}
			break;
	 	}
		unlock();
d362 7
a368 8
	 /**
	  * Notifies this unit that a player has timed out and must thus be removed.
	  * @@param: handle The unihande of the game unit which has timed out.
	  */
	  public synchronized void notifyPlayerTimeout( Eoid playerId )
	  {
	  	attemptLock();
		if( myPlayer.getId().equals( playerId ) )
d370 5
a374 2
			leave();
			comm.printMessage( "Disconnected from the session as there has " +
d376 2
a377 6
		}
		else
		{
			PlayerCharacter thePlayer = playerCache.getPlayer( playerId );
			String name = thePlayer.getName();
			if( thePlayer.isInCombat() )
d379 3
a381 1
				if( thePlayer.hasMobTarget() )
d383 3
a385 1
					Mob theMob = (Mob)myState.get( GameState.MOB, 
d387 3
a389 8
					theMob.stopAttack();
				}
				else
				{
					Eoid target = (Eoid)thePlayer.getTarget();
					PlayerCharacter fighter = playerCache.getPlayer( target );
					fighter.clearTargetData();
					if( fighter.getId().equals( myPlayer.getId() ) )
d391 8
a398 2
						myPlayer.clearTargetData();
						thePlayerTarget = null;						
d401 5
a405 5
			}
			playerCache.removePlayer( playerId );
			comm.printMessage( name + " has timed out and has been removed from our world." );
		}                                                                               
		unlock();		
d414 1
a414 1
	  public synchronized void setPond( XYloc location, Eoid playerId )
d416 1
a416 2
		attemptLock();
		if( !myPlayer.getId().equals( playerId ) )
d418 11
a428 5
			String name = playerCache.getPlayer( playerId ).getName();
		  	myMap.setPondAt( location );
			if( myMap.checkLoc( location ) )
				comm.printMessage( name + " digs a small pond in the groud." );
			playerCache.refreshTimer( playerId );
a429 2
		myState.add( GameState.POND, location );
		unlock();
d439 1
a439 1
	  public synchronized void warp( Eoid playerId, XYloc from, XYloc to )
d441 13
a453 9
		attemptLock();
		if( !myPlayer.getId().equals( playerId ) )
		{
			String name = playerCache.getPlayer( playerId ).getName();	
			if( myMap.checkLoc( from ) )
				comm.printMessage( name + "  suddenly vanishes from sight!" );
			myMap.performWarp( playerId, from, to );
			if( myMap.checkLoc( to ) )
				comm.printMessage( name + " suddenly phases into view!" );
a454 1
		unlock();
d461 1
a461 1
	public synchronized void addHouse( House theHouse )
d463 1
a463 2
		attemptLock();
		if( !theHouse.getOwner().equals( myPlayer.getId() ) )
d465 2
a466 2
			myMap.placeHouse( theHouse );
			if( myMap.checkLoc( theHouse.getLocation() ) )
d468 8
a475 3
				String name = playerCache.getPlayer( theHouse.getOwner() ).getName();
				comm.printMessage( name + " builds his house here." );
			}				
a476 1
		unlock();
d483 1
a483 1
	public synchronized void notifyTimePassage( int newTime )
d485 9
a493 6
		attemptLock();
		myTimeManager.synchronize( newTime );
		myState.setTime( newTime );
		myMapWindow.updateTime( newTime );
		comm.printMessage( myTimeManager.getTimePassageString( newTime ) );
		unlock();
d502 1
a502 1
	public synchronized void merchantBroadcast( int merchantType, XYloc location )
d504 8
a511 5
		attemptLock();
		if( myMap.checkLoc( location ) )
			comm.printMessage( myMap.getMerchantBroadcast( merchantType ) );
		myMap.refreshMerchantTime( merchantType, location );
		unlock();
d519 1
a519 1
	public synchronized void sendPM( Eoid playerId, String message )
d521 7
a527 4
		attemptLock();
		String name = playerCache.getPlayer( playerId ).getName();
		comm.printMessage( name + " sends, \"" + message + "\"" );
		unlock();
d541 1
a541 1
	 public synchronized void registerAttacker( XYloc loc, MobKey theKey, Eoid playerId )
d543 1
a543 4
	 	attemptLock();
		Mob theMob = (Mob)myState.get( GameState.MOB, theKey );
		theMob.startAttackSilent();			
		if( myMap.checkLoc( loc ) && !myPlayer.getId().equals( playerId ) )
d545 16
a560 8
			PlayerCharacter thePlayer = playerCache.getPlayer( playerId );
			String pName = thePlayer.getName();
			thePlayer.registerTarget( theKey );
			comm.printMessage( pName + " begins attacking the " + theMob.getName() + "!",
			                   Color.red.darker() );
			
		}			
		unlock();
d569 1
a569 1
	public synchronized void notifyFight( Eoid p1, Eoid p2, XYloc loc )
d571 13
a583 10
		attemptLock();
		PlayerCharacter playerOne = playerCache.getPlayer( p1 );
		PlayerCharacter playerTwo = playerCache.getPlayer( p2 );
		playerOne.registerTarget( p2 );
		playerTwo.registerTarget( p1 );
		unlock();
		if(    myMap.checkLoc( loc ) && 
		    ( !myPlayer.getId().equals( p1 ) && !myPlayer.getId().equals( p2 ) ) 
		  )
			comm.printMessage( playerOne.getName() + " and " + playerTwo.getName() + " begin fighting!" );		
d589 1
a589 1
	public synchronized void printAttack( int damage )
d591 6
a596 12
		attemptLock();
		String pName = thePlayerTarget.getName();
		comm.printCombatMessage( pName + " attacks you for " + damage + " damage!", Color.red.darker(), true );
		myPlayer.adjustHP( -1 * damage );
		comm.setActivePlayer( myPlayer );
		if( !myPlayer.isAlive() )
		{
			comm.printMessage( "You were just killed by " + pName );		
			thePlayerTarget = null;
			myPlayer.clearTargetData();
			myMap.warp( 0, 0 );
			myPlayer.ressurect();
d598 14
a611 3
			comm.clearCombatLog();
			printCurrentRoom();	
			mySession.notifyPlayerDeath( myPlayer.getId(), myMap.getCurrentPlayerLocation() );
a612 1
		unlock();
d619 1
a619 1
	public synchronized void notifyMobRespawn( MobKey theKey )
d621 10
a630 7
		attemptLock();
		Mob theMob = (Mob)myState.get( GameState.MOB, theKey );
		if( !theMob.isAlive() )
			theMob.respawn();
		if( myMap.checkLoc ( theMob.getCurrentLocation() ) )
			comm.printMessage( theMob.getName() + " is restored back to life." );
		unlock();
d638 1
a638 1
	public synchronized void notifyPlayerDeath( Eoid id, XYloc loc )
d640 1
a640 1
		if( !myPlayer.getId().equals( id ) )
d642 1
a642 3
			attemptLock();
			PlayerCharacter thePlayer = playerCache.getPlayer( id );
			if( myMap.checkLoc( loc ) )
d644 3
a646 2
				String name = null;
				if( thePlayer.hasMobTarget() )
d648 2
a649 9
					Mob theMob = (Mob)myState.get( GameState.MOB, 
					(MobKey)thePlayer.getTarget() );
					name = theMob.getName();
					theMob.stopAttack();
				}
				else
				{
					Eoid theTarget = (Eoid)thePlayer.getTarget();
					if( myPlayer.getId().equals( theTarget ) )
d651 4
a654 4
						name = myPlayer.getName();
						myPlayer.clearTargetData();
						thePlayerTarget = null;
						comm.clearCombatLog();
d657 14
a670 1
						name = playerCache.getPlayer( theTarget ).getName();
d672 3
a674 2
				comm.printMessage( thePlayer.getName() + " was just killed by " + name + "!" );
				
a675 3
			thePlayer.clearTargetData();
			myMap.performWarp( id, loc, new XYloc( 0, 0 ) );
			unlock();
d679 1
a679 1
	public synchronized void updateState( GameState theState )
d681 9
a689 6
		attemptLock();
		theState.setId( myPlayer.getId() );
		myMap.updateState( theState, this, this );
		myState = myMap.getState();
		myState.setId( myPlayer.getId() );
		unlock();
d698 1
a698 1
	 public synchronized void requestDuel( Eoid pId )
d700 1
a700 5
	 	attemptLock();
		PlayerCharacter challenger = playerCache.getPlayer( pId );
		if( consideringDuel )
			challenger.getHandle().declineDuel( " is already considering another duel.", myPlayer.getId() );
		else
d702 12
a713 3
			comm.printMessage( challenger.getName() + " has challenged you to a duel!" );
			consideringDuel = true;
			currentChallenger = pId;
a714 1
		unlock();
d722 1
a722 1
	 public synchronized void declineDuel( String reason, Eoid pId )
d724 8
a731 5
	 	attemptLock();
		String pName = playerCache.getPlayer( pId ).getName();
		comm.printMessage( pName + reason );
		consideringDuel = false;
		unlock();
d738 1
a738 1
	 public synchronized void acceptDuel( Eoid pId )
d740 10
a749 7
	 	attemptLock();
		PlayerCharacter thePlayer = playerCache.getPlayer( pId );
		comm.printMessage( thePlayer.getName() + " has accepted your challenge! Begin fighting!" );
		consideringDuel = false;
		thePlayerTarget = playerCache.getPlayer( pId );
		myPlayer.registerTarget( pId );
		unlock();
d771 1
a771 1
				myState.synchronize( theAd.sessionState );
d883 1
a883 1
				mySession.updateState( theState );	
d895 1
a895 1
			mySession.joinSession( myPlayer );						
d909 1
a909 1
			mySession.leaveSession( myPlayer.getId() );
d926 1
a926 1
			mySession.notifyTimePassage( newTime );			
d945 1
a945 1
				mySession.merchantBroadcast( merchantType, location );			
d968 1
a968 1
			mySession.notifyMobRespawn( key );
d978 1
a978 1
			mySession.processMove( theMove );		
d992 1
d1001 1
a1001 1
			theMobTarget.stopAttack();
d1007 2
a1008 1
				mySession.notifyPlayerDeath( myPlayer.getId(), myMap.getCurrentPlayerLocation() );
d1025 1
a1025 1
	public synchronized void notifyMobDeath( XYloc loc, Eoid pId )
d1027 13
a1039 9
		attemptLock();
		if( !myPlayer.getId().equals( pId ) )
		{
			PlayerCharacter thePlayer = playerCache.getPlayer( pId );
			Mob theMob = (Mob)myState.get( GameState.MOB, (MobKey)thePlayer.getTarget() );
			thePlayer.clearTargetData();
			theMob.kill();
			if( myMap.checkLoc( loc )  )
				comm.printMessage( thePlayer.getName() + " kills the " + theMob.getName() );
a1040 1
		unlock();		
d1267 1
a1267 1
			mySession.notifyMobDeath( myMap.getCurrentPlayerLocation(), myPlayer.getId() );
d1278 1
a1278 1
			thePlayerTarget.getHandle().declineDuel( reason, myPlayer.getId() );
d1286 1
a1286 1
			thePlayer.getHandle().declineDuel( reason, thePlayer.getId() );
d1459 1
a1459 1
						theMob.stopAttack();
d1481 1
a1481 1
							mySession.processMove( movement );					
d1493 1
a1493 1
					mySession.yell( ((StringCommand)command).getStringData(), myPlayer.getId() );	
d1559 1
a1559 1
					mySession.say( myMessage );
d1572 1
a1572 1
						mySession.setPond( myMap.getCurrentPlayerLocation(), myPlayer.getId() );					
d1585 1
a1585 1
						mySession.addHouse( newHouse );
d1620 2
a1621 1
						mySession.warp( myPlayer.getId(), temp, myMap.getCurrentPlayerLocation() );
d1735 1
a1735 1
					theHandle.sendPM( myPlayer.getId(), ((SendCommand)command).getStringData() );
d1737 1
a1737 1
					"\" to " + pName + "." );	
d1816 1
a1816 1
							sComm.getStringData() );
d1978 1
a1978 1
							theMobTarget.startAttack();
d1984 1
a1984 1
								theMobTarget.getKey(), myPlayer.getId() );
d2079 1
a2079 1
							thePlayerTarget.getHandle().printAttack( damage );
d2143 1
a2143 1
							theGame.requestDuel( myPlayer.getId() );
d2161 2
a2162 1
					theHandle.declineDuel( " has declined your challenge.", myPlayer.getId() );
d2176 1
a2176 1
					theHandle.acceptDuel( myPlayer.getId() );
d2180 2
a2181 1
					mySession.notifyFight( thePlayerTarget.getId(), myPlayer.getId(), myMap.getCurrentPlayerLocation() );
d2353 5
@


1.15
log
@*** empty log message ***
@
text
@d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.14 2004/07/01 19:49:42 rjw2183 Exp rjw2183 $
a51 1
	private File mapFile;
d61 1
a79 1
	private GameConfig myConfig;
d133 1
a134 1
		
d150 5
a154 1
		mapFile = null;
a155 60
		
		// Try to load the previous settings
		myConfig = GameConfig.load();
		if( myConfig == null )
		{
			comm.printError( "The configuration data about the " + 
			"character and world were not found. The system is using the " +
			"default world.  Please create a new character or load one." );
		}
		else
		{
			// Try to load the actual data
			String pName = myConfig.get( GameConfig.PLAYER );
			String wName = myConfig.get( GameConfig.WORLD );
			myPlayer = PlayerCharacter.loadCharacterDataFromFile( myHandle, pName );
			if( myPlayer == null )
			{
				comm.printError( "Player not found. Please load or create a new one" );
			}
			else
			{
				myState = new GameState( myHandle, myTimeManager.getTime() );
				myMap = World.getWorld( myState, wName );
				if( myMap == null )
				{
					comm.printMessage( "No world data found, using default." );
					myMap = new World( myPlayer.getId(), myState );
					myConfig.set( GameConfig.WORLD, myMap.getName() );
					myMap.saveWorldData();
					myConfig.save();
					comm.printMessage( "World  created and saved." );
				}
				else
					comm.printMessage( "World loaded." );
					
				// Register the map viewer
				myMap.setViewer( myMapWindow );	
			
				// Get the player cache 
				playerCache = myState.getCache();
				
				// This may seem like a roundabout thing to do, 
				// but it ensures that the myPlayer is set to the 
				// object that resisdes in the player cache, so that any updates
				// done on the player are made immediatley to the state object
				Eoid temp = myPlayer.getId();
				playerCache.addCharacter( myPlayer );
				myPlayer = playerCache.getPlayer( temp );
			
				// Attempt to load the friends' listing
				myFriendsList = FriendsList.loadFromFile();
				if( myFriendsList == null || !myFriendsList.getPlayerId().equals( myPlayer.getId() ) )
					myFriendsList = new FriendsList();
				
				// All set!  print out the room and start things going
				printCurrentRoom();
				comm.setActivePlayer( myPlayer );
				myTimeManager.start();	
			}
		}
d234 1
a234 1
	public synchronized void joinSession( Game handle, PlayerCharacter player, GameState newState )
d236 3
a238 11
	 	attemptLock();
		try
		{
		reportTimer.stop();							
		playerCache.addCharacter( player );		
		if( !myHandle.equals( handle ) )
			myState = GameState.mergeStates( newState, myState );		
		else
			myState = GameState.mergeStates( newState, incomingState );
			
		myMap.processState( myState, this );								
d240 1
a240 1
		if( myHandle.equals( handle ) )		
d245 1
a245 1
		{
d252 2
a253 8
			comm.printMessage( "Your friend, " + player.getName() + " has joined this session." );
		handle.addPlayer( myMap.getCurrentPlayerLocation(), myPlayer.getId() );
		scheduleNormalReport();
		}
		catch( Exception e )
		{
			e.printStackTrace();
		}	
d264 2
d276 6
d307 1
a307 1
						theMob.unregisterAttacker();
d374 1
a374 1
					theMob.unregisterAttacker();
a393 16
	  /**
	   * Places the given player at the specified location.
	   * @@param location The location to put the player at
	   * @@param playerId The id of the player to place
	   */
	  public synchronized void addPlayer( XYloc location, Eoid playerId )
	  {	  	
		attemptLock();
		if( !myPlayer.getId().equals( playerId ) )
		{
			myMap.addPlayer( location, playerId );
			if( myMap.checkLoc( location ) == true )
				comm.printMessage(  playerCache.getPlayer( playerId ).getName() + " suddenly appears!" );
		}
		unlock();
	  }	
d513 1
a513 1
		theMob.registerAttackerSilent( playerId );			
d605 1
a605 1
					theMob.unregisterAttacker();
d628 10
d701 1
d704 11
a714 1
			scheduleNormalReport();
d716 1
d733 1
d735 1
d743 1
a743 1
		reportTimer.start( intervalPRNG.nextInt( 6000 ) + 6000 );
d751 1
a751 1
	     reportTimer.start( intervalPRNG.nextInt( 600 ) + 600 );
d753 13
d787 1
a787 1
			playerCache.addCharacter( myPlayer );
d789 1
d791 2
a792 1
			if( incomingState.getConfig() != null )
d794 1
a794 1
				myMap.saveWorldData();
d797 8
a804 21
				try
				{					
					File theFile = new File( "maps/" + incomingState.getConfig().getFileName() );
					if( !theFile.exists() )
					{
						FileWriter fw = new FileWriter( theFile );
						BufferedWriter writer = new BufferedWriter( fw );
						String data = incomingState.getConfig().toString();
						writer.write( data, 0, data.length() );
						writer.close();
						fw.close();
						
					}
					myConfig.set( GameConfig.WORLD, myMap.getName() );	
					myConfig.save();					
				}	
				catch( IOException e )
				{
					e.printStackTrace();
					System.exit( 1 );
				}										
d806 22
a827 2
			else 
				System.err.println( "config is null." );
d830 1
d832 1
a832 2
			mySession.joinSession( myHandle, myPlayer, myState );			
			mySession.addPlayer( myMap.getCurrentPlayerLocation(), myPlayer.getId() );						
d850 1
a850 1
		playerCache.addCharacter( myPlayer );
d892 1
a892 1
	 public void attackTarget( Eoid target, int damage, String name )
d894 1
a894 3
		if( myPlayer.getId().equals( target ) )
			doAttack( damage, name );
		
d937 1
a937 1
			theMobTarget.unregisterAttacker();
d973 1
a973 1
	}
d1014 1
a1014 1
					// Simplt print out the name if the player is not in comabt
d1017 1
a1017 2
						String name = thePlayer.getName();
						playerName.append( " " + name );
d1036 5
a1040 1
							System.err.println( "null" );
d1276 50
d1336 4
a1339 1
		if( myPlayer == null && command.getType() != Command.CREATE )
d1341 2
a1342 1
			comm.printError( "Cannot execute other commands without creating a character" );
d1357 3
a1360 50
				// if there was a previous character, save it
				if( myPlayer != null )
				{
					playerCache.removePlayer( myPlayer.getId() );
					myPlayer.saveCharacterData();
					myPlayer = null;
				}
				
				// Create the character
				myPlayer = PlayerCharacter.createNewCharacter( (PlayerCreationCommand)command, myHandle );
				myPlayer.saveCharacterData();
				
				// If the world is null, create a new default one
				if( myMap == null )
				{
					
					myState = new GameState( myHandle, myTimeManager.getTime() );
					myMap = new World( myPlayer.getId(), myState );
					myMap.saveWorldData();
				
				}
					
				// Register the map viewer
				myMap.setViewer( myMapWindow );	
				
				// Get the player cache 
				if( playerCache == null );
					playerCache = myState.getCache();
					
				// This may seem like a roundabout thing to do, 
				// but it ensures that the myPlayer is set to the 
				// object that resisdes in the player cache, so that any updates
				// done on the player are made immediatley to the state object
				Eoid temp = myPlayer.getId();
				playerCache.addCharacter( myPlayer );
				myPlayer = playerCache.getPlayer( temp );
			
				// Attempt to load the friends' listing
				myFriendsList = FriendsList.loadFromFile();
				if( myFriendsList == null || !myFriendsList.getPlayerId().equals( myPlayer.getId() ) )
					myFriendsList = new FriendsList();
				
				// All set!  print out the room and start things going
				comm.setActivePlayer( myPlayer );
				printCurrentRoom();
				
				myTimeManager.start();	
				myConfig = new GameConfig( myPlayer.getName(), myMap.getName() );
				
				myConfig.save();							
d1375 1
a1375 1
				comm.printMessage( myPlayer.toString() + " at location " + myMap.getCurrentPlayerLocation().toString() );				
d1391 1
a1391 1
						theMob.unregisterAttacker();
d1401 3
a1403 1
						// Prints out the room, finish fillig in the data
d1480 1
a1480 1
				comm.printMessage( playerCache.getCharacters() );
d1510 14
a1523 6
				House newHouse = new House( myMap.getCurrentPlayerLocation(), myPlayer,
				 	          (HouseCreationCommand)command );
				myMap.placeHouse( newHouse );				
				comm.printMessage( "You place your house at " + newHouse.getLocation() );
				if( mySession != null )
					mySession.addHouse( newHouse );
d1548 2
a1549 1
					myMap.warp( x, y );					
a1563 1
					System.out.println( type );
d1701 1
a1701 1
					if( playerCache.checkPlayer( tempKey )  )
d1909 1
a1909 1
							theMobTarget.registerAttacker( myPlayer.getId() );
d2137 1
a2137 1
								comm.printError( "Player not found." );
d2139 1
a2139 11
							{
								comm.clear();
								playerCache.removePlayer( myPlayer.getId() );
								myPlayer.saveCharacterData();							
								playerCache.addCharacter( temp );
								myPlayer = playerCache.getPlayer( temp.getId() );
								myConfig.set( GameConfig.PLAYER, myPlayer.getName() );	
								comm.setActivePlayer( myPlayer );
								myConfig.save();
								printCurrentRoom();							
							}
d2147 3
a2149 1
							if( !theFile.exists() )
d2152 1
a2152 2
							{
								myMap.saveWorldData();
d2159 2
a2160 2
								myConfig.set( GameConfig.WORLD, myMap.getName() );
								myConfig.save();
d2167 22
a2188 1
						{
d2190 1
a2190 1
						
d2195 87
d2290 1
a2290 3
				myMap.saveWorldData();
				myFriendsList.save();	
				myConfig.save();			
d2292 1
a2292 1
			}
d2297 1
a2297 2
}	 
	     
@


1.14
log
@*** empty log message ***
@
text
@d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.13 2004/06/29 20:00:18 rjw2183 Exp rjw2183 $
d80 1
d123 2
a133 1
		comm = theComm;
d135 1
d152 5
a156 8
				
		// Try to load the player's character data
		// Everything is attached the character's id, if there is
		// no character, or the id for the world and friends' listing are
		// not the sam as the character, they must be recreated.
		comm.printMessage( "Loading character data..." );
		myPlayer = PlayerCharacter.loadCharacterDataFromFile( myHandle );
		if( myPlayer == null )
d158 3
a160 2
			comm.printError( "No character data found." );
			comm.printError( "Please create a new one using the CREATE command." );			
d162 1
a162 1
		else		
d164 5
a168 9
			// Attempt to load the world from a file.
			comm.printMessage( "Character data loaded." );	
			comm.printMessage( "Loading world data..." );
			
			// First, create the state object that will be used by the world and the
			// GameSystem object
			myState = new GameState( myHandle, myTimeManager.getTime() );
			myMap = World.getWorld( myState );
			if( myMap == null )
d170 1
a170 5
				// no map was found, create a default one
				comm.printMessage( "World data not found. Creating and saving new world...", Color.red );
				myMap = new World( myPlayer.getId(), myState );
				myMap.saveWorldData();
				comm.printMessage( "World created and saved." );			
d172 1
a172 4
			else			
				comm.printMessage( "World loaded." );
			
			if( myMap.getName() != null )
d174 3
a176 3
				String fileName = myMap.getName() + ".map";
				mapFile = new File( fileName );
				if( !mapFile.exists() )
d178 1
a178 2
					comm.printError( "Configuration file for the map does not exist. " +
					"Clearing world." );
d180 4
a183 1
					mapFile = null;
d185 5
a189 3
			}	
			// Register the map viewer
			myMap.setViewer( myMapWindow );	
d191 10
a200 2
			// Get the player cache 
			playerCache = myState.getCache();
d202 4
a205 12
			// This may seem like a roundabout thing to do, 
			// but it ensures that the myPlayer is set to the 
			// object that resisdes in the player cache, so that any updates
			// done on the player are made immediatley to the state object
			Eoid temp = myPlayer.getId();
			playerCache.addCharacter( myPlayer );
			myPlayer = playerCache.getPlayer( temp );
			
			// Attempt to load the friends' listing
			myFriendsList = FriendsList.loadFromFile();
			if( myFriendsList == null || !myFriendsList.getPlayerId().equals( myPlayer.getId() ) )
				myFriendsList = new FriendsList();
d207 5
a211 4
			// All set!  print out the room and start things going
			printCurrentRoom();
			comm.setActivePlayer( myPlayer );
			myTimeManager.start();					
d213 1
a213 1
		
d219 1
a219 3
		mobMover = new Random();
		
			
a300 1
		{
a302 3
		}
		if( myState == null )
			System.err.println( "myState is null." );
d832 29
d1107 1
a1107 1
	 	File itemFile = new File( "items.dat" );
d1255 53
a1307 1
	}		
d1333 5
a1337 3
				if( myPlayer != null  )
					comm.printError( "You already have a character." );
				else		
d1339 12
a1350 4
					// Create a new character
					myPlayer = PlayerCharacter.createNewCharacter( (PlayerCreationCommand)command, myHandle );										
					comm.printMessage( "Character " + myPlayer.getName() + " created and saved!" );
					comm.printMessage( "Creating world." );
d1353 1
a1353 3
					
					// Create a new map
					myMap = new World( myPlayer.getId(), myState );	
d1355 2
a1356 1
					comm.printMessage( "World created and saved." );
d1358 5
a1362 6
					// create a new friend's listing
					myFriendsList = new FriendsList( myPlayer.getId() );			
					
					//  start the time managaer and map window
					myTimeManager.start();					
					myMap.setViewer( myMapWindow );
a1363 3
					Eoid temp = myPlayer.getId();
					playerCache.addCharacter( myPlayer );
					myPlayer = playerCache.getPlayer( temp );
d1365 21
a1385 4
					// Finally, set the active player and print out the room
					comm.setActivePlayer( myPlayer );
					printCurrentRoom();				
				}					
a2137 10
				String name = ((StringCommand)command).getStringData() + ".map";				
				try
				{
					mapFile = new File( name );
				}
				catch( Exception e )
				{
					e.printStackTrace();
				}
								
d2139 1
a2139 4
					comm.printError( "You are in a session and may not modify "  + 
							 "the world in this fashion." );
				else if( !mapFile.exists() )
					comm.printError( name + ": world file not found." );				
d2141 46
a2186 1
				{
d2188 8
a2195 8
					WorldConfiguration theConfig = new WorldConfiguration( mapFile );
										
					comm.printMessage( "Loading world.." );
					myState.setConfig( theConfig );
					myMap.createWorld();
					comm.printMessage( "World loaded!" );
					printCurrentRoom();
				}				
d2207 2
a2208 1
				myFriendsList.save();				
@


1.13
log
@*** empty log message ***
@
text
@d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.12 2004/06/23 19:57:24 rjw2183 Exp rjw2183 $
d52 1
d148 1
d179 1
a179 1
			else
d181 13
a193 1
				
d319 1
a319 3
						     mySession,
						     myState );
		}					
d841 2
a842 1
			playerCache.setSession( mySession );						
d1373 1
a1373 1
							             mySession, myState );
d1466 2
a1467 2
				if( ( 0 <= x && x <= 99 ) &&
				    ( 0 <= y && y <= 99 ) )
d1476 2
d2046 1
a2046 2
				String name = ((StringCommand)command).getStringData() + ".map";
				File theFile = null;
d2049 1
a2049 1
					theFile = new File( name );
d2059 1
a2059 1
				else if( !theFile.exists() )
d2063 3
d2067 2
a2068 1
					myMap.createWorld( theFile );
@


1.12
log
@*** empty log message ***
@
text
@d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.11 2004/06/22 15:19:32 rjw2183 Exp rjw2183 $
d58 1
d121 1
d125 2
d131 1
d145 1
d161 1
d164 5
a168 1
			myMap = World.getWorld();
d171 1
d173 1
a173 1
				myMap = new World( myPlayer.getId() );
a176 7
			else if( !myMap.getId().equals( myPlayer.getId() ) )
			{	
				comm.printMessage( "This is not the world for this character, recreating world." );
				myMap = new World( myPlayer.getId() );
				myMap.saveWorldData();
				comm.printMessage( "World created and saved." );
			}
d180 15
d197 6
a202 1
				myFriendsList = new FriendsList();					
a204 14
		// Set up the player cache.  If the user has a character add it to the cache
		// and print the description of where the player currently is
		playerCache = new PlayerCache();
		if( myPlayer != null )
		{
			playerCache.addCharacter( myPlayer );
			myTimeManager.start();
			myMap.setTime( myTimeManager.getTime() );
			myMap.setViewer( myMapWindow );
			printCurrentRoom();
			comm.setActivePlayer( myPlayer );				
		}
			                                                                             

d287 2
d291 11
a301 9
		/*
		 * Here is the reason a joining session's myState variable is set to the state of the session,
		 * and not its own state.  The reason is so that all memebers of the session will call the same funcion
		 * on the same data and thus get the same results.
		 */
		myState = GameState.mergeState( newState, myState );
		myMap.processState( myState, this, this );					
		myState = myMap.buildState();		
		myState.synchronizeTime( myTimeManager.getTime() );
d305 1
a305 1
						     mySession, playerCache.getTransferData(),
d310 1
a310 2
			mySessionAd.sessionCount = playerCache.numPlayers();		
			mySessionAd.sessionPlayers = playerCache.getTransferData();
d318 6
a323 1
		scheduleNormalReport();	
d367 2
a368 1
						Mob theMob = myMap.getMob( (MobKey)thePlayer.getTarget() );
a395 2
					if( validMob )
						myState.updateMobLoc( theMove.getKey(), theMove.getLoc(MoveData.TO) );
d434 2
a435 1
					Mob theMob = myMap.getMob( (MobKey)thePlayer.getTarget() );
d489 1
a489 1
		myState.add( GameState.PONDS, location );
a540 1
		myMap.setTime( newTime );
d542 2
a543 1
		mySessionAd.sessionState.synchronizeTime( myTimeManager.getTime() );
d590 2
a591 3
		Mob theMob = myMap.getMob( theKey );
		theMob.registerAttackerSilent( playerId );
		myState.updateMobAttacker( theMob.getKey(), playerId );		
d656 1
a656 1
		Mob theMob = myMap.getMob( theKey );
d680 2
a681 1
					Mob theMob = myMap.getMob( (MobKey)thePlayer.getTarget() );
a770 1
			myState.checkandSynchronize( theAd, myMap, playerCache );
d825 5
a829 4
			mySessionName = theAd.sessionName;						
			myState = theAd.sessionState;	// This may seem odd, but it is explained in the joinSession
			playerCache.setSession( mySession );
			playerCache.processTransferData( theAd.sessionPlayers );								
d833 1
a833 1
			mySession.joinSession( myHandle, myPlayer, myMap.buildState() );			
d868 1
a868 1
			myMap.setTime( newTime );
d970 1
a970 1
			Mob theMob = myMap.getMob( (MobKey)thePlayer.getTarget() );
d1259 2
d1262 1
a1262 1
					myMap = new World( myPlayer.getId() );	
d1270 1
a1270 2
					myTimeManager.start();
					myMap.setTime( myTimeManager.getTime() );
d1272 2
d1275 1
d1309 2
a1310 1
						Mob theMob = myMap.getMob( (MobKey)myPlayer.getTarget() );
d1358 1
a1358 3
					myMap.spawnMobs( this );
					myState = myMap.buildState();	
					myState.synchronizeTime( myTimeManager.getTime() );																					
d1360 1
a1360 2
							             mySession, playerCache.getTransferData(),
								     myState );
d2029 27
@


1.11
log
@*** empty log message ***
@
text
@d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.10 2004/06/22 15:18:58 rjw2183 Exp rjw2183 $
d63 1
a63 1
	private Eoid thePlayerTarget; // the player target the player is currently fighting.
d67 1
a67 3
	private Eoid currentChallenger; // the current duel challenger
	private Eoid currentPlayerTarget; // the
	private Game targetHandle;
a139 2
		currentPlayerTarget = null;
		targetHandle = null;
d414 16
a429 2
				Mob theMob = myMap.getMob( (MobKey)thePlayer.getTarget() );
				theMob.unregisterAttacker();
d586 104
d723 4
d733 1
a733 2
		thePlayerTarget = pId;
		targetHandle = playerCache.getPlayer( pId ).getHandle();
d736 1
a736 15
	 }
	 
	public synchronized void notifyFight( Eoid p1, Eoid p2, XYloc loc )
	{
		attemptLock();
		PlayerCharacter playerOne = playerCache.getPlayer( p1 );
		PlayerCharacter playerTwo = playerCache.getPlayer( p2 );
		playerOne.registerTarget( p2 );
		playerTwo.registerTarget( p1 );
		unlock();
		if(    myMap.checkLoc( loc ) && 
		    ( !myPlayer.getId().equals( p1 ) && !myPlayer.getId().equals( p2 ) ) 
		  )
			comm.printMessage( playerOne.getName() + " and " + playerTwo.getName() + " begin fighting!" );		
	}	
d738 1
a738 8
	public synchronized void printAttack()
	{
		attemptLock();
		String pName = playerCache.getPlayer( thePlayerTarget ).getName();
		comm.printCombatMessage( pName + " attacks you!", Color.red.darker(), true );
		unlock();
	}
/********************************************************************************************************************************/	
d887 1
a887 1
	  public void respawnMob( MobKey key, XYloc location )
d889 2
d914 2
d918 20
a937 2
			round = 0;					  
		unlock();
d948 9
a956 6
		PlayerCharacter thePlayer = playerCache.getPlayer( pId );
		Mob theMob = myMap.getMob( (MobKey)thePlayer.getTarget() );
		thePlayer.clearTargetData();
		theMob.kill();
		if( myMap.checkLoc( loc ) && !myPlayer.getId().equals( pId ) )
			comm.printMessage( thePlayer.getName() + " kills the " + theMob.getName() );
d967 1
d969 3
a971 1
		TextMessage roomDesc = myMap.getCurrentRoomDescription();			
d975 1
d985 1
d991 1
d999 1
d1008 4
a1011 1
						if( thePlayer.getTarget() != null )
d1017 2
a1018 2
								playerName.append( thePlayer.getName() + " is fighting " +
								pName );
d1027 2
a1028 1
				comm.printMessage( playerName.toString(), Color.gray );
d1116 5
d1128 5
d1153 53
d1213 1
a1213 1
	 public void execute( Command command )
d1215 1
a1215 1
	 {	 
d1235 1
d1239 2
d1244 2
d1247 2
d1253 2
d1276 1
d1282 2
d1292 2
d1297 1
d1300 2
d1303 1
a1303 9
						{
							PlayerCharacter thePlayer = playerCache.getPlayer( currentChallenger );
							thePlayer.getHandle().declineDuel( " has left the area. Duel " +
							"declined.", thePlayer.getId() );
							comm.printMessage( "You have decline " + thePlayer.getName() + 
							"\'s duel." );
							setConsideringDuel( false );
							currentChallenger = null;
							currentPlayerTarget = null;
d1305 1
a1305 1
						}
d1484 1
d1517 1
d1690 2
d1695 1
d1699 2
d1717 1
d1740 6
d1820 6
a1825 2
							comm.printCombatMessage( "You " + attacks[type] + " the " + mobName + "!", 
							                          Color.yellow.darker(), false);							
a1842 1
				String weapon = myPlayer.getEquippedWeapon();
d1844 2
d1854 7
d1867 3
d1877 3
d1882 1
a1882 1
						if( myPlayer.getTarget() != null )
d1884 1
d1886 1
a1886 1
							int damage = myItemData.getCombatBonus( weapon );
d1890 1
d1892 1
a1892 7
							{
								comm.printMessage( "You kill the " + mobName + "." );
								theMobTarget= null;								
								myPlayer.clearTargetData();
								if( mySession != null )
									mySession.notifyMobDeath( myMap.getCurrentPlayerLocation(), myPlayer.getId() );
							}
d1896 4
a1899 4
						{
							String pName = playerCache.getPlayer( thePlayerTarget ).getName();
							targetHandle.printAttack();
							comm.printCombatMessage( "You attack " + pName + "!", Color.blue.darker(), false );
d1918 5
d1952 3
a1954 2
						PlayerCharacter thePlayer = playerCache.getPlayer( pId );
						if( thePlayer.isInCombat() )
d1956 2
d1960 1
a1960 1
							Game theGame = thePlayer.getHandle();
d1962 1
a1962 1
							comm.printMessage( "You challenge " + thePlayer.getName() + 
a1981 1
					currentPlayerTarget = null;
d1994 2
a1995 1
					thePlayerTarget = currentChallenger;
d1997 1
a1997 3
					targetHandle = theHandle;
					myPlayer.registerTarget( currentChallenger );
					mySession.notifyFight( thePlayerTarget, myPlayer.getId(), myMap.getCurrentPlayerLocation() );
d2011 2
d2022 1
a2022 1
		}
@


1.10
log
@*** empty log message ***
@
text
@d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.9 2004/06/22 15:18:42 rjw2183 Exp rjw2183 $
d802 1
a802 4
		{
			System.err.println( theMove.getName() + " has called moveMob." );
			mySession.processMove( theMove );
		}
@


1.9
log
@*** empty log message ***
@
text
@d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.8 2004/06/17 15:53:18 rjw2183 Exp rjw2183 $
d375 1
a375 2
				myMap.refreshMobTimer( theMove.getKey() );	
				System.err.println( theMove.getName() + "\'s direction: " + theMove.getDirection() );
d378 1
a378 2
					String name = theMove.getName();
					System.err.println( theMove.getName() + " before calling moveMob on the Map." );
@


1.8
log
@*** empty log message ***
@
text
@d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.7 2004/06/16 19:58:35 rjw2183 Exp rjw2183 $
d40 1
a40 2
	// Data members

d49 5
d58 4
a61 6
	private GameDiscovery allGames; //  An omnihandle to all the games in the system
	private Random intervalPRNG; // prng used to do reports
	private Timer reportTimer; // timer used to do reports
	private Timer attackTimer; // timer used to notify when the p;layer has balance
	private PlayerCommunicator comm; // used to talk to the player
	private String[] attacks;
d66 3
a68 3
	private boolean consideringDuel;
	private Eoid currentChallenger;
	private Eoid currentPlayerTarget;
d70 1
d72 5
a76 1
	private TimeManager myTimeManager;
d80 2
a81 1
	private ItemData myItemData;  // the item data of the game
d144 1
d192 1
d204 1
d352 1
a352 1
						Mob theMob = myMap.getMob( theMove.getLoc( MoveData.FROM ), thePlayer.getTarget() );
d374 3
a376 2
				MobMove theMove = (MobMove)aMove;
				myMap.refreshMobTimer( theMove.getKey(), theMove.getLoc(MoveData.FROM) );												;
d380 1
d420 1
a420 1
				Mob theMob = myMap.getMob( null, thePlayer.getTarget() );
d563 1
a563 1
		Mob theMob = myMap.getMob( loc, theKey );
d619 1
a619 1
		myPlayer.registerPlayerTarget( pId );
d628 2
a629 2
		playerOne.registerPlayerTarget( p2 );
		playerTwo.registerPlayerTarget( p1 );
d802 1
a802 1
	{
d804 2
d807 1
d826 17
d885 1
a885 2
						System.err.println( "here" );
						if( thePlayer.getPTarget() != null )
d887 1
a887 1
							Eoid pId = thePlayer.getPTarget();
d1004 1
a1004 2
			case Command.SEND:
			case Command.EQUIP:
d1054 1
d1084 1
a1084 1
						Mob theMob = myMap.getMob( myMap.getCurrentPlayerLocation(), myPlayer.getTarget() );
d1538 2
a1539 1
				if( status == Room.NO_SUCH_MOB && theMobTarget == null )
d1544 1
a1544 1
				else if( status == Room.NO_FREE_MOB && theMobTarget == null )
d1654 13
a1666 2
							comm.printCombatMessage( "You " + attacks[type] + " the " + mobName + "!", 
						                          Color.yellow.darker(), false);							
d1673 1
d1763 1
a1763 1
					myPlayer.registerPlayerTarget( currentChallenger );
d1770 5
@


1.7
log
@*** empty log message ***
@
text
@d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.6 2004/06/16 00:51:32 rjw2183 Exp rjw2183 $
d574 1
a574 1
			challenger.getHandle().declineDuel( "is already considering another duel.", myPlayer.getId() );
d617 1
d621 1
a621 2
			comm.printMessage( playerOne.getName() + " and " + playerTwo.getName() + " begin fighting!" );
		unlock();
d831 1
d850 16
d953 1
a953 1
		comm.setStatus(true, hasBalance );
d978 1
d999 2
a1000 1
		else if( myPlayer.isInCombat() && !checkValidCombatCommand( command.getType() ) )
d1025 1
a1025 1
					comm.printMessage( myMap.getCurrentRoomDescription() );					
d1045 4
a1048 1
				if( myPlayer.isInCombat() )
d1050 30
a1079 5
					Mob theMob = myMap.getMob( myMap.getCurrentPlayerLocation(), myPlayer.getTarget() );
					theMob.unregisterAttacker();
					myPlayer.clearTargetData();
					comm.clearCombatLog();
					comm.printMessage( "You disengage combat with " + theMob.getName() + "!" );
a1080 11
				
				UserMove movement = myMap.doPlayerMove( ((IntCommand)command).getIntValue() );				
				if( movement != null )
				{
					printCurrentRoom();
					movement.setUser( myPlayer.getId() );
					if( mySession != null )
						mySession.processMove( movement );					
				}					
				else
					comm.printError( "You can not move in that direction." );
d1501 5
d1603 1
a1603 1
				if( theMobTarget == null || thePlayerTarget == null && canAttack )
d1682 2
d1692 12
a1703 5
				Game theHandle = playerCache.getPlayer( currentChallenger ).getHandle();
				theHandle.declineDuel( " has declined your challenge.", myPlayer.getId() );
				setConsideringDuel( false );
				currentChallenger = null;
				currentPlayerTarget = null;
d1708 15
a1722 8
				Game theHandle = playerCache.getPlayer( currentChallenger ).getHandle();
				theHandle.acceptDuel( myPlayer.getId() );
				thePlayerTarget = currentChallenger;
				currentChallenger = null;
				targetHandle = playerCache.getPlayer( thePlayerTarget ).getHandle();
				myPlayer.registerPlayerTarget( currentChallenger );
				mySession.notifyFight( currentChallenger, myPlayer.getId(), myMap.getCurrentPlayerLocation() );
				setConsideringDuel( false );
@


1.6
log
@*** empty log message ***
@
text
@d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.5 2004/06/15 19:51:41 rjw2183 Exp rjw2183 $
d61 7
a67 1
	private boolean hasBalance;
d131 6
a136 1
		
d338 9
d564 67
d802 1
d804 4
a807 1
		                          Color.red.darker(), true );
d932 1
a932 1
	public synchronized void setBalance( boolean balance )
d940 7
d959 2
d1026 10
a1035 1
				UserMove movement = myMap.doPlayerMove( ((IntCommand)command).getIntValue() );
d1074 1
a1074 2
					comm.printMessage( "Game " + mySessionName + " created!" );	
					
d1190 2
a1191 1
						comm.printMessage( id + ": " + desc + ", cost " + cost + "gold pieces" );
d1486 2
d1489 2
d1536 1
d1548 120
@


1.5
log
@*** empty log message ***
@
text
@d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.4 2004/06/11 19:16:08 rjw2183 Exp rjw2183 $
d532 1
d540 1
a540 1
			myState.updateMobAttacker( theMob.getKey(), playerId );
d715 2
a716 1
		comm.printMessage( "The " + name + " attacks you and hits for " + damage + " hit points!" );
d745 1
d749 13
a761 5
				String name = playerCache.getPlayer( temp ).getName();
				if( name != null )
					playerName.append( " " + name );
			}										
			comm.printMessage( playerName.toString(), Color.gray );
d848 19
d881 4
d1356 1
a1356 1
				if( status == Room.NO_SUCH_MOB  )
d1361 1
a1361 1
				else if( status == Room.NO_FREE_MOB )
d1410 1
a1410 1
						comm.printError( "You can attack another monster until you have " +
d1420 2
a1421 1
							comm.printMessage( "You " + attacks[type] + " the " + mobName + "!");							
@


1.4
log
@*** empty log message ***
@
text
@d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.3 2004/06/11 17:22:37 rjw2183 Exp $
d57 1
d61 1
d83 18
d109 2
a110 1
		reportTimer = TimerThread.getDefault().createTimer( new ReportTimerTask() );			
d124 1
d144 1
a144 1
				comm.printMessage( "World data not found. Creating and saving new world..." );
d172 1
a172 1
			comm.printMessage( myMap.getCurrentRoomDescription() );
d186 9
d210 4
d311 2
a312 2
	  * Moves a player
	  * @@param theMove The data needed to do a move
d383 7
a389 1
			String name = playerCache.getPlayer( playerId ).getName();
d396 5
d413 5
d434 6
d455 5
a459 1
	public synchronized void addHouse( House theHouse)
d474 4
d488 6
d503 5
d514 1
a514 1
	}
d516 25
a540 4
	private synchronized void doAttack( int damage, String name )
	{
		attemptLock();
		comm.printMessage( "The " + name + " attacks you and hits for " + damage + " hit points!" );
d542 1
a542 1
	}
d705 12
d718 1
d725 13
a737 1
		comm.printMessage( "\n" + myMap.getCurrentRoomDescription() );				
d747 2
a748 1
				playerName.append( " " + name );
d750 2
a751 3
			comm.printMessage( playerName.toString() );
		}
			
d803 5
d825 12
d1283 1
a1283 1
				{				
d1315 5
d1321 3
a1323 1
				if( status == Room.NO_SUCH_MOB )
d1325 2
d1331 1
d1333 6
a1338 1
				else if( status == 0 )
d1340 17
a1356 4
					comm.printMessage( "You " + attacks[type] + " the " + mobName + "!");
					theMobTarget = myMap.getFreeMob( mobName );
					if( theMobTarget == null )
						comm.printError( "Either another player has attacked that mob, " +
d1358 24
a1381 1
					else
d1383 13
a1395 2
						theMobTarget.registerAttacker( myPlayer.getId() );	
					}					
d1401 1
d1403 1
d1406 1
a1406 2
				myFriendsList.save();
				M2MI.unexport( this );
@


1.3
log
@*** empty log message ***
@
text
@d15 1
a15 1
 * @@version: $Id: GameSystem.java,v 1.2 2004/06/10 18:22:40 rjw2183 Exp rjw2183 $
d24 1
d1158 1
a1158 1
						comm.printMessage( "You can't equip that item!" );									
d1186 1
a1186 1
					comm.printMessage( "You " + attacks[type] + " the " + mobName + "!" );
d1189 1
a1189 1
						comm.printMessage( "Either another player has attacked that mob, " +
@


1.2
log
@*** empty log message ***
@
text
@d15 1
a15 1
 * @@version: $Id$
d37 1
a37 1
implements Game, GCWindowListener, TimeListener, MerchantListener, MobTarget
d230 1
a230 1
		myMap.processState( myState, this, mySession );					
d438 7
a568 1
			attemptLock();
d572 1
a572 2
				mySession.merchantBroadcast( merchantType, location );
			unlock();
a583 1
	 	attemptLock();
d585 2
a586 4
		{
			
		}
		unlock();
d598 9
d784 1
a784 1
					myMap.spawnMobs( mySession );
d1189 5
a1193 1
						    		   "or it have moved out of the area." );					
@


1.1
log
@Initial revision
@
text
@d1 17
d669 17
d710 1
a710 1
					myPlayer = PlayerCharacter.createNewCharacter( (CreateCommand)command, myHandle );										
d727 1
a727 1
				comm.printError( ((InvalidCommand)command).getMessage() + ": Invalid Command" );
d741 1
a741 1
				UserMove movement = myMap.doPlayerMove( ((MoveCommand)command).getDirection() );
d756 1
a756 1
				comm.printMessage( "You yell, \"" + ((MessageCommand)command).getMessage() + "\"" );
d758 1
a758 1
					mySession.yell( ((MessageCommand)command).getMessage(), myPlayer.getId() );	
d768 1
a768 1
					mySessionName = ((CreateGameCommand)command).getName();
d823 1
a823 1
				comm.printMessage( "You say, \"" + ((MessageCommand)command).getMessage() + "\"" );
d827 1
a827 1
						myMap.getCurrentPlayerLocation(), ((MessageCommand)command).getMessage() );
d857 1
a857 15
				boolean attach = ((SessionCommand)command).getWhich();
				StringBuffer message = null;
				if( attach )
				{
					message = new StringBuffer( "Attaching " );
					((Multihandle)mySession).attach( this );
				}
				else
				{
					message = new StringBuffer( "Detaching " );
					((Multihandle)mySession).detach( this );
				}
				message.append( "to session." );                                                                               

				comm.printMessage( message.toString() );
d870 2
a871 2
				int x = ((GotoCommand)command).x;
				int y = ((GotoCommand)command).y;
d904 2
a905 3
			case Command.TRANSACTION:
			{
				BuySellCommand trans = (BuySellCommand)command;
d908 8
a915 29
				{
					String id = trans.getItemId();
					int amount = trans.getAmount();
					
					switch( trans.getCommandType() )
					{						
						case BuySellCommand.BUY:
						{					
							Vector merchItems = myItemData.getIdVector( type );
							if( merchItems.indexOf( id ) != -1 )
							{
								int totalCost = amount * myItemData.lookupCost( id );
								if( myPlayer.canAfford( totalCost ) )
								{
									myPlayer.addItem( id, amount );
									myPlayer.decrementGold( totalCost );
									String desc = myItemData.getDesc( id );
									comm.printMessage
									( "You buy the " + desc + " for " + totalCost +
									  "gold pieces." ); 
								}
								else
									comm.printMessage( "You can't afford that!" );
							}
							else
								comm.printMessage( "That item is not for sale." );
						}
						break;
						case BuySellCommand.SELL:
d917 6
a922 17
							int sellAmount = myPlayer.getItemAmount( id );
							if( sellAmount > 0 )
							{
								int finalAmount = 0;
								if( amount > sellAmount )
									finalAmount = sellAmount;
								else
									finalAmount = amount;
								myPlayer.addItem( id, -1 * finalAmount );								
								int amountEarned = finalAmount * myItemData.lookupSellValue( id );
								myPlayer.incrementGold( amountEarned );
								comm.printMessage( "You sell " + finalAmount + " of " + 
								myItemData.getDesc( id ) + " for " + amountEarned + 
								" goldPieces." );
							}
							else
								comm.printMessage( "You do not have any of that item." );		
d924 2
a925 1
						break;
d927 2
d931 1
a931 1
					comm.printError( "There is no merchant present." );
d934 4
a937 6
			case Command.PLAYER:
			{				
				PlayerCommand playerComm = (PlayerCommand)command;
				String pName = playerComm.getPlayerName();
				int numPlayers = playerCache.getNameCount( pName );				
				if( playerComm.getCommandType() == PlayerCommand.LOOKUP )
d939 4
a942 10
					comm.printMessage( "Performing lookup for " + pName );
					lookupVector.clear();
					playerCache.performLookup( pName, lookupVector );
					printLookup();
				}
				else
				{
					if( numPlayers == 0 )
						comm.printError( pName + " is not in this world." );		
					else if( numPlayers > 1 )
d944 11
a954 4
						comm.printError( "There are too many characters of that name.  If you want " +
						"to send a private message or add this player to your friends' listing, you " +
						"must perform a lookup on that name and use the index of the lookup listing " +
						"along with an l command (lsend, ladd) to perform that action."  );
d957 1
a957 21
					{
						switch( playerComm.getCommandType() )
						{
							case PlayerCommand.ADD:
							{
								myFriendsList.addPlayer( playerCache.lookupByName( pName ) );
								comm.printMessage( pName + " has been added to your friends\' "
								+ " listing." );
							}
							break;
							case PlayerCommand.SEND:
							{
								Game theHandle = playerCache.lookupByName( playerComm.getPlayerName() ).getHandle();
								theHandle.sendPM( myPlayer.getId(), ((SendCommand)playerComm).getMessage() );
								comm.printMessage( "You send, \"" + ((SendCommand)playerComm).getMessage() + 
								"\" to " + pName + "." );
	
							}
							break;							
						}
					}
d959 2
d962 9
d972 24
d1035 1
a1035 1
			case Command.LOOKUP:
d1037 19
d1060 1
a1060 1
					LookupCommand lCommand = (LookupCommand)command;
d1062 12
a1073 5
					
					if( lCommand.getCommandType() == LookupCommand.LIST )
						printLookup();
					else if( lCommand.getIndex() < lookupVector.size() )
						playerId = (Eoid)lookupVector.elementAt( lCommand.getIndex() );
d1075 13
a1087 3
						comm.printError( "That index is invalid." );
					
					switch( lCommand.getCommandType() )
d1089 3
a1091 13
						case LookupCommand.SEND:
						{							
							PlayerCharacter sendPlayer =
							(PlayerCharacter)playerCache.getPlayer( playerId );
							if( sendPlayer != null )
							{
								Game sendHandle = sendPlayer.getHandle();
								sendHandle.sendPM( myPlayer.getId(),
								((LSendCommand)lCommand).getMessage() );
							}
						}
						break;
						case LookupCommand.CHECK:
d1093 3
a1095 11
							if( myFriendsList.hasPlayer( playerId ) )
							{
								comm.printMessage( myFriendsList.getName( playerId ) + " (" + 
								playerId + ") is in your friends' listing." );
							}
							else
							{
								comm.printMessage( myFriendsList.getName( playerId ) + " (" + 
								playerId + ") is not in your friends' listing." );
							
							}
d1097 3
a1099 13
						break;
						case LookupCommand.ADD:
						{
							PlayerCharacter temp = playerCache.getPlayer( playerId );
							if( temp != null )
							{
								myFriendsList.addPlayer( temp );
								comm.printMessage
								( temp.getName() + " has been added from your friends' listing." );
							}
						}
						break;						
					}					
d1101 1
d1104 5
d1111 1
a1111 1
				String name = myFriendsList.removePlayer( ((RemoveCommand)command).getIndex() );
d1119 1
a1119 2
			{
				int status = myMap.enterHouse( ((EnterCommand)command).getIndex() );
d1124 2
a1125 1
				EquipCommand eComm = (EquipCommand)command;
d1127 1
a1127 1
				if( myPlayer.getItemAmount( eComm.getItemId() ) <= 0 )
d1129 1
a1129 1
				else if( !myItemData.canEquip( eComm.getItemId(), myPlayer.getPlayerClass() ) )
d1133 1
a1133 1
					switch( myItemData.getItemType( eComm.getItemId() ) ) 
d1149 2
a1150 2
						myPlayer.equipItem( eComm.getItemId(), slot );
						String desc = myItemData.getDesc( eComm.getItemId() );
d1162 2
a1163 2
				int type = ((AttackCommand)command).getAttack();
				String mobName = ((AttackCommand)command).getMobName();
d1178 1
a1178 3
						    		   "or it have moved out of the area." );
					else	
						theMobTarget.registerAttack( myPlayer );
@
